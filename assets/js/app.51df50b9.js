(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],u=0,d=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&d.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);d.length;)d.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={1:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"4651773a",3:"c999fa3c",4:"d82326e8",5:"1a2700dd",6:"c4610236",7:"a5bff2b9",8:"4ac93032",9:"a6382527",10:"b989a06e",11:"af7d1f84",12:"2ccdadd9",13:"f0845b06",14:"c6567428",15:"c9994de4",16:"20d95549",17:"9abbc3fb",18:"35af3720",19:"406860f2",20:"5f4c54fa",21:"cbd55d73",22:"17d94390",23:"71f3318d",24:"52e90323",25:"b502869e",26:"6f44735e",27:"1d65aca3",28:"98366502",29:"aeaeb5e3",30:"b3434784",31:"9a104273",32:"b09ab3dc",33:"906f5e48",34:"65f2ade3",35:"638ad7c5",36:"16ab1509",37:"851d308f",38:"9c9c5f69",39:"8da9fa39",40:"252d8608",41:"81e7aef1",42:"c70af93c",43:"acbd19b9",44:"8db3762d",45:"e2e6b96f",46:"748ce323",47:"de2ad0fe",48:"138136b9",49:"3cff77e6",50:"1e264e29",51:"5b27ad72",52:"f45fd595",53:"151f1dbf",54:"689022c8",55:"e46d9867",56:"dc2831a1",57:"7072ff5d",58:"54f07e7e",59:"eafc095d",60:"314af2d6",61:"3862b3af",62:"a4cccce2",63:"dfc009ae",64:"8f216c0d",65:"cb92cce0",66:"7da08f3c",67:"8f5d2a42",68:"6eea4628",69:"b9654bda",70:"97bf8b83",71:"ba0a87e1",72:"84b055cd",73:"7ab818f4",74:"2fac3511",75:"688b385a",76:"e5a15c1b"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",l.name="ChunkLoadError",l.type=r,l.request=i,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;i.push([104,0]),t()}([function(n,e,t){var r=t(56),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(29),a=Function.prototype,i=a.call,o=r&&a.bind.bind(i,i);n.exports=r?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(1),a=t(33),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(70),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){var r=t(0),a=t(56),i=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===i}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(165),a=t(168);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return w}));t(13);const r=/#.*$/,a=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=s(n);return i.test(a)?n:a+".html"+t}function d(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:a,themeConfig:i}=t,o=r&&i.locales&&i.locales[r]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return g(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?g(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function w(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(18),a=t(33),i=t(34),o=t(129),s=t(131);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=i(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var r=t(5),a=t(65),i=t(100),o=t(28),s=t(55),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(17),a=t(150),i=t(151),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){var r=t(5),a=t(14),i=t(36);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(8).Symbol;n.exports=r},function(n,e,t){var r=t(2),a=t(52).f,i=t(16),o=t(112),s=t(38),l=t(66),c=t(125);n.exports=function(n,e){var t,p,u,d,m,h=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[h]||s(h,{}):(r[h]||{}).prototype)for(p in e){if(d=e[p],u=n.dontCallGetSet?(m=a(t,p))&&m.value:t[p],!c(g?p:h+(f?".":"#")+p,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;l(d,u)}(n.sham||u&&u.sham)&&i(d,"sham",!0),o(t,p,d,n)}}},function(n,e,t){var r=t(1),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(2),a=t(62),i=t(7),o=t(64),s=t(60),l=t(59),c=r.Symbol,p=a("wks"),u=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(p,n)||(p[n]=s&&i(c,n)?c[n]:u("Symbol."+n)),p[n]}},function(n,e,t){var r=t(155),a=t(156),i=t(157),o=t(158),s=t(159);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(177);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(46);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,u=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),l=n?"-100":i(t.status||0),p=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&d(a),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){var r=t(9),a=String,i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(48),a=t(53);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(2),a=t(0),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(0),a=t(110),i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var r=t(53),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var r=t(123);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(29),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=t(38),i=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var r=t(2),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(149),a=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(8),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(169),a=t(176),i=t(178),o=t(179),s=t(180);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(6),a=t(46),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(15),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(3),i=t(19),o=Object,s=r("".split);n.exports=a((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,s,l,c=0,p=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,i=a;return r=a=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(x,e),p?b(n):o}function w(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=i}function x(){var n=m();if(w(n))return _(n);s=setTimeout(x,function(n){var t=e-(n-l);return f?d(t,i-(n-c)):t}(n))}function _(n){return s=void 0,v&&r?b(n):(r=a=void 0,o)}function k(){var n=m(),t=w(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(x,e),b(l)}return void 0===s&&(s=setTimeout(x,e)),o}return e=g(e)||0,h(t)&&(p=!!t.leading,i=(f="maxWait"in t)?u(g(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},k.flush=function(){return void 0===s?o:_(m())},k}},function(n,e,t){var r=t(5),a=t(35),i=t(106),o=t(36),s=t(30),l=t(55),c=t(7),p=t(65),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),p)try{return u(n,e)}catch(n){}if(c(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e,t){var r=t(54),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(107),a=t(57);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(31),a=t(0),i=t(58),o=t(59),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,s(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(60);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(61),a=t(3);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,i=t(2),o=t(108),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(a=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(63),a=t(37);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.28.0",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.28.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){var r=t(5),a=t(3),i=t(99);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(7),a=t(118),i=t(52),o=t(14);n.exports=function(n,e,t){for(var s=a(e),l=o.f,c=i.f,p=0;p<s.length;p++){var u=s[p];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(135),a=t(28),i=t(136);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(21),a=t(160),i=t(161),o=t(162),s=t(163),l=t(164);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(15),a=t(41);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(181),a=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,s))}},function(n,e,t){var r=t(77),a=t(184),i=t(78);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,u=e.length;if(p!=u&&!(c&&u>p))return!1;var d=l.get(n),m=l.get(e);if(d&&m)return d==e&&m==n;var h=-1,g=!0,f=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var v=n[h],b=e[h];if(o)var y=c?o(b,v,h,e,n,l):o(v,b,h,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!a(e,(function(n,e){if(!i(f,e)&&(v===n||s(v,n,t,o,l)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(42),a=t(182),i=t(183);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(194),a=t(200),i=t(83);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(8),a=t(196),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(197),a=t(198),i=t(199),o=i&&i.isTypedArray,s=o?a(o):r;n.exports=s},function(n,e,t){var r=t(73),a=t(44);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(8),"Set");n.exports=r},function(n,e,t){var r=t(41);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(88),a=t(25);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(6),a=t(45),i=t(211),o=t(214);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(147),a=t(152),i=t(223),o=t(231),s=t(240),l=t(103),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,s=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(249),a=t(250),i=t(251),o=!1,s=t(252).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function u(n,t){var a,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),r.existsSync(i)&&(a=i)),a||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),r.existsSync(i)}))&&(a=i),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function d(n,t){var r,a=n.filename,i=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;i||(t=h(a).toString().replace(p,""))}else if(!i){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=h(a).toString().replace(p,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function m(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=d(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=d(n)(t)}catch(n){return r(n)}r(null,a)}function h(n){return e.fileLoader(n)}function g(n,e,t,r,a){var i=e.split("\n"),o=Math.max(r-3,0),s=Math.min(i.length,r+3),l=a(t),c=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,i=a.extname,o=(0,a.resolve)(t?e:r(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&i.shallowCopyFromList(a,r,l),d(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),o={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?i.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=a):e={},m(o,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),r=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",p=0;p<r.destructuredLocals.length;p++){var m=r.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}o+=c+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var a=i.shallowCopy({},n);return t&&(a=i.shallowCopy(a,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=u(n,t),d(t)}(e,r)(a)},g])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var f=r.filename,v=a.basename(f,a.extname(f));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var d,m,g,f,b,y;if(0===l.indexOf(o+a)&&0!==l.indexOf(o+a+a)&&(m=r[c+2])!=a+s&&m!="-"+a+s&&m!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(g=l.match(/^\s*include\s+(\S+)/))&&(d=r[c-1])&&(d==o+a||d==o+a+"-"||d==o+a+"_"))return f=i.shallowCopy({},t.opts),b=function(n,e){var t,r,a=i.shallowCopy({},e);r=h(t=u(n,a)).toString().replace(p,""),a.filename=t;var o=new v(r,a);return o.generateSource(),{source:o.source,filename:t,template:r}}(g[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(g[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=v.modes.EVAL;break;case r+t+"=":this.mode=v.modes.ESCAPED;break;case r+t+"-":this.mode=v.modes.RAW;break;case r+t+"#":this.mode=v.modes.COMMENT;break;case r+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(243),t(4)),i=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(244),t(4)),i=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),a=t(9),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var r=t(5),a=t(3);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(62),a=t(64),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var r=t(1),a=t(7),i=t(30),o=t(120).indexOf,s=t(49),l=r([].push);n.exports=function(n,e){var t,r=i(n),c=0,p=[];for(t in r)!a(s,t)&&a(r,t)&&l(p,t);for(;e.length>c;)a(r,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(255)},function(n,e,t){"use strict";var r=t(18),a=t(126).left,i=t(127),o=t(61);r({target:"Array",proto:!0,forced:!t(128)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(35),a=t(9),i=t(57),o=t(109),s=t(111),l=t(20),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,l=o(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(32),a=t(54);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(35),a=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!i(s=r(t,n)))return s;if(a(t=n.valueOf)&&!i(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!i(s=r(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(14),i=t(113),o=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(1),a=t(3),i=t(0),o=t(7),s=t(5),l=t(114).CONFIGURABLE,c=t(115),p=t(116),u=p.enforce,d=p.get,m=String,h=Object.defineProperty,g=r("".slice),f=r("".replace),v=r([].join),b=s&&!a((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),w=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+f(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return o(r,"source")||(r.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=w((function(){return i(this)&&d(this).source||c(this)}),"toString")},function(n,e,t){var r=t(5),a=t(7),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=a(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(0),i=t(37),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var r,a,i,o=t(117),s=t(2),l=t(9),c=t(16),p=t(7),u=t(37),d=t(101),m=t(49),h=s.TypeError,g=s.WeakMap;if(o||u.state){var f=u.state||(u.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,r=function(n,e){if(f.has(n))throw h("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},i=function(n){return f.has(n)}}else{var v=d("state");m[v]=!0,r=function(n,e){if(p(n,v))throw h("Object already initialized");return e.facade=n,c(n,v,e),e},a=function(n){return p(n,v)?n[v]:{}},i=function(n){return p(n,v)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),a=t(0),i=r.WeakMap;n.exports=a(i)&&/native code/.test(String(i))},function(n,e,t){var r=t(31),a=t(1),i=t(119),o=t(124),s=t(28),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(102),a=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(30),a=t(121),i=t(34),o=function(n){return function(e,t,o){var s,l=r(e),c=i(l),p=a(o,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(67),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(67),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),a=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==p||t!=c&&(a(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(32),a=t(33),i=t(48),o=t(34),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=a(e),u=i(p),d=o(p),m=n?d-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:d<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:d>m;m+=h)m in u&&(c=t(c,u[m],m,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(19);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(5),a=t(130),i=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(19);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(18),a=t(2),i=t(133),o=t(134),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var r=t(29),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var r=t(31),a=t(7),i=t(16),o=t(58),s=t(68),l=t(66),c=t(137),p=t(138),u=t(139),d=t(143),m=t(144),h=t(5),g=t(63);n.exports=function(n,e,t,f){var v=f?2:1,b=n.split("."),y=b[b.length-1],w=r.apply(null,b);if(w){var x=w.prototype;if(!g&&a(x,"cause")&&delete x.cause,!t)return w;var _=r("Error"),k=e((function(n,e){var t=u(f?e:n,void 0),r=f?new w(n):new w;return void 0!==t&&i(r,"message",t),m(r,k,r.stack,2),this&&o(x,this)&&p(r,this,k),arguments.length>v&&d(r,arguments[v]),r}));if(k.prototype=x,"Error"!==y?s?s(k,_):l(k,_,{name:!0}):h&&"stackTraceLimit"in w&&(c(k,w,"stackTraceLimit"),c(k,w,"prepareStackTrace")),l(k,w),!g)try{x.name!==y&&i(x,"name",y),x.constructor=k}catch(n){}return k}}},function(n,e,t){var r=t(1),a=t(32);n.exports=function(n,e,t){try{return r(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var r=t(0),a=String,i=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(14).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),a=t(9),i=t(68);n.exports=function(n,e,t){var o,s;return i&&r(o=e.constructor)&&o!==t&&a(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var r=t(140);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(141),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(142),a=t(0),i=t(19),o=t(20)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(r=i(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(20)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(16);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(16),a=t(145),i=t(146),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){var r=t(1),a=Error,i=r("".replace),o=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var r=t(3),a=t(36);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(69),a=t(148);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=a),s||(s=[]);++l<c;){var p=e[l];t>0&&i(p)?t>1?n(p,t-1,i,o,s):r(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var r=t(17),a=t(39),i=t(6),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(15),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(17),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(153),a=t(209),i=t(47),o=t(6),s=t(220);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(154),a=t(208),i=t(86);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(71),a=t(75);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],u=n[p],d=c[1];if(l&&c[2]){if(void 0===u&&!(p in n))return!1}else{var m=new r;if(i)var h=i(u,d,p,n,e,m);if(!(void 0===h?a(d,u,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(22),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(22);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(21),a=t(40),i=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(73),a=t(166),i=t(41),o=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,u=c.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?d:s).test(o(n))}},function(n,e,t){var r,a=t(167),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(8)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(170),a=t(21),i=t(40);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(171),a=t(172),i=t(173),o=t(174),s=t(175);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(23);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(23),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(23),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(24);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(24);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(71),a=t(76),i=t(185),o=t(188),s=t(204),l=t(6),c=t(80),p=t(82),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),v=l(e),b=f?"[object Array]":s(n),y=v?"[object Array]":s(e),w=(b="[object Arguments]"==b?u:b)==u,x=(y="[object Arguments]"==y?u:y)==u,_=b==y;if(_&&c(n)){if(!c(e))return!1;f=!0,w=!1}if(_&&!w)return g||(g=new r),f||p(n)?a(n,e,t,m,h,g):i(n,e,b,t,m,h,g);if(!(1&t)){var k=w&&d.call(n,"__wrapped__"),j=x&&d.call(e,"__wrapped__");if(k||j){var S=k?n.value():n,E=j?e.value():e;return g||(g=new r),h(S,E,t,m,g)}}return!!_&&(g||(g=new r),o(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(17),a=t(186),i=t(72),o=t(76),s=t(187),l=t(43),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=d.get(n);if(g)return g==e;r|=2,d.set(n,e);var f=o(m(n),m(e),r,c,u,d);return d.delete(n),f;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(8).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(189),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var u=p;u--;){var d=c[u];if(!(l?d in e:a.call(e,d)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++u<p;){var v=n[d=c[u]],b=e[d];if(i)var y=l?i(b,v,d,e,n,s):i(v,b,d,n,e,s);if(!(void 0===y?v===b||o(v,b,t,i,s):y)){g=!1;break}f||(f="constructor"==d)}if(g&&!f){var w=n.constructor,x=e.constructor;w==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof x&&x instanceof x||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(190),a=t(191),i=t(79);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(69),a=t(6);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(192),a=t(193),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(195),a=t(39),i=t(6),o=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),p=!t&&a(n),u=!t&&!p&&o(n),d=!t&&!p&&!u&&l(n),m=t||p||u||d,h=m?r(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||d&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(15),a=t(44),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(70),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(50)(n))},function(n,e,t){var r=t(201),a=t(202),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(203)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(205),a=t(40),i=t(206),o=t(84),s=t(207),l=t(15),c=t(74),p=c(r),u=c(a),d=c(i),m=c(o),h=c(s),g=l;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||i&&"[object Promise]"!=g(i.resolve())||o&&"[object Set]"!=g(new o)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(10)(t(8),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(8),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(8),"WeakMap");n.exports=r},function(n,e,t){var r=t(85),a=t(79);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(75),a=t(210),i=t(217),o=t(45),s=t(85),l=t(86),c=t(25);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(87);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(212),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(213);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(42);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(215);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(17),a=t(216),i=t(6),o=t(46),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(218),a=t(219);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(88),a=t(39),i=t(6),o=t(81),s=t(44),l=t(25);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,u=!1;++c<p;){var d=l(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=p?u:!!(p=null==n?0:n.length)&&s(p)&&o(d,p)&&(i(n)||a(n))}},function(n,e,t){var r=t(221),a=t(222),i=t(45),o=t(25);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(87);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(47),a=t(224),i=t(226);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(225),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=a(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(227),a=t(230)(r);n.exports=a},function(n,e,t){var r=t(228),a=t(229),i=t(47),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(77),a=t(232),i=t(237),o=t(78),s=t(238),l=t(43);n.exports=function(n,e,t){var c=-1,p=a,u=n.length,d=!0,m=[],h=m;if(t)d=!1,p=i;else if(u>=200){var g=e?null:s(n);if(g)return l(g);d=!1,p=o,h=new r}else h=e?[]:m;n:for(;++c<u;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,d&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(f)}else p(h,v,t)||(h!==m&&h.push(v),m.push(f))}return m}},function(n,e,t){var r=t(233);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(234),a=t(235),i=t(236);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(84),a=t(239),i=t(43),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(83),a=t(12);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(18),a=t(2),i=t(248);r({global:!0},{Reflect:{}}),i(a.Reflect,"Reflect",!0)},function(n,e,t){var r=t(14).f,a=t(7),i=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,i)&&r(n,i,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var i=a>=0?arguments[a]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),i=r(t.split("/")),o=Math.min(a.length,i.length),s=o,l=0;l<o;l++)if(a[l]!==i[l]){s=l;break}var c=[];for(l=s;l<a.length;l++)c.push("..");return(c=c.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!a){r=i;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===r&&(a=!1,r=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!a){t=o+1;break}}return-1===e||-1===r||0===i||1===i&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var x=Object.prototype.hasOwnProperty;function _(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,S=k((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),E=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,C=k((function(n){return n.replace(T,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function D(n,e,t){}var B=function(n,e,t){return!1},M=function(n){return n};function z(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return z(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return z(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(z(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function H(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var J=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:D,parsePlatformTagName:M,mustUseProp:B,async:!0,_lifecycleHooks:F},$=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function G(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat($.source,".$_\\d]"));var V="__proto__"in{},q="undefined"!=typeof window,X=q&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),Z=X&&X.indexOf("msie 9.0")>0,Y=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var Q=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(q)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,a,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function fn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var wn=[];function xn(n){wn.push(n),yn.target=n}function _n(){wn.pop(),yn.target=wn[wn.length-1]}var kn=Array.prototype,jn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];G(jn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var Sn=Object.getOwnPropertyNames(jn),En={},Tn=!0;function Cn(n){Tn=n}var An={notify:D,depend:D,addSub:D,removeSub:D},In=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?An:new yn,this.vmCount=0,G(n,"__ob__",this),a(n)){if(!t)if(V)n.__proto__=jn;else for(var r=0,i=Sn.length;r<i;r++){G(n,s=Sn[r],jn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;On(n,s=o[r],En,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&_(n,"__ob__")&&n.__ob__ instanceof In?n.__ob__:!Tn||!t&&on()||!a(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Hn(n)||n instanceof mn?void 0:new In(n,e,t)}function On(n,e,t,r,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==En&&2!==arguments.length||(t=n[e]);var u=!i&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),u&&(u.dep.depend(),a(e)&&Mn(e))),Hn(e)&&!i?e.value:e},set:function(e){var r=c?c.call(n):t;if(H(r,e)){if(p)p.call(n,e);else{if(c)return;if(!i&&Hn(r)&&!Hn(e))return void(r.value=e);t=e}u=!i&&Pn(e,!1,o),s.notify()}}}),s}}function Dn(n,e,t){if(!Rn(n)){var r=n.__ob__;return a(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(On(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(a(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Rn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Mn(e)}function zn(n){return Ln(n,!0),G(n,"__v_isShallow",!0),n}function Ln(n,e){if(!Rn(n)){Pn(n,e,on());0}}function Rn(n){return!(!n||!n.__v_isReadonly)}function Hn(n){return!(!n||!0!==n.__v_isRef)}function Jn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Hn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Hn(r)&&!Hn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function $n(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Nn=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Gn(n,e){function t(){var n=t.fns;if(!a(n))return Te(n,null,arguments,e,"v-on handler");for(var r=n.slice(),i=0;i<r.length;i++)Te(r[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,a,o){var l,c,p,u;for(l in n)c=n[l],p=e[l],u=Nn(l),i(c)||(i(p)?(i(c.fns)&&(c=n[l]=Gn(c,o)),s(u.once)&&(c=n[l]=a(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)i(n[l])&&r((u=Nn(l)).name,e[l],u.capture)}function Vn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}i(a)?r=Gn([l]):o(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Gn([a,l]),r.merged=!0,n[e]=r}function qn(n,e,t,r,a){if(o(e)){if(_(e,t))return n[t]=e[t],a||delete e[t],!0;if(_(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Xn(n){return l(n)?[gn(n)]:a(n)?function n(e,t){var r,c,p,u,d=[];for(r=0;r<e.length;r++)i(c=e[r])||"boolean"==typeof c||(p=d.length-1,u=d[p],a(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Kn(u)&&(d[p]=gn(u.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Kn(u)?d[p]=gn(u.text+c):""!==c&&d.push(gn(c)):Kn(c)&&Kn(u)?d[p]=gn(u.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Kn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Zn(n,e){var t,r,i,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,r=i.length;t<r;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=P(P({},r),t)),a=i(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function Qn(n){return It(this.$options,"filters",n,!0)||M}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var i=U.keyCodes[e]||t;return a&&r&&!U.keyCodes[e]?ne(a,r):i?ne(i,n):r?C(r)!==e:void 0===n}function te(n,e,t,r,i){if(t)if(p(t)){a(t)&&(t=O(t));var o=void 0,s=function(a){if("class"===a||"style"===a||y(a))o=n;else{var s=n.attrs&&n.attrs.type;o=r||U.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(a),c=C(a);l in o||c in o||(o[a]=t[a],i&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ie(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(d(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];a(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ae,n._n=v,n._s=f,n._l=Zn,n._t=Yn,n._q=z,n._i=L,n._m=re,n._f=Qn,n._k=ee,n._b=te,n._v=gn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=pe}function de(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,a){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!o&&!a.$hasNormal)return a;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=fe(n,t,c,e[c]))}else i={};for(var p in t)p in i||(i[p]=ve(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),G(i,"$stable",s),G(i,"$key",l),G(i,"$hasNormal",o),i}function fe(n,e,t,r){var i=function(){var e=un;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),i=(t=t&&"object"==typeof t&&!a(t)?[t]:Xn(t))&&t[0];return dn(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};G(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:A(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Jn(n,e,t)}))}}}function ye(n,e,t,r,a){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,we(n,o,r,a));for(var o in n)o in e||(i=!0,delete n[o]);return i}function we(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function ke(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function je(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function Se(n,e,t,r,u,d){return(a(t)||l(t))&&(u=r,r=t,t=void 0),s(d)&&(u=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Xn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,d;if("string"==typeof e){var m=void 0;d=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),u=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(m=It(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):wt(m,t,n,r,e)}else u=wt(e,t,n,r);return a(u)?u:o(u)?(o(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];o(c.tag)&&(i(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,d),o(t)&&function(n){p(n.style)&&Ue(n.style);p(n.class)&&Ue(n.class)}(t),u):hn()}(n,e,t,r,u)}function Ee(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Ce(n,r,"errorCaptured hook")}}Ce(n,e,t)}finally{_n()}}function Te(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&g(i)&&!i._handled&&(i.catch((function(n){return Ee(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){Ee(n,r,a)}return i}function Ce(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ae(e,null,"config.errorHandler")}Ae(n,e,t)}function Ae(n,e,t){if(!q||"undefined"==typeof console)throw n;console.error(n)}var Ie,Pe=!1,Oe=[],De=!1;function Be(){De=!1;var n=Oe.slice(0);Oe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Me=Promise.resolve();Ie=function(){Me.then(Be),Q&&setTimeout(D)},Pe=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ie="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Be)}:function(){setTimeout(Be,0)};else{var ze=1,Le=new MutationObserver(Be),Re=document.createTextNode(String(ze));Le.observe(Re,{characterData:!0}),Ie=function(){ze=(ze+1)%2,Re.data=String(ze)},Pe=!0}function He(n,e){var t;if(Oe.push((function(){if(n)try{n.call(e)}catch(n){Ee(n,e,"nextTick")}else t&&t(e)})),De||(De=!0,Ie()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Je(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=Et(r[e],t)}(t,n,e)}}Je("beforeMount"),Je("mounted"),Je("beforeUpdate"),Je("updated"),Je("beforeDestroy"),Je("destroyed"),Je("activated"),Je("deactivated"),Je("serverPrefetch"),Je("renderTracked"),Je("renderTriggered"),Je("errorCaptured");var Fe=new cn;function Ue(n){return function n(e,t){var r,i,o=a(e);if(!o&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Hn(e))n(e.value,t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,Fe),Fe.clear(),n}var $e,Ne=0,Ge=function(){function n(n,e,t,r,a){var i,o;i=this,void 0===(o=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(o=Fn),o&&o.active&&o.effects.push(i),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ne,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=D)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ee(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Te(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){$e.$on(n,e)}function Ve(n,e){$e.$off(n,e)}function qe(n,e){var t=$e;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Xe(n,e,t){$e=n,Wn(e,t||{},We,Ve,qe,n),$e=void 0}var Ke=null;function Ze(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),xn();var a=un;r&&dn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Te(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&dn(a),_n()}var et=[],tt=[],rt={},at=!1,it=!1,ot=0;var st=0,lt=Date.now;if(q&&!K){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),it=!0,et.sort(pt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();ot=et.length=tt.length=0,rt={},at=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&U.devtools&&sn.emit("flush")}function dt(n){var e=n.id;if(null==rt[e]&&(n!==yn.target||!n.noRecurse)){if(rt[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,He(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,i,o){var l,c=this,p=o.options;_(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var u=s(p._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||r,this.injections=mt(p.inject,i),this.slots=function(){return c.$slots||ge(i,n.scopedSlots,c.$slots=de(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(i,n.scopedSlots,this.slots())}}),u&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=ge(i,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var o=Se(l,n,e,t,r,d);return o&&!a(o)&&(o.fnScopeId=p._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,r){return Se(l,n,e,t,r,d)}}function gt(n,e,t,r,a){var i=fn(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[S(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){var o=a.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=i;var u=a.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,u,p.data&&p.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,d),e&&n.$options.props){Cn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],v=n.$options.props;m[f]=Pt(f,v,e,n)}Cn(!0),n.$options.propsData=e}c&&(n.$slots=de(i,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Qe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function wt(n,e,t,l,c){if(!i(n)){var u=t.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=_e;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=R((function(t){n.resolved=ke(t,e),a?r.length=0:u(!0)})),m=R((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),h=n(d,m);return p(h)&&(g(h)?i(n.resolved)&&h.then(d,m):g(h.component)&&(h.component.then(d,m),o(h.error)&&(n.errorComp=ke(h.error,e)),o(h.loading)&&(n.loadingComp=ke(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),h.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,a){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(d,e,t,l,c);e=e||{},Gt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[r],l=e.model.callback;o(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(i[r]=[l].concat(s)):i[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var p=C(c);qn(a,l,c,p,!0)||qn(a,s,c,p,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},p=l.props;if(o(p))for(var u in p)c[u]=Pt(u,p,e||r);else o(t.attrs)&&ft(c,t.attrs),o(t.props)&&ft(c,t.props);var d=new ht(t,c,s,i,n),m=l.render.call(null,d._c,d);if(m instanceof mn)return gt(m,t,d.parent,l,d);if(a(m)){for(var h=Xn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=gt(h[f],t,d.parent,l,d);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],a=e[r],i=bt[r];a===i||a&&a._merged||(e[r]=a?xt(i,a):i)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},d)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var _t=D,kt=U.optionMergeStrategies;function jt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,i,o=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(a=n[r],i=e[r],t&&_(n,r)?a!==i&&d(a)&&d(i)&&jt(a,i):Dn(n,r,i));return n}function St(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?jt(r,a):a}:e?n?function(){return jt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Et(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Tt(n,e,t,r){var a=Object.create(n||null);return e?P(a,e):a}kt.data=function(n,e,t){return t?St(n,e,t):e&&"function"!=typeof e?n:St(n,e)},F.forEach((function(n){kt[n]=Et})),J.forEach((function(n){kt[n+"s"]=Tt})),kt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in P(i,n),e){var s=i[o],l=e[o];s&&!a(s)&&(s=[s]),i[o]=s?s.concat(l):a(l)?l:[l]}return i},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return P(a,n),e&&P(a,e),a},kt.provide=function(n,e){return n?function(){var t=Object.create(null);return jt(t,c(n)?n.call(this):n),e&&jt(t,c(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function At(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,o={};if(a(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(o[S(i)]={type:null});else if(d(t))for(var s in t)i=t[s],o[S(s)]=d(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(d(t))for(var o in t){var s=t[o];r[o]=d(s)?P({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=At(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=At(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)_(n,o)||l(o);function l(r){var a=kt[r]||Ct;s[r]=a(n[r],e[r],t,r)}return s}function It(n,e,t,r){if("string"==typeof t){var a=n[e];if(_(a,t))return a[t];var i=S(t);if(_(a,i))return a[i];var o=E(i);return _(a,o)?a[o]:a[t]||a[i]||a[o]}}function Pt(n,e,t,r){var a=e[n],i=!_(t,n),o=t[n],s=Mt(Boolean,a.type);if(s>-1)if(i&&!_(a,"default"))o=!1;else if(""===o||o===C(n)){var l=Mt(String,a.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!_(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Dt(e.type)?r.call(n):r}(r,a,n);var p=Tn;Cn(!0),Pn(o),Cn(p)}return o}var Ot=/^\s*function (\w+)/;function Dt(n){var e=n&&n.toString().match(Ot);return e?e[1]:""}function Bt(n,e){return Dt(n)===Dt(e)}function Mt(n,e){if(!a(e))return Bt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Bt(e[t],n))return t;return-1}var zt={enumerable:!0,configurable:!0,get:D,set:D};function Lt(n,e,t){zt.get=function(){return this[e][t]},zt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,zt)}function Rt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=zn({}),a=n.$options._propKeys=[];n.$parent&&Cn(!1);var i=function(i){a.push(i);var o=Pt(i,e,t,n);On(r,i,o),i in n||Lt(n,"_props",i)};for(var o in e)i(o);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);dn(n),xn();var a=Te(t,null,[n._props||zn({}),r],n,"setup");if(_n(),dn(),c(a))e.render=a;else if(p(a))if(n._setupState=a,a.__sfc){var i=n._setupProxy={};for(var o in a)"__sfc"!==o&&Jn(i,a,o)}else for(var o in a)N(o)||Jn(n,a,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?D:A(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Ee(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&_(r,i)||N(i)||Lt(n,"_data",i)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var i=e[a],o=c(i)?i:i.get;0,r||(t[a]=new Ge(n,o||D,D,Ht)),a in n||Jt(n,a,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var i=0;i<r.length;i++)$t(n,t,r[i]);else $t(n,t,r)}}(n,e.watch)}var Ht={lazy:!0};function Jt(n,e,t){var r=!on();c(t)?(zt.get=r?Ft(e):Ut(t),zt.set=D):(zt.get=t.get?r&&!1!==t.cache?Ft(e):Ut(t.get):D,zt.set=t.set||D),Object.defineProperty(n,e,zt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function $t(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Nt=0;function Gt(n){var e=n.options;if(n.super){var t=Gt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=At(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Vt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=vt(n)||vt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=At(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Lt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Jt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,J.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=P({},o.options),a[r]=o,o}}function qt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Kt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Zt(t,i,r,a)}}}function Zt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Nt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=At(Gt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=de(e._renderChildren,a),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return Se(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Se(n,e,t,r,a,!0)};var i=t&&t.data;On(n,"$attrs",i&&i.attrs||r,null,!0),On(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){On(n,t,e[t])})),Cn(!0))}(e),Rt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var r=$n(n),a=pn?Reflect.ownKeys(t):Object.keys(t),i=0;i<a.length;i++){var o=a[i];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Wt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Dn,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(d(e))return $t(this,n,e,t);(t=t||{}).user=!0;var r=new Ge(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');xn(),Te(e,this,[r.value],this,a),_n()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),a='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Te(t[i],e,r,e,a)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Ze(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return He(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{dn(e),_e=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ee(t,e,"render"),n=e._vnode}finally{_e=null,dn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=i,n}}(Wt);var Yt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:qt(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=je(n),t=e&&e.componentOptions;if(t){var r=qt(t),a=this.include,i=this.exclude;if(a&&(!r||!Xt(a,r))||i&&r&&Xt(i,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:P,mergeOptions:At,defineReactive:On},n.set=Dn,n.delete=Bn,n.nextTick=He,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),J.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=At(this.options,n),this}}(n),Vt(n),function(n){J.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:on}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:ht}),Wt.version="2.7.14";var nr=b("style,class"),er=b("input,textarea,option,select,progress"),tr=b("contenteditable,draggable,spellcheck"),rr=b("events,caret,typing,plaintext-only"),ar=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ir="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return or(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(o(n)||o(e))return ur(n,dr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function dr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=dr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fr=function(n){return hr(n)||gr(n)};var vr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Te(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=Hn(t),m=r.$refs;if(u||d)if(p){var h=u?m[t]:t.value;e?a(h)&&w(h,i):a(h)?h.includes(i)||h.push(i):u?(m[t]=[i],_r(r,t,m[t])):t.value=[i]}else if(u){if(e&&m[t]!==i)return;m[t]=l,_r(r,t,s)}else if(d){if(e&&t.value!==i)return;t.value=s}else 0}}}function _r(n,e,t){var r=n._setupState;r&&_(r,e)&&(Hn(r[e])?r[e].value=t:r[e]=t)}var kr=new mn("",{},[]),jr=["create","activate","update","remove","destroy"];function Sr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||br(r)&&br(a)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Er(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var Tr={create:Cr,update:Cr,destroy:function(n){Cr(n,kr)}};function Cr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===kr,o=e===kr,s=Ir(n.data.directives,n.context),l=Ir(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Or(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(Or(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Or(c[t],"inserted",e,n)};i?Vn(e,"insert",u):u()}p.length&&Vn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)Or(p[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||Or(s[t],"unbind",n,n,o)}(n,e)}var Ar=Object.create(null);function Ir(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Ar),a[Pr(r)]=r,e._setupState&&e._setupState.__sfc){var i=r.def||It(e,"_setupState","v-"+r.name);r.def="function"==typeof i?{bind:i,update:i}:i}r.def=r.def||It(e.$options,"directives",r.name)}return a}function Pr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Or(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){Ee(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Dr=[wr,Tr];function Br(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=P({},p)),p)a=p[r],c[r]!==a&&Mr(l,r,a,e.data.pre);for(r in(K||Y)&&p.value!==c.value&&Mr(l,"value",p.value),c)i(p[r])&&(or(r)?l.removeAttributeNS(ir,sr(r)):tr(r)||l.removeAttribute(r))}}function Mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?zr(n,e,t):ar(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):or(e)?lr(t)?n.removeAttributeNS(ir,sr(e)):n.setAttributeNS(ir,e,t):zr(n,e,t)}function zr(n,e,t){if(lr(t))n.removeAttribute(e);else{if(K&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Lr={create:Br,update:Br};function Rr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var s=cr(e),l=t._transitionClasses;o(l)&&(s=ur(s,dr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Hr,Jr={create:Rr,update:Rr};function Fr(n,e,t){var r=Hr;return function a(){var i=e.apply(null,arguments);null!==i&&Nr(n,a,t,r)}}var Ur=Pe&&!(en&&Number(en[1])<=53);function $r(n,e,t,r){if(Ur){var a=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Hr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Nr(n,e,t,r){(r||Hr).removeEventListener(n,e._wrapper||e,t)}function Gr(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Hr=e.elm||n.elm,function(n){if(o(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,$r,Nr,Fr,e.context),Hr=void 0}}var Wr,Vr={create:Gr,update:Gr,destroy:function(n){return Gr(n,kr)}};function qr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var p=i(r)?"":String(r);Xr(a,p)&&(a.value=p)}else if("innerHTML"===t&&gr(a.tagName)&&i(a.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Wr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Xr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Kr={create:qr,update:qr},Zr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Yr(n){var e=Qr(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Qr(n){return Array.isArray(n)?O(n):"string"==typeof n?Zr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(C(e),t.replace(ta,""),"important");else{var r=ia(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],ia=k((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=S(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function oa(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},u=c||p,d=Qr(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?P({},d):d;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Yr(a.data))&&P(r,t);(t=Yr(n.data))&&P(r,t);for(var i=n;i=i.parent;)i.data&&(t=Yr(i.data))&&P(r,t);return r}(e,!0);for(s in u)i(m[s])&&ra(l,s,"");for(s in m)(a=m[s])!==u[s]&&ra(l,s,null==a?"":a)}}var sa={create:oa,update:oa},la=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,da(n.name||"v")),P(e,n),e}return"string"==typeof n?da(n):void 0}}var da=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ma=q&&!Z,ha="transition",ga="transitionend",fa="animation",va="animationend";ma&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ha="WebkitTransition",ga="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fa="WebkitAnimation",va="webkitAnimationEnd"));var ba=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ya(n){ba((function(){ba(n)}))}function wa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function xa(n,e){n._transitionClasses&&w(n._transitionClasses,e),pa(n,e)}function _a(n,e,t){var r=ja(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var s="transition"===a?ga:va,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,p)}var ka=/\b(transform|all)(,|$)/;function ja(n,e){var t,r=window.getComputedStyle(n),a=(r[ha+"Delay"]||"").split(", "),i=(r[ha+"Duration"]||"").split(", "),o=Sa(a,i),s=(r[fa+"Delay"]||"").split(", "),l=(r[fa+"Duration"]||"").split(", "),c=Sa(s,l),p=0,u=0;return"transition"===e?o>0&&(t="transition",p=o,u=i.length):"animation"===e?c>0&&(t="animation",p=c,u=l.length):u=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&ka.test(r[ha+"Property"])}}function Sa(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ea(e)+Ea(n[t])})))}function Ea(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ta(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ua(n.data.transition);if(!i(r)&&!o(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,g=r.appearActiveClass,f=r.beforeEnter,b=r.enter,y=r.afterEnter,w=r.enterCancelled,x=r.beforeAppear,_=r.appear,k=r.afterAppear,j=r.appearCancelled,S=r.duration,E=Ke,T=Ke.$vnode;T&&T.parent;)E=T.context,T=T.parent;var C=!E._isMounted||!n.isRootInsert;if(!C||_||""===_){var A=C&&m?m:l,I=C&&g?g:d,P=C&&h?h:u,O=C&&x||f,D=C&&c(_)?_:b,B=C&&k||y,M=C&&j||w,z=v(p(S)?S.enter:S);0;var L=!1!==a&&!Z,H=Ia(D),J=t._enterCb=R((function(){L&&(xa(t,P),xa(t,I)),J.cancelled?(L&&xa(t,A),M&&M(t)):B&&B(t),t._enterCb=null}));n.data.show||Vn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),D&&D(t,J)})),O&&O(t),L&&(wa(t,A),wa(t,I),ya((function(){xa(t,A),J.cancelled||(wa(t,P),H||(Aa(z)?setTimeout(J,z):_a(t,s,J)))}))),n.data.show&&(e&&e(),D&&D(t,J)),L||H||J()}}}function Ca(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ua(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,m=r.leave,h=r.afterLeave,g=r.leaveCancelled,f=r.delayLeave,b=r.duration,y=!1!==a&&!Z,w=Ia(m),x=v(p(b)?b.leave:b);0;var _=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(xa(t,c),xa(t,u)),_.cancelled?(y&&xa(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(k):k()}function k(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),y&&(wa(t,l),wa(t,u),ya((function(){xa(t,l),_.cancelled||(wa(t,c),w||(Aa(x)?setTimeout(_,x):_a(t,s,_)))}))),m&&m(t,_),y||w||_())}}function Aa(n){return"number"==typeof n&&!isNaN(n)}function Ia(n){if(i(n))return!1;var e=n.fns;return o(e)?Ia(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pa(n,e){!0!==e.data.show&&Ta(e)}var Oa=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<jr.length;++e)for(r[jr[e]]=[],t=0;t<c.length;++t)o(c[t][jr[e]])&&r[jr[e]].push(c[t][jr[e]]);function u(n){var e=p.parentNode(n);o(e)&&p.removeChild(e,n)}function d(n,e,t,a,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=fn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,a),s(l)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](kr,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,d=n.children,f=n.tag;o(f)?(n.elm=n.ns?p.createElementNS(n.ns,f):p.createElement(f,n),y(n),g(n,d,e),o(u)&&v(n,e),h(t,n.elm,a)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,a)):(n.elm=p.createTextNode(n.text),h(t,n.elm,a))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),y(n)):(xr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function g(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var a=0;a<r.create.length;++a)r.create[a](kr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(kr,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;o(e=Ke)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function w(n,e,t,r,a,i){for(;r<=a;++r)d(t[r],i,n,e,!1,t,r)}function x(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function _(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),x(r)):u(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function j(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&Sr(n,i))return a}}function S(n,e,t,a,l,c){if(n!==e){o(e.elm)&&o(a)&&(e=a[l]=fn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var g=n.children,v=e.children;if(o(h)&&f(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(g)&&o(v)?g!==v&&function(n,e,t,r,a){var s,l,c,u=0,m=0,h=e.length-1,g=e[0],f=e[h],v=t.length-1,b=t[0],y=t[v],x=!a;for(0;u<=h&&m<=v;)i(g)?g=e[++u]:i(f)?f=e[--h]:Sr(g,b)?(S(g,b,r,t,m),g=e[++u],b=t[++m]):Sr(f,y)?(S(f,y,r,t,v),f=e[--h],y=t[--v]):Sr(g,y)?(S(g,y,r,t,v),x&&p.insertBefore(n,g.elm,p.nextSibling(f.elm)),g=e[++u],y=t[--v]):Sr(f,b)?(S(f,b,r,t,m),x&&p.insertBefore(n,f.elm,g.elm),f=e[--h],b=t[++m]):(i(s)&&(s=Er(e,u,h)),i(l=o(b.key)?s[b.key]:j(b,e,u,h))?d(b,r,n,g.elm,!1,t,m):Sr(c=e[l],b)?(S(c,b,r,t,m),e[l]=void 0,x&&p.insertBefore(n,c.elm,g.elm)):d(b,r,n,g.elm,!1,t,m),b=t[++m]);u>h?w(n,i(t[v+1])?null:t[v+1].elm,t,m,v,r):m>v&&_(e,u,h)}(u,g,v,t,c):o(v)?(o(n.text)&&p.setTextContent(u,""),w(u,null,v,0,v.length-1,t)):o(g)?_(g,0,g.length-1):o(n.text)&&p.setTextContent(u,""):n.text!==e.text&&p.setTextContent(u,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var T=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,r){var a,i=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,d=0;d<c.length;d++){if(!u||!C(u,c[d],t,r)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else g(e,c,t);if(o(l)){var h=!1;for(var f in l)if(!T(f)){h=!0,v(e,t);break}!h&&l.class&&Ue(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var l,c=!1,u=[];if(i(n))c=!0,d(e,u);else{var m=o(n.nodeType);if(!m&&Sr(n,e))S(n,e,u,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,u))return E(e,u,!0),n;l=n,n=new mn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=p.parentNode(h);if(d(e,u,h._leaveCb?null:g,p.nextSibling(h)),o(e.parent))for(var v=e.parent,b=f(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var w=0;w<r.create.length;++w)r.create[w](kr,v);var k=v.data.hook.insert;if(k.merged)for(var j=1;j<k.fns.length;j++)k.fns[j]()}else xr(v);v=v.parent}o(g)?_([n],0,0):o(n.tag)&&x(n)}}return E(e,u,c),e.elm}o(n)&&x(n)}}({nodeOps:yr,modules:[Lr,Jr,Vr,Kr,sa,q?{create:Pa,activate:Pa,remove:function(n,e){!0!==n.data.show?Ca(n,e):e()}}:{}].concat(Dr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ja(n,"input")}));var Da={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Vn(t,"postpatch",(function(){Da.componentUpdated(n,e,t)})):Ba(n,e,t.context),n._vOptions=[].map.call(n.options,La)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ra),n.addEventListener("compositionend",Ha),n.addEventListener("change",Ha),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ba(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,La);if(a.some((function(n,e){return!z(n,r[e])})))(n.multiple?e.value.some((function(n){return za(n,a)})):e.value!==e.oldValue&&za(e.value,a))&&Ja(n,"change")}}};function Ba(n,e,t){Ma(n,e,t),(K||Y)&&setTimeout((function(){Ma(n,e,t)}),0)}function Ma(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],a)i=L(r,La(o))>-1,o.selected!==i&&(o.selected=i);else if(z(La(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function za(n,e){return e.every((function(e){return!z(e,n)}))}function La(n){return"_value"in n?n._value:n.value}function Ra(n){n.target.composing=!0}function Ha(n){n.target.composing&&(n.target.composing=!1,Ja(n.target,"input"))}function Ja(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fa(n){return!n.componentInstance||n.data&&n.data.transition?n:Fa(n.componentInstance._vnode)}var Ua={model:Da,show:{bind:function(n,e,t){var r=e.value,a=(t=Fa(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ta(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fa(t)).data&&t.data.transition?(t.data.show=!0,r?Ta(t,(function(){n.style.display=n.__vOriginalDisplay})):Ca(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},$a={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Na(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Na(je(e.children)):n}function Ga(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[S(r)]=a[r];return e}function Wa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Va=function(n){return n.tag||he(n)},qa=function(n){return"show"===n.name},Xa={name:"transition",props:$a,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Va)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=Na(a);if(!i)return a;if(this._leaving)return Wa(n,a);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Ga(this),c=this._vnode,p=Na(c);if(i.data.directives&&i.data.directives.some(qa)&&(i.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,p)&&!he(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=P({},s);if("out-in"===r)return this._leaving=!0,Vn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wa(n,a);if("in-out"===r){if(he(i))return c;var d,m=function(){d()};Vn(s,"afterEnter",m),Vn(s,"enterCancelled",m),Vn(u,"delayLeave",(function(n){d=n}))}}return a}}},Ka=P({tag:String,moveClass:String},$a);function Za(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ya(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),i.transitionDuration="0s"}}delete Ka.mode;var ni={Transition:Xa,TransitionGroup:{props:Ka,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=Ga(this),s=0;s<a.length;s++){if((p=a[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))i.push(p),t[p.key]=p,(p.data||(p.data={})).transition=o;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Za),n.forEach(Ya),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;wa(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ga,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ga,n),t._moveCb=null,xa(t,e))})}})))},methods:{hasMove:function(n,e){if(!ma)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pa(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=ja(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=fr,Wt.config.isReservedAttr=nr,Wt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!q)return!0;if(fr(n))return!1;if(n=n.toLowerCase(),null!=vr[n])return vr[n];var e=document.createElement(n);return n.indexOf("-")>-1?vr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:vr[n]=/HTMLUnknownElement/.test(e.toString())},P(Wt.options.directives,Ua),P(Wt.options.components,ni),Wt.prototype.__patch__=q?Oa:D,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ge(n,r,D,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var i=0;i<a.length;i++)a[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},q&&setTimeout((function(){U.devtools&&sn&&sn.emit("init",Wt)}),0);var ti=/[!'()*]/g,ri=function(n){return"%"+n.charCodeAt(0).toString(16)},ai=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ri).replace(ai,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function li(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=oi(t.shift()),a=t.length>0?oi(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(ii(e)):r.push(ii(e)+"="+ii(n)))})),r.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pi=/\/?$/;function ui(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=di(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:gi(e,a),matched:n?hi(n):[]};return t&&(o.redirectedFrom=gi(t,a)),Object.freeze(o)}function di(n){if(Array.isArray(n))return n.map(di);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=di(n[t]);return e}return n}var mi=ui(null,{path:"/"});function hi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function gi(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||ci)(r)+a}function fi(n,e,t){return e===mi?n===e:!!e&&(n.path&&e.path?n.path.replace(pi,"")===e.path.replace(pi,"")&&(t||n.hash===e.hash&&vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vi(n.query,e.query)&&vi(n.params,e.params))))}function vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?vi(i,o):String(i)===String(o)}))}function bi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var o=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),p=0,u=!1;a&&a._routerRoot!==a;){var d=a.$vnode?a.$vnode.data:{};d.routerView&&p++,d.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(i.routerViewDepth=p,u){var m=c[s],h=m&&m.component;return h?(m.configProps&&wi(h,i,m.route,m.configProps),o(h,i,r)):o()}var g=l.matched[p],f=g&&g.components[s];if(!g||!f)return c[s]=null,o();c[s]={component:f},i.registerRouteInstance=function(n,e){var t=g.instances[s];(e&&t!==n||!e&&t===n)&&(g.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[s]&&(g.instances[s]=n.componentInstance),bi(l)};var v=g.props&&g.props[s];return v&&(ei(c[s],{route:l,configProps:v}),wi(f,i,l,v)),o(f,i,r)}};function wi(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=ei({},a);var i=e.attrs=e.attrs||{};for(var o in a)n.props&&o in n.props||(i[o]=a[o],delete a[o])}}function xi(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function _i(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ki=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ji=Ri,Si=Ii,Ei=function(n,e){return Oi(Ii(n,e),e)},Ti=Oi,Ci=Li,Ai=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ii(n,e){for(var t,r=[],a=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Ai.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(i,p),i=p+l.length,c)o+=c[1];else{var u=n[i],d=t[2],m=t[3],h=t[4],g=t[5],f=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=d&&null!=u&&u!==d,y="+"===f||"*"===f,w="?"===f||"*"===f,x=t[2]||s,_=h||g;r.push({name:m||a++,prefix:d||"",delimiter:x,optional:w,repeat:y,partial:b,asterisk:!!v,pattern:_?Bi(_):v?".*":"[^"+Di(x)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function Pi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Oi(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",zi(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?Pi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=i[l.name];if(null==p){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ki(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(c=o(p[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Di(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Bi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Mi(n,e){return n.keys=e,n}function zi(n){return n&&n.sensitive?"":"i"}function Li(n,e,t){ki(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Di(s);else{var l=Di(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Di(t.delimiter||"/"),u=i.slice(-p.length)===p;return r||(i=(u?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=a?"$":r&&u?"":"(?="+p+"|$)",Mi(new RegExp("^"+i,zi(t)),e)}function Ri(n,e,t){return ki(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Mi(n,e)}(n,e):ki(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Ri(n[a],e,t).source);return Mi(new RegExp("(?:"+r.join("|")+")",zi(t)),e)}(n,e,t):function(n,e,t){return Li(Ii(n,t),e,t)}(n,e,t)}ji.parse=Si,ji.compile=Ei,ji.tokensToFunction=Ti,ji.tokensToRegExp=Ci;var Hi=Object.create(null);function Ji(n,e,t){e=e||{};try{var r=Hi[n]||(Hi[n]=ji.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fi(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=ei({},n)).params;return i&&"object"==typeof i&&(a.params=ei({},i)),a}if(!a.path&&a.params&&e){(a=ei({},a))._normalized=!0;var o=ei(ei({},e.params),a.params);if(e.name)a.name=e.name,a.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Ji(s,o,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",p=l.path?xi(l.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var r,a=t||li;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(si):si(o)}return r}(l.query,a.query,r&&r.options.parseQuery),d=a.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:p,query:u,hash:d}}var Ui,$i=function(){},Ni={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,o=a.route,s=a.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,d=null==p?"router-link-exact-active":p,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,g=o.redirectedFrom?ui(null,Fi(o.redirectedFrom),null,t):o;l[h]=fi(r,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(pi,"/").indexOf(e.path.replace(pi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var f=l[h]?this.ariaCurrentValue:null,v=function(n){Gi(n)&&(e.replace?t.replace(i,$i):t.push(i,$i))},b={click:Gi};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[m],isExactActive:l[h]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?n():n("span",{},w)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":f};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var _=x.data=ei({},x.data);for(var k in _.on=_.on||{},_.on){var j=_.on[k];k in b&&(_.on[k]=Array.isArray(j)?j:[j])}for(var S in b)S in _.on?_.on[S].push(b[S]):_.on[S]=v;var E=x.data.attrs=ei({},x.data.attrs);E.href=s,E["aria-current"]=f}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Gi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wi="undefined"!=typeof window;function Vi(n,e,t,r,a){var i=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _i(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:p,regex:qi(p,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?_i(o+"/"+a.path):void 0;n(e,t,r,a,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<d.length;++m){0;var h={path:d[m],children:a.children};n(e,t,r,h,i,u.path||"/")}l&&(r[l]||(r[l]=u))}(i,o,s,n,a)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function qi(n,e){return ji(n,[],e)}function Xi(n,e){var t=Vi(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Fi(n,t,!1,e),c=s.name;if(c){var p=i[c];if(!p)return l(null,s);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&u.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Ji(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],g=a[h];if(Ki(g.regex,s.path,s.params))return l(g,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(ui(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,p=s.path,u=t.query,d=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,d=s.hasOwnProperty("hash")?s.hash:d,m=s.hasOwnProperty("params")?s.params:m,c){i[c];return o({_normalized:!0,name:c,query:u,hash:d,params:m},void 0,t)}if(p){var h=function(n,e){return xi(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:Ji(h,m),query:u,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Ji(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):ui(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Vi([e||n],r,a,i,t),t&&t.alias.length&&Vi(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Vi(n,r,a,i)}}}function Ki(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?oi(r[a]):r[a])}return!0}var Zi=Wi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Zi.now().toFixed(3)}var Qi=Yi();function no(){return Qi}function eo(n){return Qi=n}var to=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ao(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){uo(n,i)})).catch((function(n){0})):uo(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var po=/^#\d/;function uo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else r&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,ho=Wi&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){io();var t=window.history;try{if(e){var r=ei({},t.state);r.key=no(),t.replaceState(r,"",n)}else t.pushState({key:eo(Yi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fo(n){go(n,!0)}var vo={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return wo(n,e,vo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return wo(n,e,vo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wo(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var xo=["params","query","hash"];function _o(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ko(n,e){return _o(n)&&n._isRouter&&(null==e||n.type===e)}function jo(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function So(n){return function(e,t,r){var a=!1,i=0,o=null;Eo(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var l,c=Ao((function(e){var a;((a=e).__esModule||Co&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ui.extend(e),t.components[s]=e,--i<=0&&r()})),p=Ao((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=_o(n)?n:new Error(e),r(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,p)}}})),a||r()}}function Eo(n,e){return To(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function To(n){return Array.prototype.concat.apply([],n)}var Co="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ao(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Io=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,r){var a=Eo(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=Ui.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return To(r?a.reverse():a)}function Oo(n,e){if(e)return function(){return n.apply(e,arguments)}}Io.prototype.listen=function(n){this.cb=n},Io.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Io.prototype.onError=function(n){this.errorCbs.push(n)},Io.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ko(n,vo.redirected)&&i===mi||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Io.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,s=function(n){!ko(n)&&_o(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(fi(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&ao(this.router,a,n,!1),s(((o=wo(i=a,n,vo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,d=p.deactivated,m=p.activated,h=[].concat(function(n){return Po(n,"beforeRouteLeave",Oo,!0)}(d),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",Oo)}(u),m.map((function(n){return n.beforeEnter})),So(m)),g=function(e,t){if(r.pending!==n)return s(yo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return wo(n,e,vo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):_o(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bo(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};jo(h,g,(function(){jo(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return s(yo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){bi(n)}))}))}))},Io.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Io.prototype.setupListeners=function(){},Io.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mi,this.pending=null};var Do=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Bo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=ho&&t;r&&this.listeners.push(ro());var a=function(){var t=n.current,a=Bo(n.base);n.current===mi&&a===n._startLocation||n.transitionTo(a,(function(n){r&&ao(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){go(_i(r.base+n.fullPath)),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fo(_i(r.base+n.fullPath)),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Bo(this.base)!==this.current.fullPath){var e=_i(this.base+this.current.fullPath);n?go(e):fo(e)}},e.prototype.getCurrentLocation=function(){return Bo(this.base)},e}(Io);function Bo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(_i(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mo=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Bo(n);if(!/^\/#/.test(e))return window.location.replace(_i(n+"/#"+e)),!0}(this.base)||zo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ro());var r=function(){var e=n.current;zo()&&n.transitionTo(Lo(),(function(r){t&&ao(n.router,r,e,!0),ho||Jo(r.fullPath)}))},a=ho?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Ho(n.fullPath),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Jo(n.fullPath),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Lo()!==e&&(n?Ho(e):Jo(e))},e.prototype.getCurrentLocation=function(){return Lo()},e}(Io);function zo(){var n=Lo();return"/"===n.charAt(0)||(Jo("/"+n),!1)}function Lo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ro(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ho(n){ho?go(Ro(n)):window.location.hash=n}function Jo(n){ho?fo(Ro(n)):window.location.replace(Ro(n))}var Fo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ko(n,vo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Io),Uo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Wi||(e="abstract"),this.mode=e,e){case"history":this.history=new Do(this,n.base);break;case"hash":this.history=new Mo(this,n.base,this.fallback);break;case"abstract":this.history=new Fo(this,n.base);break;default:0}},$o={currentRoute:{configurable:!0}};Uo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},$o.currentRoute.get=function(){return this.history&&this.history.current},Uo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Do||t instanceof Mo){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;ho&&a&&"fullPath"in n&&ao(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Uo.prototype.beforeEach=function(n){return Go(this.beforeHooks,n)},Uo.prototype.beforeResolve=function(n){return Go(this.resolveHooks,n)},Uo.prototype.afterEach=function(n){return Go(this.afterHooks,n)},Uo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Uo.prototype.onError=function(n){this.history.onError(n)},Uo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Uo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Uo.prototype.go=function(n){this.history.go(n)},Uo.prototype.back=function(){this.go(-1)},Uo.prototype.forward=function(){this.go(1)},Uo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Uo.prototype.resolve=function(n,e,t){var r=Fi(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?_i(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},Uo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Uo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Uo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Uo.prototype,$o);var No=Uo;function Go(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Uo.install=function n(e){if(!n.installed||Ui!==e){n.installed=!0,Ui=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",Ni);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Uo.version="3.6.5",Uo.isNavigationFailure=ko,Uo.NavigationFailureType=vo,Uo.START_LOCATION=mi,Wi&&window.Vue&&window.Vue.use(Uo);t(105);t(13),t(132);var Wo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,341)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,340))},Vo={"v-af806e72":()=>t.e(6).then(t.bind(null,342)),"v-7b30df76":()=>t.e(7).then(t.bind(null,343)),"v-0f29318d":()=>t.e(8).then(t.bind(null,344)),"v-17d1abf2":()=>t.e(11).then(t.bind(null,345)),"v-1e37fba9":()=>t.e(12).then(t.bind(null,346)),"v-7fd3f54a":()=>t.e(13).then(t.bind(null,347)),"v-e2342726":()=>t.e(14).then(t.bind(null,348)),"v-624c6ac9":()=>t.e(15).then(t.bind(null,349)),"v-896d9d60":()=>t.e(16).then(t.bind(null,350)),"v-0f49eef1":()=>t.e(17).then(t.bind(null,351)),"v-b781da14":()=>t.e(10).then(t.bind(null,352)),"v-49daadf4":()=>t.e(18).then(t.bind(null,353)),"v-de1b1892":()=>t.e(19).then(t.bind(null,354)),"v-00f44386":()=>t.e(20).then(t.bind(null,355)),"v-259c1a0e":()=>t.e(9).then(t.bind(null,356)),"v-764776e4":()=>t.e(21).then(t.bind(null,357)),"v-63e62d2f":()=>t.e(22).then(t.bind(null,358)),"v-382edf72":()=>t.e(23).then(t.bind(null,359)),"v-10c0c4bc":()=>t.e(24).then(t.bind(null,360)),"v-523358fd":()=>t.e(25).then(t.bind(null,361)),"v-6ee75b6c":()=>t.e(26).then(t.bind(null,362)),"v-c43a3196":()=>t.e(27).then(t.bind(null,363)),"v-6c749aa2":()=>t.e(28).then(t.bind(null,364)),"v-5f0bc376":()=>t.e(29).then(t.bind(null,365)),"v-68ab505c":()=>t.e(30).then(t.bind(null,366)),"v-120f2772":()=>t.e(31).then(t.bind(null,367)),"v-09ee94f0":()=>t.e(32).then(t.bind(null,368)),"v-ea0cd796":()=>t.e(33).then(t.bind(null,369)),"v-19777b50":()=>t.e(34).then(t.bind(null,370)),"v-57f48596":()=>t.e(35).then(t.bind(null,371)),"v-2bab44b8":()=>t.e(36).then(t.bind(null,372)),"v-eaa110c0":()=>t.e(37).then(t.bind(null,373)),"v-7cc4c202":()=>t.e(38).then(t.bind(null,374)),"v-9ff076e8":()=>t.e(39).then(t.bind(null,375)),"v-411acbf5":()=>t.e(40).then(t.bind(null,376)),"v-72dfcce0":()=>t.e(41).then(t.bind(null,377)),"v-2b6c3a17":()=>t.e(42).then(t.bind(null,378)),"v-7632d62e":()=>t.e(43).then(t.bind(null,379)),"v-34f679a5":()=>t.e(44).then(t.bind(null,380)),"v-613ea943":()=>t.e(45).then(t.bind(null,381)),"v-444825c3":()=>t.e(47).then(t.bind(null,382)),"v-9aeca196":()=>t.e(48).then(t.bind(null,383)),"v-2ce6653a":()=>t.e(49).then(t.bind(null,384)),"v-ad5f0baa":()=>t.e(46).then(t.bind(null,385)),"v-3f052c28":()=>t.e(50).then(t.bind(null,386)),"v-59f3b0d2":()=>t.e(51).then(t.bind(null,387)),"v-5257dd59":()=>t.e(52).then(t.bind(null,388)),"v-77b0cb36":()=>t.e(53).then(t.bind(null,389)),"v-19e65b15":()=>t.e(54).then(t.bind(null,390)),"v-206fe99b":()=>t.e(55).then(t.bind(null,391)),"v-08947a02":()=>t.e(56).then(t.bind(null,392)),"v-065caaf0":()=>t.e(57).then(t.bind(null,393)),"v-73ef0f20":()=>t.e(58).then(t.bind(null,394)),"v-7f658b18":()=>t.e(59).then(t.bind(null,395)),"v-5cdd7466":()=>t.e(60).then(t.bind(null,396)),"v-eb84e6ce":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,397)),"v-3320b556":()=>t.e(61).then(t.bind(null,398)),"v-30875754":()=>t.e(62).then(t.bind(null,399)),"v-185bd302":()=>t.e(63).then(t.bind(null,400)),"v-35a778e7":()=>t.e(64).then(t.bind(null,401)),"v-6bce7929":()=>t.e(65).then(t.bind(null,402)),"v-6b0ea974":()=>t.e(66).then(t.bind(null,403)),"v-f0d21874":()=>t.e(67).then(t.bind(null,404)),"v-a1f06136":()=>t.e(68).then(t.bind(null,405)),"v-aad24a76":()=>t.e(69).then(t.bind(null,406)),"v-015f14e5":()=>t.e(70).then(t.bind(null,407)),"v-92bd0212":()=>t.e(71).then(t.bind(null,408)),"v-8dbf1712":()=>t.e(72).then(t.bind(null,409)),"v-68b42d7e":()=>t.e(73).then(t.bind(null,410))};function qo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xo=/-(\w)/g,Ko=qo(n=>n.replace(Xo,(n,e)=>e?e.toUpperCase():"")),Zo=/\B([A-Z])/g,Yo=qo(n=>n.replace(Zo,"-$1").toLowerCase()),Qo=qo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qo(Ko(e))):n(Qo(e))||n(Yo(e))}const es=Object.assign({},Wo,Vo),ts=n=>es[n],rs=n=>Vo[n],as=n=>Wo[n],is=n=>Wt.component(n);function os(n){return ns(rs,n)}function ss(n){return ns(as,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(is,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Wt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ds=t(93),ms=t.n(ds),hs=t(94),gs=t.n(hs),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xs=t(51),_s={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ks=t(26),js=t.n(ks),Ss={mounted(){js.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||js.a.start(),t()}),this.$router.afterEach(()=>{js.a.done(),this.isSidebarOpen=!1})}};t(241),t(242);class Es{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Ts={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Es).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Cs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},As={},Is=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ps=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Cs[n]},Os=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,i=e.children;a.appendChild(n(t,r,i))})),a},Ds=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Bs=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Is(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,i=[eval][0](a);return i.template=e,i}(s.js,s.html);var l=Ps("vue");return s.jsLib.unshift(l),s},Ms=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},zs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ls(){var n=Ds(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ds(n,"vuepress-plugin-demo-block__code"),t=Ds(n,"vuepress-plugin-demo-block__display"),r=Ds(n,"vuepress-plugin-demo-block__footer"),a=Ds(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:zs(n),htmlTpl:Is("")},o=Ps("react"),s=Ps("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Ms(i,o):Bs(i,o),p=Os("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",Rs.bind(null,p,l,e,r)),Ps("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=a.concat(i).concat(Ps("cssLib")).concat(Ps("jsLib")).join(",");return Os("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ps("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(Ps("jsLib")).join(";"),css_external:i.concat(Ps("cssLib")).join(";"),layout:Ps("codepenLayout"),js_pre_processor:Ps("codepenJsProcessor"),editors:Ps("codepenEditors")});return Os("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Ps("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!As[n]){var e=Os("style",{innerHTML:n});document.body.appendChild(e),As[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();a.appendChild(d.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ls()}),300)}function Rs(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Hs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ls()},updated:function(){Ls()}},Js="auto",Fs="zoom-in",Us="zoom-out",$s="grab",Ns="move";function Gs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Ws(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Vs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function qs(n,e,t){!function(n){var e=Xs,t=Ks;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var i in e)t&&(a[i]=r[i]||""),r[i]=e[i];return a}var Xs="transition",Ks="transform",Zs="transform",Ys="transitionend";var Qs=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qs,onClose:Qs,onGrab:Qs,onMove:Qs,onRelease:Qs,onBeforeOpen:Qs,onBeforeClose:Qs,onBeforeGrab:Qs,onBeforeRelease:Qs,onImageLoading:Qs,onImageLoaded:Qs},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(r)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,qs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Gs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){qs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},il="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Vs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?$s:Us,transition:Zs+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=qs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,qs(this.el,{transform:"none"})},grab:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;qs(this.el,{cursor:Ns,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;qs(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){qs(this.el,this.styleClose)},restoreOpenStyle:function(){qs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,i=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":il(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-o,y:l.y-s},p=c.x/o,u=c.y/s,d=i+Math.min(p,u);if(a&&"string"==typeof a){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(a)*m/(100*this.rect.width),f=parseFloat(a)*h/(100*this.rect.height);if(d>g||d>f)return{x:g,y:f}}return{x:d,y:d}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Gs(n,r,e[r],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(al),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Fs,Gs(n,"click",this.handler.click),this.options.preloadImage&&Ws(Vs(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Ws(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Gs(document,"scroll",this.handler.scroll),Gs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Gs(window,"resize",this.handler.resizeWindow);var i=function n(){Gs(r,Ys,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(r)};return Gs(r,Ys,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Js,this.overlay.fadeOut(),this.target.zoomOut(),Gs(document,"scroll",this.handler.scroll,!1),Gs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Gs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Gs(t,Ys,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Gs(t,Ys,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){Gs(a,Ys,n,!1),r(a)};return Gs(a,Ys,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ns,this.target.move(n,e,t);var a=this.target.el,i=function n(){Gs(a,Ys,n,!1),r(a)};return Gs(a,Ys,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Js,this.target.restoreOpenStyle();var r=function r(){Gs(t,Ys,r,!1),n.lock=!1,n.released=!0,e(t)};return Gs(t,Ys,r),this}}}]),n}();const dl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new ul(dl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var gl=[fs,_s,Ss,Ts,Hs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(4),bl=Object(vl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",gl);const yl=[{name:"v-af806e72",path:"/web/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-af806e72").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/01.前端.html",redirect:"/web/"},{name:"v-7b30df76",path:"/open/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7b30df76").then(t)}},{path:"/open/index.html",redirect:"/open/"},{path:"/00.目录页/02.页面.html",redirect:"/open/"},{name:"v-0f29318d",path:"/technology/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-0f29318d").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-17d1abf2",path:"/pages/21c2f2/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-17d1abf2").then(t)}},{path:"/pages/21c2f2/index.html",redirect:"/pages/21c2f2/"},{path:"/01.前端/01.前端开发笔记/02.CSS：页面布局的基本规则和方式.html",redirect:"/pages/21c2f2/"},{name:"v-1e37fba9",path:"/pages/884d6e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-1e37fba9").then(t)}},{path:"/pages/884d6e/index.html",redirect:"/pages/884d6e/"},{path:"/01.前端/01.前端开发笔记/03.JavaScript 如何实现继承？.html",redirect:"/pages/884d6e/"},{name:"v-7fd3f54a",path:"/pages/13ef6c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7fd3f54a").then(t)}},{path:"/pages/13ef6c/index.html",redirect:"/pages/13ef6c/"},{path:"/01.前端/01.前端开发笔记/04.JavaScript 引擎如何执行 JavaScript 代码.html",redirect:"/pages/13ef6c/"},{name:"v-e2342726",path:"/pages/c3f2e0/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-e2342726").then(t)}},{path:"/pages/c3f2e0/index.html",redirect:"/pages/c3f2e0/"},{path:"/01.前端/01.前端开发笔记/05.单线程的 JavaScript 如何管理任务.html",redirect:"/pages/c3f2e0/"},{name:"v-624c6ac9",path:"/pages/6fddea/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-624c6ac9").then(t)}},{path:"/pages/6fddea/index.html",redirect:"/pages/6fddea/"},{path:"/01.前端/01.前端开发笔记/06.一个网络请求是怎么进行的.html",redirect:"/pages/6fddea/"},{name:"v-896d9d60",path:"/pages/595abe/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-896d9d60").then(t)}},{path:"/pages/595abe/index.html",redirect:"/pages/595abe/"},{path:"/01.前端/01.前端开发笔记/07.HTTP 协议和前端开发有什么关系.html",redirect:"/pages/595abe/"},{name:"v-0f49eef1",path:"/pages/53ab0a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-0f49eef1").then(t)}},{path:"/pages/53ab0a/index.html",redirect:"/pages/53ab0a/"},{path:"/01.前端/01.前端开发笔记/08.深入剖析浏览器中页面的渲染过程.html",redirect:"/pages/53ab0a/"},{name:"v-b781da14",path:"/pages/86005a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-b781da14").then(t)}},{path:"/pages/86005a/index.html",redirect:"/pages/86005a/"},{path:"/01.前端/01.前端开发笔记/01.重识 HTML，掌握页面基本结构和加载过程.html",redirect:"/pages/86005a/"},{name:"v-49daadf4",path:"/pages/b206ba/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-49daadf4").then(t)}},{path:"/pages/b206ba/index.html",redirect:"/pages/b206ba/"},{path:"/01.前端/01.前端开发笔记/09.改善编程思维：从事件驱动到数据驱动.html",redirect:"/pages/b206ba/"},{name:"v-de1b1892",path:"/pages/ea57d2/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-de1b1892").then(t)}},{path:"/pages/ea57d2/index.html",redirect:"/pages/ea57d2/"},{path:"/01.前端/01.前端开发笔记/10.掌握前端框架模板引擎的实现原理.html",redirect:"/pages/ea57d2/"},{name:"v-00f44386",path:"/pages/49a69e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-00f44386").then(t)}},{path:"/pages/49a69e/index.html",redirect:"/pages/49a69e/"},{path:"/01.前端/01.前端开发笔记/11.为什么小程序特立独行.html",redirect:"/pages/49a69e/"},{name:"v-259c1a0e",path:"/more/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-259c1a0e").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/04.更多.html",redirect:"/more/"},{name:"v-764776e4",path:"/pages/f761ed/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-764776e4").then(t)}},{path:"/pages/f761ed/index.html",redirect:"/pages/f761ed/"},{path:"/01.前端/01.前端开发笔记/12.单页应用与前端路由库设计原理.html",redirect:"/pages/f761ed/"},{name:"v-63e62d2f",path:"/pages/596343/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-63e62d2f").then(t)}},{path:"/pages/596343/index.html",redirect:"/pages/596343/"},{path:"/01.前端/01.前端开发笔记/13.代码构建与 Webpack 必备技能.html",redirect:"/pages/596343/"},{name:"v-382edf72",path:"/pages/996215/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-382edf72").then(t)}},{path:"/pages/996215/index.html",redirect:"/pages/996215/"},{path:"/01.前端/01.前端开发笔记/14.提升编程体验：组件化与模块化设计.html",redirect:"/pages/996215/"},{name:"v-10c0c4bc",path:"/pages/7d3a8a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-10c0c4bc").then(t)}},{path:"/pages/7d3a8a/index.html",redirect:"/pages/7d3a8a/"},{path:"/01.前端/01.前端开发笔记/17.AngularReactVue 三大前端框架的设计特色.html",redirect:"/pages/7d3a8a/"},{name:"v-523358fd",path:"/pages/ddbbb3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-523358fd").then(t)}},{path:"/pages/ddbbb3/index.html",redirect:"/pages/ddbbb3/"},{path:"/01.前端/01.前端开发笔记/18.如何设计合适的状态管理方案.html",redirect:"/pages/ddbbb3/"},{name:"v-6ee75b6c",path:"/pages/9c6643/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6ee75b6c").then(t)}},{path:"/pages/9c6643/index.html",redirect:"/pages/9c6643/"},{path:"/01.前端/01.前端开发笔记/19.如何搭建前端监控体系为业务排忧解难.html",redirect:"/pages/9c6643/"},{name:"v-c43a3196",path:"/pages/aeb6b9/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-c43a3196").then(t)}},{path:"/pages/aeb6b9/index.html",redirect:"/pages/aeb6b9/"},{path:"/01.前端/01.前端开发笔记/20.如何进行性能分析的自动化实现.html",redirect:"/pages/aeb6b9/"},{name:"v-6c749aa2",path:"/pages/55cc33/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6c749aa2").then(t)}},{path:"/pages/55cc33/index.html",redirect:"/pages/55cc33/"},{path:"/01.前端/01.前端开发笔记/21.前端性能优化与解决方案.html",redirect:"/pages/55cc33/"},{name:"v-5f0bc376",path:"/pages/ee7a1a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-5f0bc376").then(t)}},{path:"/pages/ee7a1a/index.html",redirect:"/pages/ee7a1a/"},{path:"/01.前端/01.前端开发笔记/22.如何进行技术方案调研与设计.html",redirect:"/pages/ee7a1a/"},{name:"v-68ab505c",path:"/pages/b1d475/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-68ab505c").then(t)}},{path:"/pages/b1d475/index.html",redirect:"/pages/b1d475/"},{path:"/01.前端/01.前端开发笔记/23.如何设计一个前端项目.html",redirect:"/pages/b1d475/"},{name:"v-120f2772",path:"/pages/8a03a9/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-120f2772").then(t)}},{path:"/pages/8a03a9/index.html",redirect:"/pages/8a03a9/"},{path:"/01.前端/01.前端开发笔记/24.通过前端工程化提升团队开发效率.html",redirect:"/pages/8a03a9/"},{name:"v-09ee94f0",path:"/pages/e991d8/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-09ee94f0").then(t)}},{path:"/pages/e991d8/index.html",redirect:"/pages/e991d8/"},{path:"/01.前端/01.前端开发笔记/25.大型前端项目的痛点和优化方案.html",redirect:"/pages/e991d8/"},{name:"v-ea0cd796",path:"/pages/75d6fd/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-ea0cd796").then(t)}},{path:"/pages/75d6fd/index.html",redirect:"/pages/75d6fd/"},{path:"/01.前端/01.前端开发笔记/26.如何通过前期准备和后期复盘让项目稳定上线.html",redirect:"/pages/75d6fd/"},{name:"v-19777b50",path:"/pages/a61298/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-19777b50").then(t)}},{path:"/pages/a61298/index.html",redirect:"/pages/a61298/"},{path:"/01.前端/25.JavaScript/01.33个非常实用的JavaScript一行代码.html",redirect:"/pages/a61298/"},{name:"v-57f48596",path:"/pages/8143cc480faf9a11/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-57f48596").then(t)}},{path:"/pages/8143cc480faf9a11/index.html",redirect:"/pages/8143cc480faf9a11/"},{path:"/01.前端/25.JavaScript/02.new命令原理.html",redirect:"/pages/8143cc480faf9a11/"},{name:"v-2bab44b8",path:"/pages/b1af5cb8996363c5/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2bab44b8").then(t)}},{path:"/pages/b1af5cb8996363c5/index.html",redirect:"/pages/b1af5cb8996363c5/"},{path:"/01.前端/25.JavaScript/03.ES5面向对象.html",redirect:"/pages/b1af5cb8996363c5/"},{name:"v-eaa110c0",path:"/pages/1f4123be6f45abcd/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-eaa110c0").then(t)}},{path:"/pages/1f4123be6f45abcd/index.html",redirect:"/pages/1f4123be6f45abcd/"},{path:"/01.前端/25.JavaScript/04.ES6面向对象.html",redirect:"/pages/1f4123be6f45abcd/"},{name:"v-7cc4c202",path:"/pages/dcebaf/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7cc4c202").then(t)}},{path:"/pages/dcebaf/index.html",redirect:"/pages/dcebaf/"},{path:"/01.前端/25.JavaScript/10.Service Worker简述.html",redirect:"/pages/dcebaf/"},{name:"v-9ff076e8",path:"/pages/fd4a16d56b83c1bc/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-9ff076e8").then(t)}},{path:"/pages/fd4a16d56b83c1bc/index.html",redirect:"/pages/fd4a16d56b83c1bc/"},{path:"/01.前端/25.JavaScript/100.比typeof运算符更准确的类型判断.html",redirect:"/pages/fd4a16d56b83c1bc/"},{name:"v-411acbf5",path:"/pages/40b4db2d38ba85f2/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-411acbf5").then(t)}},{path:"/pages/40b4db2d38ba85f2/index.html",redirect:"/pages/40b4db2d38ba85f2/"},{path:"/01.前端/25.JavaScript/50.js随机打乱数组.html",redirect:"/pages/40b4db2d38ba85f2/"},{name:"v-72dfcce0",path:"/pages/f1acb712033ac8da/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-72dfcce0").then(t)}},{path:"/pages/f1acb712033ac8da/index.html",redirect:"/pages/f1acb712033ac8da/"},{path:"/01.前端/25.JavaScript/70.将一维数组按指定长度转为二维数组.html",redirect:"/pages/f1acb712033ac8da/"},{name:"v-2b6c3a17",path:"/pages/8a70a2/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2b6c3a17").then(t)}},{path:"/pages/8a70a2/index.html",redirect:"/pages/8a70a2/"},{path:"/01.前端/26.3D地图相关/01.Cesium入门.html",redirect:"/pages/8a70a2/"},{name:"v-7632d62e",path:"/pages/8382fc/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7632d62e").then(t)}},{path:"/pages/8382fc/index.html",redirect:"/pages/8382fc/"},{path:"/01.前端/26.3D地图相关/02.Cesium一般使用.html",redirect:"/pages/8382fc/"},{name:"v-34f679a5",path:"/open/8599a5b876fc95e4/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-34f679a5").then(t)}},{path:"/open/8599a5b876fc95e4/index.html",redirect:"/open/8599a5b876fc95e4/"},{path:"/02.页面/00.DevUI.html",redirect:"/open/8599a5b876fc95e4/"},{name:"v-613ea943",path:"/open/8599a5b876fc95e3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-613ea943").then(t)}},{path:"/open/8599a5b876fc95e3/index.html",redirect:"/open/8599a5b876fc95e3/"},{path:"/02.页面/01.enalPro.html",redirect:"/open/8599a5b876fc95e3/"},{name:"v-444825c3",path:"/pages/9a7ee40fc232253e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-444825c3").then(t)}},{path:"/pages/9a7ee40fc232253e/index.html",redirect:"/pages/9a7ee40fc232253e/"},{path:"/03.技术/01.技术文档/01.Git使用手册.html",redirect:"/pages/9a7ee40fc232253e/"},{name:"v-9aeca196",path:"/pages/ad247c4332211551/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-9aeca196").then(t)}},{path:"/pages/ad247c4332211551/index.html",redirect:"/pages/ad247c4332211551/"},{path:"/03.技术/01.技术文档/02.Markdown使用教程.html",redirect:"/pages/ad247c4332211551/"},{name:"v-2ce6653a",path:"/pages/61f2f95fd7da14fd/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2ce6653a").then(t)}},{path:"/pages/61f2f95fd7da14fd/index.html",redirect:"/pages/61f2f95fd7da14fd/"},{path:"/03.技术/01.技术文档/03.npm常用命令.html",redirect:"/pages/61f2f95fd7da14fd/"},{name:"v-ad5f0baa",path:"/pages/aea6571b7a8bae86/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-ad5f0baa").then(t)}},{path:"/pages/aea6571b7a8bae86/index.html",redirect:"/pages/aea6571b7a8bae86/"},{path:"/03.技术/00.面试/01.面试问题集锦.html",redirect:"/pages/aea6571b7a8bae86/"},{name:"v-3f052c28",path:"/pages/x123482/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-3f052c28").then(t)}},{path:"/pages/x123482/index.html",redirect:"/pages/x123482/"},{path:"/03.技术/01.技术文档/08.记一次nvm安装失败的过程.html",redirect:"/pages/x123482/"},{name:"v-59f3b0d2",path:"/pages/dec4f3f00e71a312/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-59f3b0d2").then(t)}},{path:"/pages/dec4f3f00e71a312/index.html",redirect:"/pages/dec4f3f00e71a312/"},{path:"/03.技术/01.技术文档/10.npm packageJson属性详解.html",redirect:"/pages/dec4f3f00e71a312/"},{name:"v-5257dd59",path:"/pages/4e8444e2d534d14f/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-5257dd59").then(t)}},{path:"/pages/4e8444e2d534d14f/index.html",redirect:"/pages/4e8444e2d534d14f/"},{path:"/03.技术/01.技术文档/15.yaml语言教程.html",redirect:"/pages/4e8444e2d534d14f/"},{name:"v-77b0cb36",path:"/pages/4c778760be26d8b3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-77b0cb36").then(t)}},{path:"/pages/4c778760be26d8b3/index.html",redirect:"/pages/4c778760be26d8b3/"},{path:"/03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.html",redirect:"/pages/4c778760be26d8b3/"},{name:"v-19e65b15",path:"/pages/6b9d359ec5aa5019/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-19e65b15").then(t)}},{path:"/pages/6b9d359ec5aa5019/index.html",redirect:"/pages/6b9d359ec5aa5019/"},{path:"/03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.html",redirect:"/pages/6b9d359ec5aa5019/"},{name:"v-206fe99b",path:"/pages/f44d2f9ad04ab8d3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-206fe99b").then(t)}},{path:"/pages/f44d2f9ad04ab8d3/index.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{path:"/03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{name:"v-08947a02",path:"/pages/95331c6a9613faf8/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-08947a02").then(t)}},{path:"/pages/95331c6a9613faf8/index.html",redirect:"/pages/95331c6a9613faf8/"},{path:"/03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.html",redirect:"/pages/95331c6a9613faf8/"},{name:"v-065caaf0",path:"/pages/117708e0af7f0bd9/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-065caaf0").then(t)}},{path:"/pages/117708e0af7f0bd9/index.html",redirect:"/pages/117708e0af7f0bd9/"},{path:"/03.技术/03.Nodejs/01.nodejs递归读取所有文件.html",redirect:"/pages/117708e0af7f0bd9/"},{name:"v-73ef0f20",path:"/pages/41f87d890d0a02af/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-73ef0f20").then(t)}},{path:"/pages/41f87d890d0a02af/index.html",redirect:"/pages/41f87d890d0a02af/"},{path:"/03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html",redirect:"/pages/41f87d890d0a02af/"},{name:"v-7f658b18",path:"/pages/1da0bf9a988eafe5/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7f658b18").then(t)}},{path:"/pages/1da0bf9a988eafe5/index.html",redirect:"/pages/1da0bf9a988eafe5/"},{path:"/03.技术/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html",redirect:"/pages/1da0bf9a988eafe5/"},{name:"v-5cdd7466",path:"/pages/a5f73af5185fdf0a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-5cdd7466").then(t)}},{path:"/pages/a5f73af5185fdf0a/index.html",redirect:"/pages/a5f73af5185fdf0a/"},{path:"/03.技术/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html",redirect:"/pages/a5f73af5185fdf0a/"},{name:"v-eb84e6ce",path:"/pages/d557b9a89a215d2e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-eb84e6ce").then(t)}},{path:"/pages/d557b9a89a215d2e/index.html",redirect:"/pages/d557b9a89a215d2e/"},{path:"/03.技术/04.博客搭建/10.vdoing主题效果图.html",redirect:"/pages/d557b9a89a215d2e/"},{name:"v-3320b556",path:"/pages/e58ecf/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-3320b556").then(t)}},{path:"/pages/e58ecf/index.html",redirect:"/pages/e58ecf/"},{path:"/03.技术/05.java/052.java.html",redirect:"/pages/e58ecf/"},{name:"v-30875754",path:"/pages/8599a5b876fc95u7/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-30875754").then(t)}},{path:"/pages/8599a5b876fc95u7/index.html",redirect:"/pages/8599a5b876fc95u7/"},{path:"/03.技术/06.编写好看的markdown文档.html",redirect:"/pages/8599a5b876fc95u7/"},{name:"v-185bd302",path:"/pages/8599a54e76fc95e3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-185bd302").then(t)}},{path:"/pages/8599a54e76fc95e3/index.html",redirect:"/pages/8599a54e76fc95e3/"},{path:"/03.技术/07.一些工具安装.html",redirect:"/pages/8599a54e76fc95e3/"},{name:"v-35a778e7",path:"/friends/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-35a778e7").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/03.技术/99.友情链接.html",redirect:"/friends/"},{name:"v-6bce7929",path:"/about/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6bce7929").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-6b0ea974",path:"/pages/beb6c0bd8a66cea6/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6b0ea974").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/06.收藏夹/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-f0d21874",path:"/pages/47cf96/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-f0d21874").then(t)}},{path:"/pages/47cf96/index.html",redirect:"/pages/47cf96/"},{path:"/06.收藏夹/02.常用的前端轮子.html",redirect:"/pages/47cf96/"},{name:"v-a1f06136",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-a1f06136").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-aad24a76",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-aad24a76").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-015f14e5",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-015f14e5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-92bd0212",path:"/pages/f2e63f/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-92bd0212").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-8dbf1712",path:"/pages/cd8bde/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-8dbf1712").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-68b42d7e",path:"/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-68b42d7e").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bl}],wl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/87452.png"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,css3,html5,Node,git,github,markdown"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端日常总结",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端",imgUrl:"/img/web.png",description:"JavaScript、TypesSript、ES6、Vue、React框架等前端技术"}},title:"前端日常总结",date:"2020-03-11T21:50:53.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-af806e72",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/30, 09:09:08",lastUpdatedTimestamp:1648631348e3},{title:"开源",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.页面",imgUrl:"/img/web.png",description:"开源技术相关"}},title:"开源",date:"2020-03-11T21:50:54.000Z",permalink:"/open",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html",relativePath:"00.目录页/02.页面.md",key:"v-7b30df76",path:"/open/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/31, 15:36:10",lastUpdatedTimestamp:164874097e4},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术",imgUrl:"/img/web.png",description:"技术文档、教程、技巧、总结等文章"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-0f29318d",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/31, 15:36:10",lastUpdatedTimestamp:164874097e4},{title:"CSS：页面布局的基本规则和方式",frontmatter:{title:"CSS：页面布局的基本规则和方式",date:"2022-04-14T22:48:01.000Z",permalink:"/pages/21c2f2/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/02.CSS%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%E5%92%8C%E6%96%B9%E5%BC%8F.html",relativePath:"01.前端/01.前端开发笔记/02.CSS：页面布局的基本规则和方式.md",key:"v-17d1abf2",path:"/pages/21c2f2/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:9603}],headersStr:"精选评论",content:'前端页面的布局和样式编写是传统技能，但页面样式的实现大多数情况下都无法速成，需要通过不断练习、反复地调试才能熟练掌握，因此有一些同学常常会感到疑惑，比如：\n\n 1. 一个元素总宽高为50px，要怎么在调整边框大小的时候，不需要重新计算和设置width/height呢？\n\n 2. 为什么给一些元素设置宽高，但是却不生效？\n\n 3. 如何将一个元素固定在页面的某个位置，具体怎么做？\n\n 4. 为什么将某个元素z-index设置为9999999，但是它依然被其他元素遮挡住了呢？\n\n 5. 为什么将某个元素里面的元素设置为float之后，这个元素的高度就歪了呢？\n\n 6. 让一个元素进行垂直和水平居中，有多少种实现方式？\n\n这些问题产生的根本，是对页面布局规则和常见页面布局方式没掌握透彻。今天我就帮你重新梳理下页面布局的基本规则和布局方式，让以上问题迎刃而解。\n\n\n页面布局的基本规则\n\n我们在调试页面样式的时候，如果你不了解页面布局规则，会经常遇到“这里为什么歪了”“这里为什么又好了”这样的困惑。其实页面的布局不只是“碰运气”似的调整样式，浏览器的页面布局会有一些规则，包括：\n\n * 盒模型计算；\n\n * 内联元素与块状元素布局规则；\n\n * 文档流布局；\n\n * 元素堆叠。\n\n下面我们可以结合问题逐一来看。\n\n盒模型计算\n\n问题 1：一个元素总宽高为30px，要怎么在调整边框大小的时候，不需要重新计算和设置width/height呢？\n\n这个问题涉及浏览器布局中的盒模型计算。什么是盒模型？浏览器对文档进行布局的时候，会将每个元素都表示为这样一个盒子。\n\n\n\n这就是 CSS 基础盒模型，也就是我们常说的盒模型。盒模型主要用来描述元素所占空间的内容，它由四个部分组成：\n\n * 外边框边界margin（橙色部分）\n\n * 边框边界border（黄色部分）\n\n * 内边距边界padding（绿色部分）\n\n * 内容边界content（蓝色部分）\n\n盒模型是根据元素的样式来进行计算的，我们可以通过调整元素的样式来改变盒模型。上图中的盒模型来自下面这个<div>元素，我们给这个元素设置了margin、padding和border：\n\n<style>\n  .box-model-sample {\n    margin: 10px;\n    padding: 10px;\n    border: solid 2px #000;\n  }\n</style>\n<div class="box-model-sample">这是一个div</div>\n\n\n在上述代码中，我们通过使用 CSS 样式来控制盒模型的大小和属性。盒模型还常用来控制元素的尺寸、属性（颜色、背景、边框等）和位置，当我们在调试样式的时，比较容易遇到以下这些场景。\n\n1. 盒模型会发生margin外边距叠加，叠加后的值会以最大边距为准。比如，我们给两个相邻的<div>元素分别设置了不同的margin外边距：\n\n<style>\n  .box-model-sample {\n    margin: 10px;\n    padding: 10px;\n    border: solid 2px #000;\n  }\n  .large-margin {\n    margin: 20px;\n  }\n</style>\n<div class="box-model-sample">这是一个div</div>\n<div class="box-model-sample">这是另一个div</div>\n<div class="box-model-sample large-margin">这是一个margin大一点的div</div>\n\n\n这段代码在浏览器中运行时，我们可以看到，两个<div>元素之间发生了margin外边距叠加，它们被合并成单个边距。\n\n\n\n如果两个元素的外边距不一样，叠加的值大小是各个边距中的最大值，比如上面第二个和第三个矩形之间的外边距值，使用的是第三个边框的外边距值 20 px。\n\n\n需要注意的是，并不是所有情况下都会发生外边距叠加，比如行内框、浮动框或绝对定位框之间的外边距不会叠加。\n\n2. 盒模型计算效果有多种，比如元素宽高是否包括了边框。我们可以通过box-sizing属性进行设置盒模型的计算方式，正常的盒模型默认值是content-box。\n\n使用box-sizing属性可以解决问题 1（调整元素的边框时，不影响元素的宽高），我们可以将元素的box-sizing属性设置为border-box：\n\n<style>\n  .box-model-sample {\n    height: 50px;\n    margin: 10px;\n    padding: 5px;\n    border: solid 2px #000;\n  }\n  .border-box {\n    box-sizing: border-box;\n  }\n</style>\n<div class="box-model-sample">这是一个div(content-box)</div>\n<div class="box-model-sample border-box">这是另一个div(border-box)</div>\n\n\n对于默认content-box的元素来说，元素所占的总宽高为设置的元素宽高(width/height)等于：content + padding + border，因此这里该元素总高度为50 + 5 * 2 + 2 * 2 = 64px。\n\n\n\n当我们设置为border-box之后，元素所占的总宽高为设置的元素宽高(width/height)，因此，此时高度为50px：\n\n\n\n也就是说，如果我们在调整元素边框的时候，不影响元素的宽高，可以给元素的box-sizing属性设置为border-box，这便是问题 1 的答案。通过这种方式，我们可以精确地控制元素的空间占位，同时还能灵活地调整元素边框和内边距。\n\n虽然我们可以通过盒模型设置元素的占位情况，但是有些时候我们给元素设置宽高却不生效（见问题 2），这是因为元素本身的性质也做了区分，我们来看一下。\n\n内联元素与块状元素\n\n在浏览器中，元素可分为内联元素和块状元素。比如，<a>元素为内联元素，<div>元素为块状元素，我们分别给它们设置宽高：\n\n<style>\n  a,\n  div {\n    width: 100px;\n    height: 20px;\n  }\n</style>\n<a>a-123</a><a>a-456</a><a>a-789</a>\n<div>div-123</div>\n<div>div-456</div>\n<div>div-789</div>\n\n\n在浏览器中的效果如下图所示：\n\n\n\n可以看到，<a>元素和<div>元素最主要的区别在于：\n\n * <a>元素（内联元素）可以和其他内联元素位于同一行，且宽高设置无效；\n\n * <div>元素（块状元素）不可和其他元素位于同一行，且宽高设置有效。\n\n所以问题 2 的答案是，当我们给某个元素设置宽高不生效，是因为该元素为内联元素。那么有没有办法解决这个问题呢？\n\n我们可以通过设置display的值来对元素进行调整。\n\n * 设置为block块状元素，此时可以设置宽度width和高度height。\n\n * 设置为inline内联元素，此时宽度高度不起作用。\n\n * 设置为inline-block，可以理解为块状元素和内联元素的结合，布局规则包括：\n   \n   * 位于块状元素或者其他内联元素内；\n   \n   * 可容纳其他块状元素或内联元素；\n   \n   * 宽度高度起作用。\n\n除了内联元素和块状元素，我们还可以将元素设置为inline-block，inline-block可以很方便解决一些问题：使元素居中、给inline元素（<a>/<span>）设置宽高、将多个块状元素放在一行等。\n\n文档流和元素定位\n\n接下来，我们来看问题 3：将一个元素固定在页面的某个位置，可以怎么做？这个问题涉及文档流的布局和元素定位的样式设置。\n\n什么是文档流呢？正常的文档流在 HTML 里面为从上到下，从左到右的排版布局。\n\n文档流布局方式可以使用position样式进行调整，包括：static（默认值）、inherit（继承父元素）、relative（相对定位）、absolute（相对非static父元素绝对定位）、fixed（相对浏览器窗口进行绝对定位）。\n\n我们来分别看下这些position样式设置效果。\n\n1. 元素position样式属性值为static(默认值)时，元素会忽略top/bottom/left/right或者z-index声明，比如我们给部分元素设置position: static的样式以及left和top定位 ：\n\na, p, div {\n  border: solid 1px red;\n}\n.static {\n  position: static;\n  left: 100px;\n  top: 100px;\n}\n\n\n在浏览器中，我们可以看到给position: static的元素添加定位left: 100px; top: 100px;是无效的。\n\n\n\n（static 元素的定位设置无效果）\n\n2. 元素position样式属性值为relative时，元素会保持原有文档流，但相对本身的原始位置发生位移，且会占用空间，比如我们给部分元素设置position: relative样式以及left和top定位：\n\na, p, div {\n  border: solid 1px red;\n}\n.relative {\n  position: relative;\n  left: 100px;\n  top: 100px;\n}\n\n\n在浏览器中，我们可以看到position: relative的元素相对于其正常位置进行定位，元素占有原本位置（文档流中占有的位置与其原本位置相同），因此下一个元素会排到该元素后方。\n\n\n\n(relative 定位的元素，定位设置可生效)\n\n这里有个需要注意的地方：虽然relative元素占位与static相同，但会溢出父元素，撑开整个页面。如下图所示，我们能看到浏览器中relative元素撑开父元素看到页面底部有滚动条。\n\n\n\n(relative 定位的元素，可撑开父元素)\n\n此时给父元素设置overflow: hidden;则可以隐藏溢出部分。\n\n\n\n（通过设置overflow: hidden可隐藏溢出部分元素）\n\n3. 元素position样式属性值为absolute、且设置了定位（top/bottom/left/right）时，元素会脱离文档流，相对于其包含块来定位，且不占位，比如我们给position: absolute的元素设置left和top定位 ：\n\n.parent {\n  border: solid 1px blue;\n  width: 300px;\n}\n.parent > div {\n  border: solid 1px red;\n  height: 100px;\n  width: 300px;\n}\n.absolute {\n  position: absolute;\n  left: 100px;\n  height: 100px;\n}\n\n\n在浏览器中，我们可以看到position: absolute的元素不占位，因此下一个符合普通流的元素会略过absolute元素排到其上一个元素的后方。\n\n\n\n（absolute 元素不占位）\n\n4. 元素position样式属性值为fixed时，元素脱离文档流、且不占位，此时看上去与absolute相似。但当我们进行页面滚动的时候，会发现fixed元素位置没有发生变化。\n\n\n\n（fixed 元素同样不占位）\n\n这是因为fixed元素相对于浏览器窗口进行定位，而absolute元素只有在满足“无static定位以外的父元素”的时候，才会相对于document进行定位。\n\n回到问题 3，将一个元素固定在页面的某个位置，可以通过给元素或是其父类元素添加position: fixed或者position: absolute将其固定在浏览器窗口或是文档页面中。\n\n使用元素定位可以将某个元素固定，那么同一个位置中存在多个元素的时候，就会发生元素的堆叠。\n\n元素堆叠 z-index\n\n元素的堆叠方式和顺序，除了与position定位有关，也与z-index有关。通过设置z-index值，我们可以设置元素的堆叠顺序，比如我们给同级的元素添加z-index值：\n\n\n\n（z-index 可改变元素堆叠顺序）\n\n在浏览器中，我们可以看到：\n\n * 当同级元素不设置z-index或者z-index相等时，后面的元素会叠在前面的元素上方；\n\n * 当同级元素z-index不同时，z-index大的元素会叠在z-index小的元素上方。\n\nz-index样式属性比较常用于多个元素层级控制的时候，比如弹窗一般需要在最上层，就可以通过设置较大的z-index值来控制。\n\n那么，我们来看问题 4： 为什么将某个元素z-index设置为9999999，但是它依然被其他元素遮挡住了呢？\n\n这是因为除了同级元素以外，z-index值的设置效果还会受到父元素的z-index值的影响。z-index值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素z-index设置为9999999，它依然可能因为父元素的z-index值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。\n\n现在，我们解答了问题 1~4，同时还学习了关于 CSS 页面布局的核心规则，包括：\n\n * 盒模型主要用来描述元素所占空间的内容；\n\n * 一个元素属于内联元素还是块状元素，会影响它是否可以和其他元素位于同一行、宽高设置是否有效；\n\n * 正常的文档流在 HTML 里面为从上到下、从左到右的排版布局，使用position属性可以使元素脱离正常的文档流；\n\n * 使用z-index属性可以设置元素的堆叠顺序。\n\n掌握了这些页面布局的规则，可以解决我们日常页面中单个元素样式调整中的大多数问题。对于进行整体的页面布局，比如设置元素居中、排版、区域划分等，涉及多个元素的布局，这种情况下常常会用到 Flex、Grid 这样的页面布局方式。下面我们一起来看看。\n\n\n常见页面布局方式\n\n在我们的日常工作中，实现页面的 UI 样式除了会遇到单个元素的样式调整外，还需要对整个页面进行结构布局，比如将页面划分为左中右、上中下模块，实现某些模块的居中对齐，实现页面的响应式布局，等等。\n\n要实现对页面的排版布局，需要使用到一些页面布局方式。目前来说，比较常见的布局方式主要有三种：\n\n * 传统布局方式；\n\n * Flex 布局方式；\n\n * Grid 布局方式。\n\n传统布局\n\n传统布局方式基本上使用上面介绍的布局规则，结合display/position/float属性以及一些边距、x/y 轴距离等方式来进行布局。\n\n除了使用position: fixed或者position: absolute时，会使元素脱离文档流，使用float属性同样会导致元素脱离文档流。\n\n这就涉及问题 5：为什么将某个元素里面的元素设置为float之后，这个元素的高度就歪了呢？\n\n这是因为当我们给元素的float属性赋值后，元素会脱离文档流，进行左右浮动，比如这里我们将其中一个<div>元素添加了float属性 ：\n\n<style>\n  div {\n    border: solid 1px red;\n    width: 50px;\n    height: 50px;\n  }\n  .float {\n    float: left;\n  }\n</style>\n<div>1</div>\n<div class="float">2</div>\n<div class="float">3</div>\n<div>4</div>\n<div>5</div>\n<div class="float">6</div>\n\n\n我们可以在浏览器中看到，float元素会紧贴着父元素或者是上一个同级同浮动元素的边框：\n\n\n\n可以看到当元素设置为float之后，它就脱离文档流，同时也不再占据原本的空间。\n\n因此，问题 5 的答案为：本属于普通流中的元素浮动之后，父元素内部如果不存在其他普通流元素了，就会表现出高度为 0，又称为高度塌陷。\n\n在这样的情况下，我们可以使用以下方法撑开父元素：\n\n * 父元素使用overflow: hidden（此时高度为auto）；\n\n * 使父元素也成为浮动float元素；\n\n * 使用clear清除浮动。\n\n除了 clear 清除浮动之外，这些方法为什么可以达到撑开父元素的效果呢，这是因为 BFC（Block Formatting Context，块格式化上下文）的特性。BFC 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域，详情大家可以私下了解下。\n\n传统方式布局的优势在于兼容性较好，在一些版本较低的浏览器上也能给到用户较友好的体验。但传统布局需要掌握的知识较多也相对复杂，对于整个页面的布局和排版实现，常常是基于盒模型、使用display属性+position属性+float属性的方式来进行，这个过程比较烦琐，因此更多时候我们都会使用开源库（比如 bootstrap）来完成页面布局。\n\n后来 W3C 提出了新的布局方式，可以快速、简便地实现页面的排版布局，新的布局方式包括 Flex 布局和 Grid 布局。\n\n使用 Flex 布局\n\nFlex 布局（又称为 flexbox）是一种一维的布局模型。在使用此布局时，需掌握几个概念。\n\n 1. flexbox 的两根轴线。其中，主轴由flex-direction定义，交叉轴则垂直于主轴。\n\n 2. 在 flexbox 中，使用起始和终止来描述布局方向。\n\n 3. 认识 flex 容器和 flex 元素。\n\n想熟练使用 Flex 布局，我们需要了解什么是 flex 容器和 flex 元素。比如我们给一个父元素div设置display: flex;：\n\n<style>\n  div {\n    border: solid 1px #000;\n    margin: 10px;\n  }\n  .box {\n    display: flex;\n  }\n</style>\n<div class="box">\n  <div>1</div>\n  <div>2</div>\n  <div>3 <br />有其他 <br />内容</div>\n</div>\n\n\n在浏览器中的效果就会如图所示：\n\n\n\n其中，flex 容器为<div class="box">元素及其内部区域，而容器的直系子元素（1、2、3 这 3 个<div>）为 flex 元素。\n\n在掌握了 flex 容器和 flex 元素之后，我们就可以通过调整 flexbox 轴线方向、排列方向和对齐方式的方式，实现需要的页面效果。\n\nFlex 布局种常用的方式包括：\n\n * 通过flex-direction调整 Flex 元素的排列方向（主轴的方向）；\n\n * 用flex-wrap实现多行 Flex 容器如何换行；\n\n * 使用justify-content调整 Flex 元素在主轴上的对齐方式；\n\n * 使用align-items调整 Flex 元素在交叉轴上如何对齐；\n\n * 使用align-content调整多根轴线的对齐方式。\n\nFlex 布局给flexbox的子元素之间提供了强大的空间分布和对齐能力，我们可以方便地使用 Flex 布局来实现垂直和水平居中，比如通过将元素设置为display: flex;，并配合使用align-items: center;、justify-content: center;：\n\n<style>\n  div {\n    border: solid 1px #000;\n  }\n  .box {\n    display: flex;\n    width: 200px;\n    height: 200px;\n    align-items: center;\n    justify-content: center;\n  }\n  .in-box {\n    width: 80px;\n    height: 80px;\n  }\n</style>\n<div class="box">\n  <div class="in-box">我想要垂直水平居中</div>\n</div>\n\n\n就可以将一个元素设置为垂直和水平居中：\n\n\n\n对于传统的布局方式来说，要实现上述垂直水平居中，常常需要依赖绝对定位+元素偏移的方式来实现，该实现方式不够灵活（在调整元素大小时需要调整定位）、难以维护。\n\nFlex 布局的出现，解决了很多前端开发居中、排版的一些痛点，尤其是垂直居中，因此现在几乎成为主流的布局方式。除此之外，还可以对 Flex 元素设置排列顺序、放大比例、缩小比例等。\n\n如果说 Flex 布局是一维布局，那么 Grid 布局则是一种二维布局的方式。\n\nGrid 布局\n\nGrid 布局又称为网格布局，它将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。\n\n我们知道 Flex 布局是基于轴线布局，与之相对，Grid 布局则是将容器划分成行和列，可以像表格一样按行或列来对齐元素。\n\n对于 Grid 布局，同样需要理解几个概念：网格轨道与行列、网格线、网格容器等。其实 Grid 布局很多概念跟 Flex 布局还挺相似的，因此这里不再赘述。\n\n使用 Grid 布局可以：\n\n * 实现网页的响应式布局；\n\n * 实现灵活的 12 列布局（类似于 Bootstrap 的 CSS 布局方式）；\n\n * 与其他布局方式结合，与 css 其他部分协同合作。\n\n通过 Grid 布局我们能实现任意组合不同布局，其设计可称得上目前最强大的布局方式，它与 Flex 布局是未来的趋势。其中，Grid 布局适用于较大规模的布局，Flex 布局则适合页面中的组件和较小规模布局。\n\n\n小结\n\n今天我带大家学习了页面布局中比较核心的一些规则，包括盒模型计算、内联元素与块状元素布局规则、文档流布局和元素堆叠顺序。我们在写 CSS 过程中会遇到很多的“神奇”现象，而要理解这些现象并解决问题，掌握这些页面布局的原理逻辑和规则很重要。\n\n除了页面布局规则之外，我还带大家认识了常见的页面布局方式，包括传统布局方式、FleX 布局和 Grid 布局。\n\n细心的你或许也发现了，我们还遗留了问题 6 没有给出具体的答案：让一个元素进行垂直和水平居中，有多少种实现方式？\n\n这个问题，我希望你可以自己进行解答，欢迎你将答案写在留言区～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **飞：\n\n> 方法挺多的，我常用的主要是如下三种1. 知道元素宽高：margin: 0 auto; position: relative; top: 50%; margin-top: -1/2元素高度2. 不知道元素宽高：margin: 0 auto; position:relative; top:50%;transform: translateY(-50%)3. display: flex;align-items:center;justify-content:center;\n\n#     编辑回复：\n\n>     赞哦\n\n# **宇：\n\n> 传统布局那一块 div4 和 div5重合是为什么呢。。\n\n#     讲师回复：\n\n>     其实你在浏览器中进行观察，就会发现实际上 div4 和 div5 的占位并没有重合，如果你试试给它们加上背景颜色就能看的比较清楚了。之所以看起来它们重合了，是因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# Change：\n\n> 垂直居中的方式：1、通过 inline-block设置元素 height和 line-height 、text-align:center 来进行垂直居中。2、通过 position:absoulte 加偏移量3、通过 flex布局属性 justity-content:center; align-items:center;\n\n# *聪：\n\n> position还有一个可取值：sticky\n\n#     讲师回复：\n\n>     你说的没错，sticky 可以进行粘性定位，在页面滚动的过程中很有用，是我这边写漏了\n\n# **涛：\n\n> 之前快手的面试官和我聊到：浮动的元素会不会脱离文档流，我的答案是会，但是面试官告诉我不会。文章里也提到了这一点，所以来讨论一下，就如这个问题中（https://segmentfault.com/q/1010000002870442/a-1020000002870502）提到的一样：float元素并不会彻底地脱离文档流\n\n#     讲师回复：\n\n>     可以查看 MDN 中的描述：“float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性。”可见，浮动元素的确会从文档流中删除，但它并不是完全彻底地移除。 而我们常说的“脱离”二字并没有官方的定义，因此你和你的面试官理解或许不一样。如果将脱离认为是不符合正常的文档流，那么它便是脱离的；如果将脱离认为是彻底从文档流中移除，那么它便是不会脱离的。\n\n# **圳：\n\n> 九种方式，定宽高3种，不定宽高6种\n\n# **北：\n\n> 疑惑，float布局部分，div6也设置了float，按理说应该会向上同级浮动元素，不应该是div4嘛，为啥4.5还重叠了，6位置还是之前的\n\n#     讲师回复：\n\n>     其实你在浏览器中进行观察，就会发现实际上 div4 和 div5 的占位并没有重合，如果你试试给它们加上背景颜色就能看的比较清楚了。之所以看起来它们重合了，是因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# **星：\n\n> 老师，float布局这里我有一个疑问，div2, div3 设置了float:left, 脱离文档流，div2重叠到div4上面，为什么4被挤出了盒子和5重叠了而不是2与4重叠呢，我知道实际上是div2和div4重叠的，不理解的是为什么div4里边的文字4被挤了出去\n\n#     讲师回复：\n\n>     因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# *雅：\n\n> **飞的第一二两种方式，position:relative配top: 50%真的可以吗？试了不行啊，position:absolute时，top:50%才起效吧\n\n#     讲师回复：\n\n>     是的，应该是父元素需要将 position 设置为 relative/absolute/fixed，同时子元素需要为 position:absolute\n\n# *好：\n\n> 除了前面的还有tabel-cell\n\n#     讲师回复：\n\n>     是的，不过 table-cell 现在很少人使用了，flexbox 使用要方便和简单很多\n\n# **星：\n\n> 都是干货😀\n\n# *聪：\n\n> 纠正老师的读音：赘（zhuì）述😀\n\n#     讲师回复：\n\n>     [哭泣]我的确想这么念的来着，可是我的广普不允许\n\n# **贤：\n\n> 使用display:table-cell，还有一种就是使用grid网格行列去实现',normalizedContent:'前端页面的布局和样式编写是传统技能，但页面样式的实现大多数情况下都无法速成，需要通过不断练习、反复地调试才能熟练掌握，因此有一些同学常常会感到疑惑，比如：\n\n 1. 一个元素总宽高为50px，要怎么在调整边框大小的时候，不需要重新计算和设置width/height呢？\n\n 2. 为什么给一些元素设置宽高，但是却不生效？\n\n 3. 如何将一个元素固定在页面的某个位置，具体怎么做？\n\n 4. 为什么将某个元素z-index设置为9999999，但是它依然被其他元素遮挡住了呢？\n\n 5. 为什么将某个元素里面的元素设置为float之后，这个元素的高度就歪了呢？\n\n 6. 让一个元素进行垂直和水平居中，有多少种实现方式？\n\n这些问题产生的根本，是对页面布局规则和常见页面布局方式没掌握透彻。今天我就帮你重新梳理下页面布局的基本规则和布局方式，让以上问题迎刃而解。\n\n\n页面布局的基本规则\n\n我们在调试页面样式的时候，如果你不了解页面布局规则，会经常遇到“这里为什么歪了”“这里为什么又好了”这样的困惑。其实页面的布局不只是“碰运气”似的调整样式，浏览器的页面布局会有一些规则，包括：\n\n * 盒模型计算；\n\n * 内联元素与块状元素布局规则；\n\n * 文档流布局；\n\n * 元素堆叠。\n\n下面我们可以结合问题逐一来看。\n\n盒模型计算\n\n问题 1：一个元素总宽高为30px，要怎么在调整边框大小的时候，不需要重新计算和设置width/height呢？\n\n这个问题涉及浏览器布局中的盒模型计算。什么是盒模型？浏览器对文档进行布局的时候，会将每个元素都表示为这样一个盒子。\n\n\n\n这就是 css 基础盒模型，也就是我们常说的盒模型。盒模型主要用来描述元素所占空间的内容，它由四个部分组成：\n\n * 外边框边界margin（橙色部分）\n\n * 边框边界border（黄色部分）\n\n * 内边距边界padding（绿色部分）\n\n * 内容边界content（蓝色部分）\n\n盒模型是根据元素的样式来进行计算的，我们可以通过调整元素的样式来改变盒模型。上图中的盒模型来自下面这个<div>元素，我们给这个元素设置了margin、padding和border：\n\n<style>\n  .box-model-sample {\n    margin: 10px;\n    padding: 10px;\n    border: solid 2px #000;\n  }\n</style>\n<div class="box-model-sample">这是一个div</div>\n\n\n在上述代码中，我们通过使用 css 样式来控制盒模型的大小和属性。盒模型还常用来控制元素的尺寸、属性（颜色、背景、边框等）和位置，当我们在调试样式的时，比较容易遇到以下这些场景。\n\n1. 盒模型会发生margin外边距叠加，叠加后的值会以最大边距为准。比如，我们给两个相邻的<div>元素分别设置了不同的margin外边距：\n\n<style>\n  .box-model-sample {\n    margin: 10px;\n    padding: 10px;\n    border: solid 2px #000;\n  }\n  .large-margin {\n    margin: 20px;\n  }\n</style>\n<div class="box-model-sample">这是一个div</div>\n<div class="box-model-sample">这是另一个div</div>\n<div class="box-model-sample large-margin">这是一个margin大一点的div</div>\n\n\n这段代码在浏览器中运行时，我们可以看到，两个<div>元素之间发生了margin外边距叠加，它们被合并成单个边距。\n\n\n\n如果两个元素的外边距不一样，叠加的值大小是各个边距中的最大值，比如上面第二个和第三个矩形之间的外边距值，使用的是第三个边框的外边距值 20 px。\n\n\n需要注意的是，并不是所有情况下都会发生外边距叠加，比如行内框、浮动框或绝对定位框之间的外边距不会叠加。\n\n2. 盒模型计算效果有多种，比如元素宽高是否包括了边框。我们可以通过box-sizing属性进行设置盒模型的计算方式，正常的盒模型默认值是content-box。\n\n使用box-sizing属性可以解决问题 1（调整元素的边框时，不影响元素的宽高），我们可以将元素的box-sizing属性设置为border-box：\n\n<style>\n  .box-model-sample {\n    height: 50px;\n    margin: 10px;\n    padding: 5px;\n    border: solid 2px #000;\n  }\n  .border-box {\n    box-sizing: border-box;\n  }\n</style>\n<div class="box-model-sample">这是一个div(content-box)</div>\n<div class="box-model-sample border-box">这是另一个div(border-box)</div>\n\n\n对于默认content-box的元素来说，元素所占的总宽高为设置的元素宽高(width/height)等于：content + padding + border，因此这里该元素总高度为50 + 5 * 2 + 2 * 2 = 64px。\n\n\n\n当我们设置为border-box之后，元素所占的总宽高为设置的元素宽高(width/height)，因此，此时高度为50px：\n\n\n\n也就是说，如果我们在调整元素边框的时候，不影响元素的宽高，可以给元素的box-sizing属性设置为border-box，这便是问题 1 的答案。通过这种方式，我们可以精确地控制元素的空间占位，同时还能灵活地调整元素边框和内边距。\n\n虽然我们可以通过盒模型设置元素的占位情况，但是有些时候我们给元素设置宽高却不生效（见问题 2），这是因为元素本身的性质也做了区分，我们来看一下。\n\n内联元素与块状元素\n\n在浏览器中，元素可分为内联元素和块状元素。比如，<a>元素为内联元素，<div>元素为块状元素，我们分别给它们设置宽高：\n\n<style>\n  a,\n  div {\n    width: 100px;\n    height: 20px;\n  }\n</style>\n<a>a-123</a><a>a-456</a><a>a-789</a>\n<div>div-123</div>\n<div>div-456</div>\n<div>div-789</div>\n\n\n在浏览器中的效果如下图所示：\n\n\n\n可以看到，<a>元素和<div>元素最主要的区别在于：\n\n * <a>元素（内联元素）可以和其他内联元素位于同一行，且宽高设置无效；\n\n * <div>元素（块状元素）不可和其他元素位于同一行，且宽高设置有效。\n\n所以问题 2 的答案是，当我们给某个元素设置宽高不生效，是因为该元素为内联元素。那么有没有办法解决这个问题呢？\n\n我们可以通过设置display的值来对元素进行调整。\n\n * 设置为block块状元素，此时可以设置宽度width和高度height。\n\n * 设置为inline内联元素，此时宽度高度不起作用。\n\n * 设置为inline-block，可以理解为块状元素和内联元素的结合，布局规则包括：\n   \n   * 位于块状元素或者其他内联元素内；\n   \n   * 可容纳其他块状元素或内联元素；\n   \n   * 宽度高度起作用。\n\n除了内联元素和块状元素，我们还可以将元素设置为inline-block，inline-block可以很方便解决一些问题：使元素居中、给inline元素（<a>/<span>）设置宽高、将多个块状元素放在一行等。\n\n文档流和元素定位\n\n接下来，我们来看问题 3：将一个元素固定在页面的某个位置，可以怎么做？这个问题涉及文档流的布局和元素定位的样式设置。\n\n什么是文档流呢？正常的文档流在 html 里面为从上到下，从左到右的排版布局。\n\n文档流布局方式可以使用position样式进行调整，包括：static（默认值）、inherit（继承父元素）、relative（相对定位）、absolute（相对非static父元素绝对定位）、fixed（相对浏览器窗口进行绝对定位）。\n\n我们来分别看下这些position样式设置效果。\n\n1. 元素position样式属性值为static(默认值)时，元素会忽略top/bottom/left/right或者z-index声明，比如我们给部分元素设置position: static的样式以及left和top定位 ：\n\na, p, div {\n  border: solid 1px red;\n}\n.static {\n  position: static;\n  left: 100px;\n  top: 100px;\n}\n\n\n在浏览器中，我们可以看到给position: static的元素添加定位left: 100px; top: 100px;是无效的。\n\n\n\n（static 元素的定位设置无效果）\n\n2. 元素position样式属性值为relative时，元素会保持原有文档流，但相对本身的原始位置发生位移，且会占用空间，比如我们给部分元素设置position: relative样式以及left和top定位：\n\na, p, div {\n  border: solid 1px red;\n}\n.relative {\n  position: relative;\n  left: 100px;\n  top: 100px;\n}\n\n\n在浏览器中，我们可以看到position: relative的元素相对于其正常位置进行定位，元素占有原本位置（文档流中占有的位置与其原本位置相同），因此下一个元素会排到该元素后方。\n\n\n\n(relative 定位的元素，定位设置可生效)\n\n这里有个需要注意的地方：虽然relative元素占位与static相同，但会溢出父元素，撑开整个页面。如下图所示，我们能看到浏览器中relative元素撑开父元素看到页面底部有滚动条。\n\n\n\n(relative 定位的元素，可撑开父元素)\n\n此时给父元素设置overflow: hidden;则可以隐藏溢出部分。\n\n\n\n（通过设置overflow: hidden可隐藏溢出部分元素）\n\n3. 元素position样式属性值为absolute、且设置了定位（top/bottom/left/right）时，元素会脱离文档流，相对于其包含块来定位，且不占位，比如我们给position: absolute的元素设置left和top定位 ：\n\n.parent {\n  border: solid 1px blue;\n  width: 300px;\n}\n.parent > div {\n  border: solid 1px red;\n  height: 100px;\n  width: 300px;\n}\n.absolute {\n  position: absolute;\n  left: 100px;\n  height: 100px;\n}\n\n\n在浏览器中，我们可以看到position: absolute的元素不占位，因此下一个符合普通流的元素会略过absolute元素排到其上一个元素的后方。\n\n\n\n（absolute 元素不占位）\n\n4. 元素position样式属性值为fixed时，元素脱离文档流、且不占位，此时看上去与absolute相似。但当我们进行页面滚动的时候，会发现fixed元素位置没有发生变化。\n\n\n\n（fixed 元素同样不占位）\n\n这是因为fixed元素相对于浏览器窗口进行定位，而absolute元素只有在满足“无static定位以外的父元素”的时候，才会相对于document进行定位。\n\n回到问题 3，将一个元素固定在页面的某个位置，可以通过给元素或是其父类元素添加position: fixed或者position: absolute将其固定在浏览器窗口或是文档页面中。\n\n使用元素定位可以将某个元素固定，那么同一个位置中存在多个元素的时候，就会发生元素的堆叠。\n\n元素堆叠 z-index\n\n元素的堆叠方式和顺序，除了与position定位有关，也与z-index有关。通过设置z-index值，我们可以设置元素的堆叠顺序，比如我们给同级的元素添加z-index值：\n\n\n\n（z-index 可改变元素堆叠顺序）\n\n在浏览器中，我们可以看到：\n\n * 当同级元素不设置z-index或者z-index相等时，后面的元素会叠在前面的元素上方；\n\n * 当同级元素z-index不同时，z-index大的元素会叠在z-index小的元素上方。\n\nz-index样式属性比较常用于多个元素层级控制的时候，比如弹窗一般需要在最上层，就可以通过设置较大的z-index值来控制。\n\n那么，我们来看问题 4： 为什么将某个元素z-index设置为9999999，但是它依然被其他元素遮挡住了呢？\n\n这是因为除了同级元素以外，z-index值的设置效果还会受到父元素的z-index值的影响。z-index值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素z-index设置为9999999，它依然可能因为父元素的z-index值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。\n\n现在，我们解答了问题 1~4，同时还学习了关于 css 页面布局的核心规则，包括：\n\n * 盒模型主要用来描述元素所占空间的内容；\n\n * 一个元素属于内联元素还是块状元素，会影响它是否可以和其他元素位于同一行、宽高设置是否有效；\n\n * 正常的文档流在 html 里面为从上到下、从左到右的排版布局，使用position属性可以使元素脱离正常的文档流；\n\n * 使用z-index属性可以设置元素的堆叠顺序。\n\n掌握了这些页面布局的规则，可以解决我们日常页面中单个元素样式调整中的大多数问题。对于进行整体的页面布局，比如设置元素居中、排版、区域划分等，涉及多个元素的布局，这种情况下常常会用到 flex、grid 这样的页面布局方式。下面我们一起来看看。\n\n\n常见页面布局方式\n\n在我们的日常工作中，实现页面的 ui 样式除了会遇到单个元素的样式调整外，还需要对整个页面进行结构布局，比如将页面划分为左中右、上中下模块，实现某些模块的居中对齐，实现页面的响应式布局，等等。\n\n要实现对页面的排版布局，需要使用到一些页面布局方式。目前来说，比较常见的布局方式主要有三种：\n\n * 传统布局方式；\n\n * flex 布局方式；\n\n * grid 布局方式。\n\n传统布局\n\n传统布局方式基本上使用上面介绍的布局规则，结合display/position/float属性以及一些边距、x/y 轴距离等方式来进行布局。\n\n除了使用position: fixed或者position: absolute时，会使元素脱离文档流，使用float属性同样会导致元素脱离文档流。\n\n这就涉及问题 5：为什么将某个元素里面的元素设置为float之后，这个元素的高度就歪了呢？\n\n这是因为当我们给元素的float属性赋值后，元素会脱离文档流，进行左右浮动，比如这里我们将其中一个<div>元素添加了float属性 ：\n\n<style>\n  div {\n    border: solid 1px red;\n    width: 50px;\n    height: 50px;\n  }\n  .float {\n    float: left;\n  }\n</style>\n<div>1</div>\n<div class="float">2</div>\n<div class="float">3</div>\n<div>4</div>\n<div>5</div>\n<div class="float">6</div>\n\n\n我们可以在浏览器中看到，float元素会紧贴着父元素或者是上一个同级同浮动元素的边框：\n\n\n\n可以看到当元素设置为float之后，它就脱离文档流，同时也不再占据原本的空间。\n\n因此，问题 5 的答案为：本属于普通流中的元素浮动之后，父元素内部如果不存在其他普通流元素了，就会表现出高度为 0，又称为高度塌陷。\n\n在这样的情况下，我们可以使用以下方法撑开父元素：\n\n * 父元素使用overflow: hidden（此时高度为auto）；\n\n * 使父元素也成为浮动float元素；\n\n * 使用clear清除浮动。\n\n除了 clear 清除浮动之外，这些方法为什么可以达到撑开父元素的效果呢，这是因为 bfc（block formatting context，块格式化上下文）的特性。bfc 是 web 页面的可视 css 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域，详情大家可以私下了解下。\n\n传统方式布局的优势在于兼容性较好，在一些版本较低的浏览器上也能给到用户较友好的体验。但传统布局需要掌握的知识较多也相对复杂，对于整个页面的布局和排版实现，常常是基于盒模型、使用display属性+position属性+float属性的方式来进行，这个过程比较烦琐，因此更多时候我们都会使用开源库（比如 bootstrap）来完成页面布局。\n\n后来 w3c 提出了新的布局方式，可以快速、简便地实现页面的排版布局，新的布局方式包括 flex 布局和 grid 布局。\n\n使用 flex 布局\n\nflex 布局（又称为 flexbox）是一种一维的布局模型。在使用此布局时，需掌握几个概念。\n\n 1. flexbox 的两根轴线。其中，主轴由flex-direction定义，交叉轴则垂直于主轴。\n\n 2. 在 flexbox 中，使用起始和终止来描述布局方向。\n\n 3. 认识 flex 容器和 flex 元素。\n\n想熟练使用 flex 布局，我们需要了解什么是 flex 容器和 flex 元素。比如我们给一个父元素div设置display: flex;：\n\n<style>\n  div {\n    border: solid 1px #000;\n    margin: 10px;\n  }\n  .box {\n    display: flex;\n  }\n</style>\n<div class="box">\n  <div>1</div>\n  <div>2</div>\n  <div>3 <br />有其他 <br />内容</div>\n</div>\n\n\n在浏览器中的效果就会如图所示：\n\n\n\n其中，flex 容器为<div class="box">元素及其内部区域，而容器的直系子元素（1、2、3 这 3 个<div>）为 flex 元素。\n\n在掌握了 flex 容器和 flex 元素之后，我们就可以通过调整 flexbox 轴线方向、排列方向和对齐方式的方式，实现需要的页面效果。\n\nflex 布局种常用的方式包括：\n\n * 通过flex-direction调整 flex 元素的排列方向（主轴的方向）；\n\n * 用flex-wrap实现多行 flex 容器如何换行；\n\n * 使用justify-content调整 flex 元素在主轴上的对齐方式；\n\n * 使用align-items调整 flex 元素在交叉轴上如何对齐；\n\n * 使用align-content调整多根轴线的对齐方式。\n\nflex 布局给flexbox的子元素之间提供了强大的空间分布和对齐能力，我们可以方便地使用 flex 布局来实现垂直和水平居中，比如通过将元素设置为display: flex;，并配合使用align-items: center;、justify-content: center;：\n\n<style>\n  div {\n    border: solid 1px #000;\n  }\n  .box {\n    display: flex;\n    width: 200px;\n    height: 200px;\n    align-items: center;\n    justify-content: center;\n  }\n  .in-box {\n    width: 80px;\n    height: 80px;\n  }\n</style>\n<div class="box">\n  <div class="in-box">我想要垂直水平居中</div>\n</div>\n\n\n就可以将一个元素设置为垂直和水平居中：\n\n\n\n对于传统的布局方式来说，要实现上述垂直水平居中，常常需要依赖绝对定位+元素偏移的方式来实现，该实现方式不够灵活（在调整元素大小时需要调整定位）、难以维护。\n\nflex 布局的出现，解决了很多前端开发居中、排版的一些痛点，尤其是垂直居中，因此现在几乎成为主流的布局方式。除此之外，还可以对 flex 元素设置排列顺序、放大比例、缩小比例等。\n\n如果说 flex 布局是一维布局，那么 grid 布局则是一种二维布局的方式。\n\ngrid 布局\n\ngrid 布局又称为网格布局，它将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。\n\n我们知道 flex 布局是基于轴线布局，与之相对，grid 布局则是将容器划分成行和列，可以像表格一样按行或列来对齐元素。\n\n对于 grid 布局，同样需要理解几个概念：网格轨道与行列、网格线、网格容器等。其实 grid 布局很多概念跟 flex 布局还挺相似的，因此这里不再赘述。\n\n使用 grid 布局可以：\n\n * 实现网页的响应式布局；\n\n * 实现灵活的 12 列布局（类似于 bootstrap 的 css 布局方式）；\n\n * 与其他布局方式结合，与 css 其他部分协同合作。\n\n通过 grid 布局我们能实现任意组合不同布局，其设计可称得上目前最强大的布局方式，它与 flex 布局是未来的趋势。其中，grid 布局适用于较大规模的布局，flex 布局则适合页面中的组件和较小规模布局。\n\n\n小结\n\n今天我带大家学习了页面布局中比较核心的一些规则，包括盒模型计算、内联元素与块状元素布局规则、文档流布局和元素堆叠顺序。我们在写 css 过程中会遇到很多的“神奇”现象，而要理解这些现象并解决问题，掌握这些页面布局的原理逻辑和规则很重要。\n\n除了页面布局规则之外，我还带大家认识了常见的页面布局方式，包括传统布局方式、flex 布局和 grid 布局。\n\n细心的你或许也发现了，我们还遗留了问题 6 没有给出具体的答案：让一个元素进行垂直和水平居中，有多少种实现方式？\n\n这个问题，我希望你可以自己进行解答，欢迎你将答案写在留言区～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **飞：\n\n> 方法挺多的，我常用的主要是如下三种1. 知道元素宽高：margin: 0 auto; position: relative; top: 50%; margin-top: -1/2元素高度2. 不知道元素宽高：margin: 0 auto; position:relative; top:50%;transform: translatey(-50%)3. display: flex;align-items:center;justify-content:center;\n\n#     编辑回复：\n\n>     赞哦\n\n# **宇：\n\n> 传统布局那一块 div4 和 div5重合是为什么呢。。\n\n#     讲师回复：\n\n>     其实你在浏览器中进行观察，就会发现实际上 div4 和 div5 的占位并没有重合，如果你试试给它们加上背景颜色就能看的比较清楚了。之所以看起来它们重合了，是因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# change：\n\n> 垂直居中的方式：1、通过 inline-block设置元素 height和 line-height 、text-align:center 来进行垂直居中。2、通过 position:absoulte 加偏移量3、通过 flex布局属性 justity-content:center; align-items:center;\n\n# *聪：\n\n> position还有一个可取值：sticky\n\n#     讲师回复：\n\n>     你说的没错，sticky 可以进行粘性定位，在页面滚动的过程中很有用，是我这边写漏了\n\n# **涛：\n\n> 之前快手的面试官和我聊到：浮动的元素会不会脱离文档流，我的答案是会，但是面试官告诉我不会。文章里也提到了这一点，所以来讨论一下，就如这个问题中（https://segmentfault.com/q/1010000002870442/a-1020000002870502）提到的一样：float元素并不会彻底地脱离文档流\n\n#     讲师回复：\n\n>     可以查看 mdn 中的描述：“float css属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性。”可见，浮动元素的确会从文档流中删除，但它并不是完全彻底地移除。 而我们常说的“脱离”二字并没有官方的定义，因此你和你的面试官理解或许不一样。如果将脱离认为是不符合正常的文档流，那么它便是脱离的；如果将脱离认为是彻底从文档流中移除，那么它便是不会脱离的。\n\n# **圳：\n\n> 九种方式，定宽高3种，不定宽高6种\n\n# **北：\n\n> 疑惑，float布局部分，div6也设置了float，按理说应该会向上同级浮动元素，不应该是div4嘛，为啥4.5还重叠了，6位置还是之前的\n\n#     讲师回复：\n\n>     其实你在浏览器中进行观察，就会发现实际上 div4 和 div5 的占位并没有重合，如果你试试给它们加上背景颜色就能看的比较清楚了。之所以看起来它们重合了，是因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# **星：\n\n> 老师，float布局这里我有一个疑问，div2, div3 设置了float:left, 脱离文档流，div2重叠到div4上面，为什么4被挤出了盒子和5重叠了而不是2与4重叠呢，我知道实际上是div2和div4重叠的，不理解的是为什么div4里边的文字4被挤了出去\n\n#     讲师回复：\n\n>     因为浮动元素会对相邻的元素造成影响，其中就包括了文字会尽可能围绕浮动元素。在 div4 上加上 clear: left; 就可以清除 float 带来的影响\n\n# *雅：\n\n> **飞的第一二两种方式，position:relative配top: 50%真的可以吗？试了不行啊，position:absolute时，top:50%才起效吧\n\n#     讲师回复：\n\n>     是的，应该是父元素需要将 position 设置为 relative/absolute/fixed，同时子元素需要为 position:absolute\n\n# *好：\n\n> 除了前面的还有tabel-cell\n\n#     讲师回复：\n\n>     是的，不过 table-cell 现在很少人使用了，flexbox 使用要方便和简单很多\n\n# **星：\n\n> 都是干货😀\n\n# *聪：\n\n> 纠正老师的读音：赘（zhui）述😀\n\n#     讲师回复：\n\n>     [哭泣]我的确想这么念的来着，可是我的广普不允许\n\n# **贤：\n\n> 使用display:table-cell，还有一种就是使用grid网格行列去实现',charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"JavaScript 如何实现继承？",frontmatter:{title:"JavaScript 如何实现继承？",date:"2022-04-14T22:48:01.000Z",permalink:"/pages/884d6e/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/03.JavaScript%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F.html",relativePath:"01.前端/01.前端开发笔记/03.JavaScript 如何实现继承？.md",key:"v-1e37fba9",path:"/pages/884d6e/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5613}],headersStr:"精选评论",content:"JavaScript 在编程语言界是个异类，它和其他编程语言很不一样，JavaScript 可以在运行的时候动态地改变某个变量的类型。\n\n比如你永远也没法想到像isTimeout这样一个变量可以存在多少种类型，除了布尔值true和false，它还可能是undefined、1和0、一个时间戳，甚至一个对象。\n\n又或者你的代码跑异常了，打开浏览器开始断点，发现InfoList这个变量第一次被赋值的时候是个数组[{name: 'test1', value: '11'}, {name: 'test2', value: '22'}]，过了一会竟然变成了一个对象{test1:'11', test2: '22'}\n\n除了变量可以在运行时被赋值为任何类型以外，JavaScript 中也能实现继承，但它不像 Java、C++、C# 这些编程语言一样基于类来实现继承，而是基于原型进行继承。\n\n这是因为 JavaScript 中有个特殊的存在：对象。每个对象还都拥有一个原型对象，并可以从中继承方法和属性。\n\n提到对象和原型，你曾经是否有过这些疑惑：\n\n 1. JavaScript 的函数怎么也是个对象？\n\n 2. __proto__和prototype到底是啥关系？\n\n 3. JavaScript 中对象是怎么实现继承的？\n\n 4. JavaScript 是怎么访问对象的方法和属性的？\n\n下面我们一起结合问题，来探讨下 JavaScript 对象和继承。\n\n\n原型对象和对象是什么关系\n\n在 JavaScript 中，对象由一组或多组的属性和值组成：\n\n{\n  key1: value1,\n  key2: value2,\n  key3: value3,\n}\n\n\n在 JavaScript 中，对象的用途很是广泛，因为它的值既可以是原始类型（number、string、boolean、null、undefined、bigint和symbol），还可以是对象和函数。\n\n不管是对象，还是函数和数组，它们都是Object的实例，也就是说在 JavaScript 中，除了原始类型以外，其余都是对象。\n\n这也就解答了疑惑 1：JavaScript 的函数怎么也是个对象？\n\n在 JavaScript 中，函数也是一种特殊的对象，它同样拥有属性和值。所有的函数会有一个特别的属性prototype，该属性的值是一个对象，这个对象便是我们常说的“原型对象”。\n\n我们可以在控制台打印一下这个属性：\n\nfunction Person(name) {\n  this.name = name;\n}\nconsole.log(Person.prototype);\n\n\n打印结果显示为：\n\n\n\n可以看到，该原型对象有两个属性：constructor和__proto__。\n\n到这里，我们仿佛看到疑惑 “2：__proto__和prototype到底是啥关系？”的答案要出现了。在 JavaScript 中，__proto__属性指向对象的原型对象，对于函数来说，它的原型对象便是prototype。函数的原型对象prototype有以下特点：\n\n * 默认情况下，所有函数的原型对象（prototype）都拥有constructor属性，该属性指向与之关联的构造函数，在这里构造函数便是Person函数；\n\n * Person函数的原型对象（prototype）同样拥有自己的原型对象，用__proto__属性表示。前面说过，函数是Object的实例，因此Person.prototype的原型对象为Object.prototype。\n\n我们可以用这样一张图来描述prototype、__proto__和constructor三个属性的关系：\n\n\n\n从这个图中，我们可以找到这样的关系：\n\n * 在 JavaScript 中，__proto__属性指向对象的原型对象；\n\n * 对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象。\n\n这是否就是疑惑 2 的完整答案呢？并不全是，在 JavaScript 中还可以通过prototype和__proto__实现继承。\n\n\n使用 prototype 和 proto 实现继承\n\n前面我们说过，对象之所以使用广泛，是因为对象的属性值可以为任意类型。因此，属性的值同样可以为另外一个对象，这意味着 JavaScript 可以这么做：通过将对象 A 的__proto__属性赋值为对象 B，即A.__proto__ = B，此时使用A.__proto__便可以访问 B 的属性和方法。\n\n这样，JavaScript 可以在两个对象之间创建一个关联，使得一个对象可以访问另一个对象的属性和方法，从而实现了继承，此时疑惑 “3. JavaScript 中对象是怎么实现继承的？”解答完毕。\n\n那么，JavaScript 又是怎样使用prototype和__proto__实现继承的呢？\n\n继续以Person为例，当我们使用new Person()创建对象时，JavaScript 就会创建构造函数Person的实例，比如这里我们创建了一个叫“Lily”的Person：\n\nvar lily = new Person(\"Lily\");\n\n\n上述这段代码在运行时，JavaScript 引擎通过将Person的原型对象prototype赋值给实例对象lily的__proto__属性，实现了lily对Person的继承，即执行了以下代码：\n\n// 实际上 JavaScript 引擎执行了以下代码\nvar lily = {};\nlily.__proto__ = Person.prototype;\nPerson.call(lily, \"Lily\");\n\n\n我们来打印一下lily实例：\n\n\n\n可以看到，lily作为Person的实例对象，它的__proto__指向了Person的原型对象，即Person.prototype。\n\n这时，我们再补充下上图中的关系：\n\n\n\n从这幅图中，我们可以清晰地看到构造函数和constructor属性、原型对象（prototype）和__proto__、实例对象之间的关系，这是很多初学者容易搞混的。根据这张图，我们可以得到以下的关系：\n\n 1. 每个函数的原型对象（Person.prototype）都拥有constructor属性，指向该原型对象的构造函数（Person）；\n\n 2. 使用构造函数（new Person()）可以创建对象，创建的对象称为实例对象（lily）；\n\n 3. 实例对象通过将__proto__属性指向构造函数的原型对象（Person.prototype），实现了该原型对象的继承。\n\n那么现在，关于疑惑 2 中__proto__和prototype的关系，我们可以得到这样的答案：\n\n * 每个对象都有__proto__属性来标识自己所继承的原型对象，但只有函数才有prototype属性；\n\n * 对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象；\n\n * 通过将实例对象的__proto__属性赋值为其构造函数的原型对象prototype，JavaScript 可以使用构造函数创建对象的方式，来实现继承。\n\n现在我们知道，一个对象可通过__proto__访问原型对象上的属性和方法，而该原型同样也可通过__proto__访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链。这里我用红色的线将lily实例的原型链标了出来。\n\n\n\n下面一起来进行疑惑 4 “JavaScript 是怎么访问对象的方法和属性的？”的解答：在 JavaScript 中，是通过遍历原型链的方式，来访问对象的方法和属性。\n\n\n通过原型链访问对象的方法和属性\n\n当 JavaScript 试图访问一个对象的属性时，会基于原型链进行查找。查找的过程是这样的：\n\n * 首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃告警）；\n\n * JavaScript 中的所有对象都来自Object，Object.prototype.__proto__ === null。null没有原型，并作为这个原型链中的最后一个环节；\n\n * JavaScript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为undefined。\n\n我们可以通过一个具体的例子，来表示基于原型链的对象属性的访问过程，在该例子中我们构建了一条对象的原型链，并进行属性值的访问：\n\n// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：\nvar o = {a: 1, b: 2};\n// o 的原型 o.__proto__有属性 b 和 c：\no.__proto__ = {b: 3, c: 4};\n// 最后, o.__proto__.__proto__ 是 null.\n// 这就是原型链的末尾，即 null，\n// 根据定义，null 没有__proto__.\n// 综上，整个原型链如下:\n{a:1, b:2} ---\x3e {b:3, c:4} ---\x3e null\n// 当我们在获取属性值的时候，就会触发原型链的查找：\nconsole.log(o.a); // o.a => 1\nconsole.log(o.b); // o.b => 2\nconsole.log(o.c); // o.c => o.__proto__.c => 4\nconsole.log(o.d); // o.c => o.__proto__.d => o.__proto__.__proto__ == null => undefined\n\n\n可以看到，当我们对对象进行属性值的获取时，会触发该对象的原型链查找过程。\n\n既然 JavaScript 中会通过遍历原型链来访问对象的属性，那么我们可以通过原型链的方式进行继承。\n\n也就是说，可以通过原型链去访问原型对象上的属性和方法，我们不需要在创建对象的时候给该对象重新赋值/添加方法。比如，我们调用lily.toString()时，JavaScript 引擎会进行以下操作：\n\n 1. 先检查lily对象是否具有可用的toString()方法；\n\n 2. 如果没有，则``检查lily的原型对象（Person.prototype）是否具有可用的toString()方法；\n\n 3. 如果也没有，则检查Person()构造函数的prototype属性所指向的对象的原型对象（即Object.prototype）是否具有可用的toString()方法，于是该方法被调用。\n\n由于通过原型链进行属性的查找，需要层层遍历各个原型对象，此时可能会带来性能问题：\n\n * 当试图访问不存在的属性时，会遍历整个原型链；\n\n * 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。\n\n因此，我们在设计对象的时候，需要注意代码中原型链的长度。当原型链过长时，可以选择进行分解，来避免可能带来的性能问题。\n\n除了通过原型链的方式实现 JavaScript 继承，JavaScript 中实现继承的方式还包括经典继承(盗用构造函数)、组合继承、原型式继承、寄生式继承，等等。\n\n * 原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有；\n\n * 经典继承方式可以实现实例属性私有，但要求类型只能通过构造函数来定义；\n\n * 组合继承融合原型链继承和构造函数的优点，它的实现如下：\n\nfunction Parent(name) {\n  // 私有属性，不共享\n  this.name = name;\n}\n\n\n// 需要复用、共享的方法定义在父类原型上\nParent.prototype.speak = function() {\nconsole.log(\"hello\");\n};\n\n\nfunction Child(name) {\nParent.call(this, name);\n}\n\n\n// 继承方法\nChild.prototype = new Parent();\n\n\n\n\n组合继承模式通过将共享属性定义在父类原型上、将私有属性通过构造函数赋值的方式，实现了按需共享对象和方法，是 JavaScript 中最常用的继承模式。\n\n虽然在继承的实现方式上有很多种，但实际上都离不开原型对象和原型链的内容，因此掌握__proto__和prototype、对象的继承等这些知识，是我们实现各种继承方式的前提。\n\n\n小结\n\n关于 JavaScript 的原型和继承，常常会在我们面试题中出现。随着 ES6/ES7 等新语法糖的出现，我们在日常开发中可能更倾向于使用class/extends等语法来编写代码，原型继承等概念逐渐变淡。\n\n但不管语法糖怎么先进，JavaScript 的设计在本质上依然没有变化，依然是基于原型来实现继承的。如果不了解这些内容，可能在我们遇到一些超出自己认知范围的内容时，很容易束手无策。\n\n现在，本文开始的四个疑惑我都在文中进行解答了，现在该轮到你了：\n\n 1. JavaScript 的函数和对象是怎样的关系？\n\n 2. __proto__和prototype都表示原型对象，它们有什么区别呢？\n\n 3. JavaScript 中对象的继承和原型链是什么关系？\n\n把你的想法写在留言区~\n\n----------------------------------------\n\n\n# 精选评论\n\n# Better：\n\n> 老师讲的好棒👍🏻1. 函数是一种特殊的对象，在对象内部属性拥有仅供 JavaScript引擎读取的 Call 属性的对象称为函数，使用 typeof 检测时会被识别为 function 。2. proto 可以称作指针指向 prototype ，后者实质上也是对象。3. 可以将 proto 比作链，prototype 比作节点，以 null 为顶点链接起来形成原型链，当访问标识符时，实例没有则会去原型链上查找，找到则返回结果，直到顶端 null 没找到则返回 undefined。\n\n#     编辑回复：\n\n>     你也好棒！\n\n# **2951：\n\n> 1、Function instanceof Object === true;2、只有函数才有prototype 只有对象才有__proto__;3、一个对象的__proto__指向了另一个对象， 另一个对象的__proto__又指向了其他对象，举例let a = {name : \"a\"}let b = {age: 12}let c={}c.proto = bb.proto = a此时 c继承了a 和 b b继承了 a，同时他们的继承关系组成了一条原型链\n\n#     讲师回复：\n\n>     没毛病！\n\n# *聪：\n\n> 对于构造函数，原型对象等概念不清晰的同学可以看看我的CSDN上的博客（看完一定懂）：《帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）》，没错，原创：码飞_CC，就是我啦~~\n\n# **雄：\n\n> 被删老师你好，我对于”函数的 prototype 属性指向它的原型对象“这句话有不同的看法；在此之前你说每个对象的 __proto__ 指向它的原型对象，我是比较赞成的，所以对于函数，它的原型对象也应该是由 __proto__ 指向的。那么函数的 prototype 要怎么理解的，它应该指向函数的实例对象的原型对象；对于一个函数，它的原型对象应该是 fn.proto = Function.prototype , 也就是对于内置的构造函数 Function 的 prototype 指向它的实例对象 fn 的原型对象；以上是我结合老师讲解后，觉得有一丢丢矛盾的地方，进行了一点点自己的理解，不知道是否有偏差，希望老师能点评一下，万分感谢\n\n#     讲师回复：\n\n>     文中应该没有说 prototype 属性指向它的原型对象？prototype 属性可以理解为就是函数的原型对象。 Function.prototype 在实例化之前就存在了，而 fn.proto = Function.prototype 是在实例化过程中，将实例的 proto 属性指向 Function.prototype 从而构成原型链。函数本身、以及函数的实例，这两者需要区分清楚~ 因此，你说的“对于内置的构造函数 Function 的 prototype 指向它的实例对象 fn 的原型对象”，个人认为这样可能更加准确：“fn 这个实例，它的 proto 指向它的构造函数的原型对象，即 Function.prototype”。\n\n# **怿：\n\n> Person.proto === lily.proto ?\n\n#     讲师回复：\n\n>     lily.proto === Person.prototype； Person.prototype.proto === Object.prototype；\n\n# *聪：\n\n>  1. JavaScript中的函数也是一种对象。除了七种基本类型值，其他的所有都是对象，这就是JS中所谓的万物皆对象。2.__ptoto__属性是对象独有的，prototype属性是函数所独有的，因为函数也是一种对象，所以函数既有__proto__属性，也具有prototype属性，这点需要细细品味！3.对象的继承是依靠原型链来实现的，通过原型链，我们才可以使用其他对象上的属性或方法。\n\n# **远：\n\n> 其实 proto 属性是 chrome 自己搞出来的，没有被标准化，并且最新的 chrome 浏览器已经弃用这个属性了，改为 prototype 表示私有属性。标准中有专门用来访问对象原型的方法啊，就是 Object.getPrototypeOf()，标准提供了 Get/SetPrototypeOf 这两个方法用来操作对象的原型，应该避免使用 proto 属性。继承一个对象的话，也是推荐 Object.create 方法，避免使用 proto 属性。\n\n# *山：\n\n> 当原型链过长时，可以选择进行分解，来避免可能带来的性能问题，请问怎么分解？\n\n#     讲师回复：\n\n>     避免使用过长的原型链就可以，比如不使用过深的继承关系\n\n# Kerita：\n\n> 请问 Person.proto 是什么东西？\n\n#     讲师回复：\n\n>     Person.prototype.proto === Object.prototype； 其实可以简单地去控制台打印看看的\n\n# **6082：\n\n> 1.每一个构造函数都有一个prototype属性，指向函数的原型对象。并且当创建了一个构造函数后，其原型对象就会默认获得一个constructor属性，该属性解决了对象是由哪个构造函数创造出来的问题，即对象识别；2.每一个原型对象都有一个默认的constructor属性指向构造函数。除了constructor属性，还有__proto__指针；3.每一个对象都有一个__proto__属性，指向原型对象，也叫指针；4.构造函数的原型的原型是由Object生成的。即Foo.prototype.proto.constructor===Object 或者等价于Foo.prototype.proto===Object.prototype；5.原型链的终点是null,null不再有__proto__指针了。\n\n#     讲师回复：\n\n>     妙呀\n\n# **：\n\n> 1 都是对象，函数是一个不具体的对象，而对象是一个具体的对象，类似树与柳树的关系2 一个在函数上，一个在对象上3 继承依赖原型链，通过原型链来实现继承\n\n# **：\n\n> 1.javascript中除了基础类型外，都是对象，函数是特殊的对象2.所有对象都有__proto__属性，指向它的构造函数的原型对象，每个函数都有个prototype属性，即原型对象3.原型链某种程度上就可以看做继承的表现\n\n# **：\n\n> 你好，学了以后收货很多。现在还有两点疑问详情见下。1.你说只有函数才有prototype 那object. prototype 是咋回事？2.你打印的Lili的实例的那张图，我看到里面是有两个__proto__是怎么看出来__proto__等于prototype 的\n\n#     讲师回复：\n\n>     1. 这里 Object.prototype 指 Object 的原型对象，并不是指 Object 的属性噢\n\n 2. 可以在控制台打印判断下噢，lily.proto === Person.prototype\n\n# *：\n\n> 求教，proto 这个属性好像不是标准里面的吧？\n\n#     讲师回复：\n\n>     实际上，没有官方的方法用于直接访问一个对象的原型对象。在 JavaScript 语言标准中用 prototype 表示，然而大多数现代浏览器还是提供了 proto 的属性来包含对象的原型",normalizedContent:"javascript 在编程语言界是个异类，它和其他编程语言很不一样，javascript 可以在运行的时候动态地改变某个变量的类型。\n\n比如你永远也没法想到像istimeout这样一个变量可以存在多少种类型，除了布尔值true和false，它还可能是undefined、1和0、一个时间戳，甚至一个对象。\n\n又或者你的代码跑异常了，打开浏览器开始断点，发现infolist这个变量第一次被赋值的时候是个数组[{name: 'test1', value: '11'}, {name: 'test2', value: '22'}]，过了一会竟然变成了一个对象{test1:'11', test2: '22'}\n\n除了变量可以在运行时被赋值为任何类型以外，javascript 中也能实现继承，但它不像 java、c++、c# 这些编程语言一样基于类来实现继承，而是基于原型进行继承。\n\n这是因为 javascript 中有个特殊的存在：对象。每个对象还都拥有一个原型对象，并可以从中继承方法和属性。\n\n提到对象和原型，你曾经是否有过这些疑惑：\n\n 1. javascript 的函数怎么也是个对象？\n\n 2. __proto__和prototype到底是啥关系？\n\n 3. javascript 中对象是怎么实现继承的？\n\n 4. javascript 是怎么访问对象的方法和属性的？\n\n下面我们一起结合问题，来探讨下 javascript 对象和继承。\n\n\n原型对象和对象是什么关系\n\n在 javascript 中，对象由一组或多组的属性和值组成：\n\n{\n  key1: value1,\n  key2: value2,\n  key3: value3,\n}\n\n\n在 javascript 中，对象的用途很是广泛，因为它的值既可以是原始类型（number、string、boolean、null、undefined、bigint和symbol），还可以是对象和函数。\n\n不管是对象，还是函数和数组，它们都是object的实例，也就是说在 javascript 中，除了原始类型以外，其余都是对象。\n\n这也就解答了疑惑 1：javascript 的函数怎么也是个对象？\n\n在 javascript 中，函数也是一种特殊的对象，它同样拥有属性和值。所有的函数会有一个特别的属性prototype，该属性的值是一个对象，这个对象便是我们常说的“原型对象”。\n\n我们可以在控制台打印一下这个属性：\n\nfunction person(name) {\n  this.name = name;\n}\nconsole.log(person.prototype);\n\n\n打印结果显示为：\n\n\n\n可以看到，该原型对象有两个属性：constructor和__proto__。\n\n到这里，我们仿佛看到疑惑 “2：__proto__和prototype到底是啥关系？”的答案要出现了。在 javascript 中，__proto__属性指向对象的原型对象，对于函数来说，它的原型对象便是prototype。函数的原型对象prototype有以下特点：\n\n * 默认情况下，所有函数的原型对象（prototype）都拥有constructor属性，该属性指向与之关联的构造函数，在这里构造函数便是person函数；\n\n * person函数的原型对象（prototype）同样拥有自己的原型对象，用__proto__属性表示。前面说过，函数是object的实例，因此person.prototype的原型对象为object.prototype。\n\n我们可以用这样一张图来描述prototype、__proto__和constructor三个属性的关系：\n\n\n\n从这个图中，我们可以找到这样的关系：\n\n * 在 javascript 中，__proto__属性指向对象的原型对象；\n\n * 对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象。\n\n这是否就是疑惑 2 的完整答案呢？并不全是，在 javascript 中还可以通过prototype和__proto__实现继承。\n\n\n使用 prototype 和 proto 实现继承\n\n前面我们说过，对象之所以使用广泛，是因为对象的属性值可以为任意类型。因此，属性的值同样可以为另外一个对象，这意味着 javascript 可以这么做：通过将对象 a 的__proto__属性赋值为对象 b，即a.__proto__ = b，此时使用a.__proto__便可以访问 b 的属性和方法。\n\n这样，javascript 可以在两个对象之间创建一个关联，使得一个对象可以访问另一个对象的属性和方法，从而实现了继承，此时疑惑 “3. javascript 中对象是怎么实现继承的？”解答完毕。\n\n那么，javascript 又是怎样使用prototype和__proto__实现继承的呢？\n\n继续以person为例，当我们使用new person()创建对象时，javascript 就会创建构造函数person的实例，比如这里我们创建了一个叫“lily”的person：\n\nvar lily = new person(\"lily\");\n\n\n上述这段代码在运行时，javascript 引擎通过将person的原型对象prototype赋值给实例对象lily的__proto__属性，实现了lily对person的继承，即执行了以下代码：\n\n// 实际上 javascript 引擎执行了以下代码\nvar lily = {};\nlily.__proto__ = person.prototype;\nperson.call(lily, \"lily\");\n\n\n我们来打印一下lily实例：\n\n\n\n可以看到，lily作为person的实例对象，它的__proto__指向了person的原型对象，即person.prototype。\n\n这时，我们再补充下上图中的关系：\n\n\n\n从这幅图中，我们可以清晰地看到构造函数和constructor属性、原型对象（prototype）和__proto__、实例对象之间的关系，这是很多初学者容易搞混的。根据这张图，我们可以得到以下的关系：\n\n 1. 每个函数的原型对象（person.prototype）都拥有constructor属性，指向该原型对象的构造函数（person）；\n\n 2. 使用构造函数（new person()）可以创建对象，创建的对象称为实例对象（lily）；\n\n 3. 实例对象通过将__proto__属性指向构造函数的原型对象（person.prototype），实现了该原型对象的继承。\n\n那么现在，关于疑惑 2 中__proto__和prototype的关系，我们可以得到这样的答案：\n\n * 每个对象都有__proto__属性来标识自己所继承的原型对象，但只有函数才有prototype属性；\n\n * 对于函数来说，每个函数都有一个prototype属性，该属性为该函数的原型对象；\n\n * 通过将实例对象的__proto__属性赋值为其构造函数的原型对象prototype，javascript 可以使用构造函数创建对象的方式，来实现继承。\n\n现在我们知道，一个对象可通过__proto__访问原型对象上的属性和方法，而该原型同样也可通过__proto__访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链。这里我用红色的线将lily实例的原型链标了出来。\n\n\n\n下面一起来进行疑惑 4 “javascript 是怎么访问对象的方法和属性的？”的解答：在 javascript 中，是通过遍历原型链的方式，来访问对象的方法和属性。\n\n\n通过原型链访问对象的方法和属性\n\n当 javascript 试图访问一个对象的属性时，会基于原型链进行查找。查找的过程是这样的：\n\n * 首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃告警）；\n\n * javascript 中的所有对象都来自object，object.prototype.__proto__ === null。null没有原型，并作为这个原型链中的最后一个环节；\n\n * javascript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为undefined。\n\n我们可以通过一个具体的例子，来表示基于原型链的对象属性的访问过程，在该例子中我们构建了一条对象的原型链，并进行属性值的访问：\n\n// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：\nvar o = {a: 1, b: 2};\n// o 的原型 o.__proto__有属性 b 和 c：\no.__proto__ = {b: 3, c: 4};\n// 最后, o.__proto__.__proto__ 是 null.\n// 这就是原型链的末尾，即 null，\n// 根据定义，null 没有__proto__.\n// 综上，整个原型链如下:\n{a:1, b:2} ---\x3e {b:3, c:4} ---\x3e null\n// 当我们在获取属性值的时候，就会触发原型链的查找：\nconsole.log(o.a); // o.a => 1\nconsole.log(o.b); // o.b => 2\nconsole.log(o.c); // o.c => o.__proto__.c => 4\nconsole.log(o.d); // o.c => o.__proto__.d => o.__proto__.__proto__ == null => undefined\n\n\n可以看到，当我们对对象进行属性值的获取时，会触发该对象的原型链查找过程。\n\n既然 javascript 中会通过遍历原型链来访问对象的属性，那么我们可以通过原型链的方式进行继承。\n\n也就是说，可以通过原型链去访问原型对象上的属性和方法，我们不需要在创建对象的时候给该对象重新赋值/添加方法。比如，我们调用lily.tostring()时，javascript 引擎会进行以下操作：\n\n 1. 先检查lily对象是否具有可用的tostring()方法；\n\n 2. 如果没有，则``检查lily的原型对象（person.prototype）是否具有可用的tostring()方法；\n\n 3. 如果也没有，则检查person()构造函数的prototype属性所指向的对象的原型对象（即object.prototype）是否具有可用的tostring()方法，于是该方法被调用。\n\n由于通过原型链进行属性的查找，需要层层遍历各个原型对象，此时可能会带来性能问题：\n\n * 当试图访问不存在的属性时，会遍历整个原型链；\n\n * 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。\n\n因此，我们在设计对象的时候，需要注意代码中原型链的长度。当原型链过长时，可以选择进行分解，来避免可能带来的性能问题。\n\n除了通过原型链的方式实现 javascript 继承，javascript 中实现继承的方式还包括经典继承(盗用构造函数)、组合继承、原型式继承、寄生式继承，等等。\n\n * 原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有；\n\n * 经典继承方式可以实现实例属性私有，但要求类型只能通过构造函数来定义；\n\n * 组合继承融合原型链继承和构造函数的优点，它的实现如下：\n\nfunction parent(name) {\n  // 私有属性，不共享\n  this.name = name;\n}\n\n\n// 需要复用、共享的方法定义在父类原型上\nparent.prototype.speak = function() {\nconsole.log(\"hello\");\n};\n\n\nfunction child(name) {\nparent.call(this, name);\n}\n\n\n// 继承方法\nchild.prototype = new parent();\n\n\n\n\n组合继承模式通过将共享属性定义在父类原型上、将私有属性通过构造函数赋值的方式，实现了按需共享对象和方法，是 javascript 中最常用的继承模式。\n\n虽然在继承的实现方式上有很多种，但实际上都离不开原型对象和原型链的内容，因此掌握__proto__和prototype、对象的继承等这些知识，是我们实现各种继承方式的前提。\n\n\n小结\n\n关于 javascript 的原型和继承，常常会在我们面试题中出现。随着 es6/es7 等新语法糖的出现，我们在日常开发中可能更倾向于使用class/extends等语法来编写代码，原型继承等概念逐渐变淡。\n\n但不管语法糖怎么先进，javascript 的设计在本质上依然没有变化，依然是基于原型来实现继承的。如果不了解这些内容，可能在我们遇到一些超出自己认知范围的内容时，很容易束手无策。\n\n现在，本文开始的四个疑惑我都在文中进行解答了，现在该轮到你了：\n\n 1. javascript 的函数和对象是怎样的关系？\n\n 2. __proto__和prototype都表示原型对象，它们有什么区别呢？\n\n 3. javascript 中对象的继承和原型链是什么关系？\n\n把你的想法写在留言区~\n\n----------------------------------------\n\n\n# 精选评论\n\n# better：\n\n> 老师讲的好棒👍🏻1. 函数是一种特殊的对象，在对象内部属性拥有仅供 javascript引擎读取的 call 属性的对象称为函数，使用 typeof 检测时会被识别为 function 。2. proto 可以称作指针指向 prototype ，后者实质上也是对象。3. 可以将 proto 比作链，prototype 比作节点，以 null 为顶点链接起来形成原型链，当访问标识符时，实例没有则会去原型链上查找，找到则返回结果，直到顶端 null 没找到则返回 undefined。\n\n#     编辑回复：\n\n>     你也好棒！\n\n# **2951：\n\n> 1、function instanceof object === true;2、只有函数才有prototype 只有对象才有__proto__;3、一个对象的__proto__指向了另一个对象， 另一个对象的__proto__又指向了其他对象，举例let a = {name : \"a\"}let b = {age: 12}let c={}c.proto = bb.proto = a此时 c继承了a 和 b b继承了 a，同时他们的继承关系组成了一条原型链\n\n#     讲师回复：\n\n>     没毛病！\n\n# *聪：\n\n> 对于构造函数，原型对象等概念不清晰的同学可以看看我的csdn上的博客（看完一定懂）：《帮你彻底搞懂js中的prototype、__proto__与constructor（图解）》，没错，原创：码飞_cc，就是我啦~~\n\n# **雄：\n\n> 被删老师你好，我对于”函数的 prototype 属性指向它的原型对象“这句话有不同的看法；在此之前你说每个对象的 __proto__ 指向它的原型对象，我是比较赞成的，所以对于函数，它的原型对象也应该是由 __proto__ 指向的。那么函数的 prototype 要怎么理解的，它应该指向函数的实例对象的原型对象；对于一个函数，它的原型对象应该是 fn.proto = function.prototype , 也就是对于内置的构造函数 function 的 prototype 指向它的实例对象 fn 的原型对象；以上是我结合老师讲解后，觉得有一丢丢矛盾的地方，进行了一点点自己的理解，不知道是否有偏差，希望老师能点评一下，万分感谢\n\n#     讲师回复：\n\n>     文中应该没有说 prototype 属性指向它的原型对象？prototype 属性可以理解为就是函数的原型对象。 function.prototype 在实例化之前就存在了，而 fn.proto = function.prototype 是在实例化过程中，将实例的 proto 属性指向 function.prototype 从而构成原型链。函数本身、以及函数的实例，这两者需要区分清楚~ 因此，你说的“对于内置的构造函数 function 的 prototype 指向它的实例对象 fn 的原型对象”，个人认为这样可能更加准确：“fn 这个实例，它的 proto 指向它的构造函数的原型对象，即 function.prototype”。\n\n# **怿：\n\n> person.proto === lily.proto ?\n\n#     讲师回复：\n\n>     lily.proto === person.prototype； person.prototype.proto === object.prototype；\n\n# *聪：\n\n>  1. javascript中的函数也是一种对象。除了七种基本类型值，其他的所有都是对象，这就是js中所谓的万物皆对象。2.__ptoto__属性是对象独有的，prototype属性是函数所独有的，因为函数也是一种对象，所以函数既有__proto__属性，也具有prototype属性，这点需要细细品味！3.对象的继承是依靠原型链来实现的，通过原型链，我们才可以使用其他对象上的属性或方法。\n\n# **远：\n\n> 其实 proto 属性是 chrome 自己搞出来的，没有被标准化，并且最新的 chrome 浏览器已经弃用这个属性了，改为 prototype 表示私有属性。标准中有专门用来访问对象原型的方法啊，就是 object.getprototypeof()，标准提供了 get/setprototypeof 这两个方法用来操作对象的原型，应该避免使用 proto 属性。继承一个对象的话，也是推荐 object.create 方法，避免使用 proto 属性。\n\n# *山：\n\n> 当原型链过长时，可以选择进行分解，来避免可能带来的性能问题，请问怎么分解？\n\n#     讲师回复：\n\n>     避免使用过长的原型链就可以，比如不使用过深的继承关系\n\n# kerita：\n\n> 请问 person.proto 是什么东西？\n\n#     讲师回复：\n\n>     person.prototype.proto === object.prototype； 其实可以简单地去控制台打印看看的\n\n# **6082：\n\n> 1.每一个构造函数都有一个prototype属性，指向函数的原型对象。并且当创建了一个构造函数后，其原型对象就会默认获得一个constructor属性，该属性解决了对象是由哪个构造函数创造出来的问题，即对象识别；2.每一个原型对象都有一个默认的constructor属性指向构造函数。除了constructor属性，还有__proto__指针；3.每一个对象都有一个__proto__属性，指向原型对象，也叫指针；4.构造函数的原型的原型是由object生成的。即foo.prototype.proto.constructor===object 或者等价于foo.prototype.proto===object.prototype；5.原型链的终点是null,null不再有__proto__指针了。\n\n#     讲师回复：\n\n>     妙呀\n\n# **：\n\n> 1 都是对象，函数是一个不具体的对象，而对象是一个具体的对象，类似树与柳树的关系2 一个在函数上，一个在对象上3 继承依赖原型链，通过原型链来实现继承\n\n# **：\n\n> 1.javascript中除了基础类型外，都是对象，函数是特殊的对象2.所有对象都有__proto__属性，指向它的构造函数的原型对象，每个函数都有个prototype属性，即原型对象3.原型链某种程度上就可以看做继承的表现\n\n# **：\n\n> 你好，学了以后收货很多。现在还有两点疑问详情见下。1.你说只有函数才有prototype 那object. prototype 是咋回事？2.你打印的lili的实例的那张图，我看到里面是有两个__proto__是怎么看出来__proto__等于prototype 的\n\n#     讲师回复：\n\n>     1. 这里 object.prototype 指 object 的原型对象，并不是指 object 的属性噢\n\n 2. 可以在控制台打印判断下噢，lily.proto === person.prototype\n\n# *：\n\n> 求教，proto 这个属性好像不是标准里面的吧？\n\n#     讲师回复：\n\n>     实际上，没有官方的方法用于直接访问一个对象的原型对象。在 javascript 语言标准中用 prototype 表示，然而大多数现代浏览器还是提供了 proto 的属性来包含对象的原型",charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"JavaScript 引擎如何执行 JavaScript 代码？",frontmatter:{title:"JavaScript 引擎如何执行 JavaScript 代码？",date:"2022-04-14T22:48:01.000Z",permalink:"/pages/13ef6c/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/04.JavaScript%20%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%20JavaScript%20%E4%BB%A3%E7%A0%81.html",relativePath:"01.前端/01.前端开发笔记/04.JavaScript 引擎如何执行 JavaScript 代码.md",key:"v-7fd3f54a",path:"/pages/13ef6c/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:7627}],headersStr:"精选评论",content:'JavaScript 在运行过程中与其他语言有所不一样，如果你不理解 JavaScript 的词法环境、执行上下文等内容，很容易会在开发过程中埋下“莫名奇妙”的 Bug，比如this指向和预期不一致、某个变量不知道为什么被改了，等等。所以今天我就跟大家聊一聊 JavaScript 代码的运行过程。\n\n大家都知道，JavaScript 代码是需要在 JavaScript 引擎中运行的。我们在说到 JavaScript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。这些概念看起来都差不多，却好像又不大容易区分清楚，它们分别都在描述什么呢？\n\n这些词语都是与 JavaScript 引擎执行代码的过程有关，为了搞清楚这些概念之间的区别，我们可以回顾下 JavaScript 代码运行过程中的各个阶段。\n\n\nJavaScript 代码运行的各个阶段\n\nJavaScript 是弱类型语言，在运行时才能确定变量类型。即使是如今流行的 TypeScript，也只是增加了编译时（编译成 JavaScript）的类型检测（对于编译器相信大家都有所了解，代码编译过程中编译器会进行词法分析、语法分析、语义分析、生成 AST 等处理）。\n\n同样，JavaScript 引擎在执行 JavaScript 代码时，也会从上到下进行词法分析、语法分析、语义分析等处理，并在代码解析完成后生成 AST（抽象语法树），最终根据 AST 生成 CPU 可以执行的机器码并执行。\n\n这个过程，我们后面统一描述为语法分析阶段。除了语法分析阶段，JavaScript 引擎在执行代码时还会进行其他的处理。以 V8 引擎为例，在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。\n\n 1. 语法分析阶段。 该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。\n\n 2. 编译阶段。 该阶段会进行执行上下文（Execution Context）的创建，包括创建变量对象、建立作用域链、确定 this 的指向等。每进入一个不同的运行环境时，V8 引擎都会创建一个新的执行上下文。\n\n 3. 执行阶段。 将编译阶段中创建的执行上下文压入调用栈，并成为正在运行的执行上下文，代码执行结束后，将其弹出调用栈。\n\n其中，语法分析阶段属于编译器通用内容，就不再赘述。前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。\n\n> 关于调用栈的内容我们会在下一讲详细讲解，目前我们只需要知道 JavaScript 在运行过程中会产生一个调用栈，调用栈遵循 LIFO（先进后出，后进先出）原则即可。\n\n今天，我们重点介绍编译阶段，而编译阶段的核心便是执行上下文的创建。\n\n\n执行上下文的创建\n\n执行上下文的创建离不开 JavaScript 的运行环境，JavaScript 运行环境包括全局环境、函数环境和eval，其中全局环境和函数环境的创建过程如下：\n\n 1. 第一次载入 JavaScript 代码时，首先会创建一个全局环境。全局环境位于最外层，直到应用程序退出后（例如关闭浏览器和网页）才会被销毁。\n\n 2. 每个函数都有自己的运行环境，当函数被调用时，则会进入该函数的运行环境。当该环境中的代码被全部执行完毕后，该环境会被销毁。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。\n\n在不同的运行环境中，变量和函数可访问的其他数据范围不同，环境的行为（比如创建和销毁）也有所区别。而每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括：\n\n * 建立作用域链（Scope Chain）；\n\n * 创建变量对象（Variable Object，简称 VO）；\n\n * 确定 this 的指向。\n\n由于建立作用域链过程中会涉及变量对象的概念，因此我们先来看看变量对象的创建，再看建立作用域链和确定 this 的指向。\n\n创建变量对象\n\n什么是变量对象呢？每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。\n\n而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。\n\n了解了什么是变量对象之后，我们来看下创建变量对象的过程。创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。\n\n * 对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。\n\n * 对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。\n\n上述变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。\n\n或许你会感到疑惑，JavaScript 是怎么支持块级作用域的呢？这就涉及作用域的概念。\n\n在各类编程语言中，作用域分为静态作用域和动态作用域。JavaScript 采用的是词法作用域（Lexical Scoping），也就是静态作用域。词法作用域中的变量，在编译过程中会产生一个确定的作用域。\n\n到这里，或许你对会词法作用域、作用域、执行上下文、词法环境之间的关系依然感到混乱，没关系，我这就来给你梳理下。\n\n刚刚说到，词法作用域中的变量，在编译过程中会产生一个确定的作用域，这个作用域即当前的执行上下文，在 ES5 后我们使用词法环境（Lexical Environment）替代作用域来描述该执行上下文。因此，词法环境可理解为我们常说的作用域，同样也指当前的执行上下文（注意，是当前的执行上下文）。\n\n在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：\n\n * 变量环境用来记录var/function等变量声明；\n\n * 词法环境是用来记录let/const/class等变量声明。\n\n也就是说，创建变量过程中会进行函数提升和变量提升，JavaScript 会通过词法环境来记录函数和变量声明。通过使用两个词法环境（而不是一个）分别记录不同的变量声明内容，JavaScript 实现了支持块级作用域的同时，不影响原有的变量声明和函数声明。\n\n这就是创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境，那词法环境是由什么组成的呢？下面我结合作用域链的建立过程一起来进行分析。\n\n建立作用域链\n\n作用域链，顾名思义，就是将各个作用域通过某种方式连接在一起。\n\n前面说过，作用域就是词法环境，而词法环境由两个成员组成。\n\n * 环境记录（Environment Record）：用于记录自身词法环境中的变量对象。\n\n * 外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。\n\n通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。\n\n那么，这个外部词法环境引用又是怎样指向外层呢？我们来看看 JavaScript 中是如何通过外部词法环境引用来创建作用域的。\n\n为了方便描述，我们将 JavaScript 代码运行过程分为定义期和执行期，前面提到的编译阶段则属于定义期。\n\n来看一个例子，我们定义了全局函数foo，并在该函数中定义了函数bar：\n\nfunction foo() {\n  console.dir(bar);\n  var a = 1;\n  function bar() {\n    a = 2;\n  }\n}\nconsole.dir(foo);\nfoo();\n\n\n前面我们说到，JavaScript 使用的是静态作用域，因此函数的作用域在定义期已经决定了。在上面的例子中，全局函数foo创建了一个foo的[[scope]]属性，包含了全局[[scope]]：\n\nfoo[[scope]] = [globalContext];\n\n\n而当我们执行foo()时，也会分别进入foo函数的定义期和执行期。\n\n在foo函数的定义期时，函数bar的[[scope]]将会包含全局[[scope]]和foo的[[scope]]：\n\nbar[[scope]] = [fooContext, globalContext];\n\n\n运行上述代码，我们可以在控制台看到符合预期的输出：\n\n\n\n可以看到：\n\n * foo的[[scope]]属性包含了全局[[scope]]\n\n * bar的[[scope]]将会包含全局[[scope]]和foo的[[scope]]\n\n也就是说，JavaScript 会通过外部词法环境引用来创建变量对象的一个作用域链，从而保证对执行环境有权访问的变量和函数的有序访问。除了创建作用域链之外，在这个过程中还会对创建的变量对象做一些处理。\n\n前面我们说过，编译阶段会进行变量对象（VO）的创建，该过程会进行函数声明和变量声明，这时候变量的值被初始化为 undefined。在代码进入执行阶段之后，JavaScript 会对变量进行赋值，此时变量对象会转为活动对象（Active Object，简称 AO），转换后的活动对象才可被访问，这就是 VO -> AO 的过程。\n\n为了更好地理解这个过程，我们来看个例子，我们在foo函数中定义了变量b、函数c和函数表达式变量d：\n\nfunction foo(a) {\n  var b = 2;\n  function c() {}\n  var d = function() {};\n}\n​\nfoo(1);\n\n\n在执行foo(1)时，首先进入定义期，此时：\n\n * 参数变量a的值为1\n\n * 变量b和d初始化为undefined\n\n * 函数c创建函数并初始化\n\nAO = {\n  arguments: {\n    0: 1,\n    length: 1\n  },\n  a: 1,\n  b: undefined,\n  c: reference to function c(){},\n  d: undefined\n}\n\n\n前面我们也有提到，进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：\n\nAO = {\n   arguments: {\n    0: 1,\n    length: 1\n  },\n  a: 1,\n  b: 2,\n  c: reference to function c(){},\n  d: reference to FunctionExpression "d"\n}\n\n\n这就是 VO -> AO 过程。\n\n * 在定义期（编译阶段）：该对象值仍为undefined，且处于不可访问的状态。\n\n * 进入执行期（执行阶段）：VO 被激活，其中变量属性会进行赋值。\n\n实际上在执行的时候，除了 VO 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象，因此 AO 和 VO 的关系可以用以下关系来表达：\n\nAO = VO + function parameters + arguments\n\n\n现在，我们知道作用域链是在进入代码的执行阶段时，通过外部词法环境引用来创建的。总结如下：\n\n * 在编译阶段，JavaScript 在创建执行上下文的时候会先创建变量对象（VO）；\n\n * 在执行阶段，变量对象（VO）被激活为活动对象（ AO），函数内部的变量对象通过外部词法环境的引用创建作用域链。\n\n虽然 JavaScript 代码的运行过程可以分为语法分析阶段、编译阶段和执行阶段，但由于在 JavaScript 引擎中是通过调用栈的方式来执行 JavaScript 代码的（下一讲会介绍），因此并不存在“整个 JavaScript 运行过程只会在某个阶段中”这一说法，比如上面例子中bar函数的编译阶段，其实是在foo函数的执行阶段中。\n\n一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。\n\n我们已经知道，通过作用域链，我们可以在函数内部可以直接读取外部以及全局变量，但外部环境是无法访问内部函数里的变量。比如下面的例子中，foo函数中定义了变量a：\n\nfunction foo() {\n  var a = 1;\n}\nfoo();\nconsole.log(a); // undefined\n\n\n我们在全局环境下无法访问函数foo中的变量a，这是因为全局函数的作用域链里，不含有函数foo内的作用域。\n\n如果我们想要访问内部函数的变量，可以通过函数foo中的函数bar返回变量a，并将函数bar返回，这样我们在全局环境中也可以通过调用函数foo返回的函数bar，来访问变量a：\n\nfunction foo() {\n  var a = 1;\n  function bar() {\n    return a;\n  }\n  return bar;\n}\nvar b = foo();\nconsole.log(b()); // 1\n\n\n前面我们说到，当函数执行结束之后，执行期上下文将被销毁，其中包括作用域链和激活对象。那么，在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？\n\n这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 JavaScript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。\n\n闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：\n\n * 用于从外部读取其他函数内部变量的函数；\n\n * 可以使用闭包来模拟私有方法；\n\n * 让这些变量的值始终保持在内存中。\n\n需要注意的是，我们在使用闭包的时候，需要及时清理不再使用到的变量，否则可能导致内存泄漏问题。\n\n相信大家现在已经掌握了作用域链的建立过程，那么作用域链的用途想必大家也已经了解，比如在函数执行过程中变量的解析：\n\n * 从当前词法环境开始，沿着作用域链逐级向外层寻找环境记录，直到找到同名变量为止；\n\n * 找到后不再继续遍历，找不到就报错。\n\n下面我们继续来看，执行上下文的创建过程中还会做的一件事：确定this的指向。\n\n确定 this 的指向\n\n在 JavaScript 中，this指向执行当前代码对象的所有者，可简单理解为this指向最后调用当前代码的那个对象。相信大家都很熟悉this，因此这里我就进行结论性的简单总结。\n\n根据 JavaScript 中函数的调用方式不同，this的指向分为以下情况。\n\n\n\n * 在全局环境中，this指向全局对象（在浏览器中为window）\n\n * 在函数内部，this的值取决于函数被调用的方式\n   \n   * 函数作为对象的方法被调用，this指向调用这个方法的对象\n   \n   * 函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象\n   \n   * 在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中\n\n * 在箭头函数中，this指向它被创建时的环境\n\n * 使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象\n\n可以看到，this在不同的情况下会有不同的指向，在 ES6 箭头函数还没出现之前，为了能正确获取某个运行环境下this对象，我们常常会使用var that = this;、var self = this;这样的代码将变量分配给this，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。\n\n到这里，围绕 JavaScript 的编译阶段和执行阶段中执行上下文创建相关的内容已经介绍完毕。\n\n\n小结\n\n今天我主要介绍了 JavaScript 代码的运行过程，该过程分为语法分析阶段、编译阶段、执行阶段三个阶段。\n\n在编译阶段，JavaScript会进行执行上下文的创建，包括：\n\n * 创建变量对象，进行变量声明和函数声明，此时会产生变量提升和函数提升；\n\n * 通过添加对外部词法环境的引用，建立作用域链，通过作用域链可以访问外部的变量对象；\n\n * 确定 this 的指向。\n\n在执行阶段，变量对象（VO）会被激活为活动对象（AO），变量会进行赋值，此时活动对象才可被访问。在执行结束之后，作用域链和活动对象均被销毁，使用闭包可使活动对象依然被保留在内存中。这就是 JavaScript 代码的运行过程。\n\n我们前面也说过，下面这段代码中bar函数的编译阶段是在foo函数的执行阶段中 ：\n\nfunction foo() {\n  console.dir(bar);\n  var a = 1;\n  function bar() {\n    a = 2;\n  }\n}\nconsole.dir(foo);\nfoo();\n\n\n你能说出整段代码的运行过程分别是怎样的，变量对象 AO/VO、作用域链、this 指向在各个阶段中又会怎样表现呢？可以把你的想法写在留言区。\n\n其实，JavaScript 的运行过程和 EventLoop 结合可以有更好的理解，关于 EventLoop 我会在下一讲进行介绍，你也可以在学习之后再来结合本讲内容进行总结。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **2951：\n\n> 首先将全局执行上下文栈window压入执行栈中，全局执行上下文中， foo是函数声明，被提升，函数声明提升要优先于变量提升，此时全局执行上下文栈中，只包含一个foo函数声明，同时将全局作用域绑定在foo的作用域链上，执行foo函数时，又为foo新创建一个执行上下文栈，并压入执行栈中，此时执行权由全局window，交到了foo函数上，进行编译阶段的工作，将变量a提升，bar函数声明提升，此时foo的执行上下文栈中，a是undefined， bar是一个函数声明，bar的作用域包含全局作用域和foo的作用域，执行阶段， a 赋值为1， 此时a变量对象变为了活动对象，this指向window。foo函数执行完毕，将foo从执行栈中弹出，执行权又交给window。\n\n# *雨：\n\n> 这一节开始吃力了，有的名词以前没听过\n\n#     编辑回复：\n\n>     哪些名词呢？可以具体说下，小编和讲师也可以针对性的帮你喔！\n\n# *浩：\n\n> 再学基础知识。\n\n# **宇：\n\n> vo里面有a b变量，a可以通过闭包被外界访问，b没有，当前作用域执行完后，整个vo都被保留，还是只保留a这块内存？\n\n#     讲师回复：\n\n>     当函数执行结束之后，执行期上下文将被销毁，其中包括作用域链和激活对象。对于闭包的场景来说，函数执行结束后，执行上下文的作用域链会被销毁，但它的激活对象仍然会被保留在内测中，这里是整个激活对象都会被保存。 因为闭包会保留锁包含函数的作用域，所以会比其他函数更占用内存。\n\n# **4391洪育煌：\n\n> 老师介绍的创建作用域链是在执行阶段出现的，那上文中创建执行上下文不是在编译阶段吗？执行上下文包含了创建作用域链不是矛盾了吗\n\n#     讲师回复：\n\n>     文中有说，虽然 JavaScript 代码的运行过程可以分为语法分析阶段、编译阶段和执行阶段，但由于在 JavaScript 引擎中是通过调用栈的方式来执行 JavaScript 代码的（下一讲会介绍），因此并不存在“整个 JavaScript 运行过程只会在某个阶段中”这一说法，比如上面例子中 bar 函数的编译阶段，其实是在 foo 函数的执行阶段中。\n\n# **泳：\n\n> "创建变量对象将会创建arguments对象（仅函数环境下）","除了 VO 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象"。老师您好！arguments对象在编译阶段就创建了，VO=AO也就意味着在执行阶段，为什么在执行阶段又会添加一次arguments对象?\n\n#     讲师回复：\n\n>     在创建变量的时候，arguments 对象只是形参，进入代码的执行阶段时，真实的参数才会被传进来，最终代码的执行是以真实的传参为准的。\n\n# *军：\n\n> 问一个问题呀，箭头函数内的执行上下文啥样的，没有arguments对象了吧，另外this应该指向定义箭头函数所在的执行上下文this吧\n\n#     讲师回复：\n\n>     箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super 或 new.target。因此，箭头函数的 this 指向它被创建时的环境。\n\n# *晶：\n\n> 有点点疑问1.编译器分析和v8引擎执行是两部分吗?词法分析、语法分析、语义分析、生成 AST会执行两遍吗？2.变量提升是在编译阶段的创建变量对象过程中吗？不是预解析阶段吗？还是说创建变量对象的过程就是预解析的过程\n\n#     讲师回复：\n\n>     1. 对于 JavaScript 这样的解释型脚本语言来说，都需要支持编译和解析的环境来运行脚本，对于 JavaScript 来说这就是 JavaScript 引擎，而 v8 引擎便是 JavaScript 引擎的一种。\n\n 2. 变量提升发生在代码执行之前，可理解为在创建变量对象的过程中或者是创建变量之后，它们都在语法分析/AST后到执行代码之前的这个过程中进行的，这个过程也常常被称作预编译/预解析。\n\n# *王：\n\n> 老师这里好像写错了:而当我们执行foo()时，也会分别进入foo函数的定义期和执行期。在foo函数的定义期时，函数bar的scope将会包含全局scope和foo的scope.第二个和第三个foo好像要改为bar\n\n#     讲师回复：\n\n>     代码运行会先进入定义期，再进入执行期，这里描述应该是没有问题的\n\n# **杰：\n\n> js权威指南写的作用域链是在定义的时候创建的，您写的是在执行期间，是否存在冲突？\n\n#     讲师回复：\n\n>     是在定义期哦\n\n# **4391洪育煌：\n\n> 变量和函数提升问题：上文中说函数提升优先级更高，如果变量名和函数名重复了，覆盖问题可以详细说一下吗\n\n#     讲师回复：\n\n>     比如 var a = 1; function a(){} 这段代码执行时，定义期中创建函数 a 并初始化；进入执行期之后，会执行赋值语句进行赋值，因此 a 的值为 1。\n\n# **泳：\n\n> “因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。”请问这一句话怎么理解？我知道变量对象在创建时，当函数名和变量名相同时，函数名优先级大会覆盖变量名。预期外被覆盖和本该被销毁的变量没有被销毁的情况，麻烦您能举个具体的例子吗？想象不出场景\n\n#     讲师回复：\n\n>     变量覆盖比如： var a = 1; function b() { console.log(a); a = 2; console.log(a); } b(); console.log(a);\n\n本该被销毁的变量没有被销毁比如： function a(){ for (var i = 0; i < 7; i++) { } console.log(i); } a()\n\n# *杰：\n\n> 根据最新的ECMA规范，变量环境只包含var定义的了， 函数声明已经归词法环境了\n\n# **龙：\n\n> 老师函数名存在哪里？ class词法环境能详细讲一下吗？\n\n#     讲师回复：\n\n>     在 ES6 中，环境记录可以分为声明式环境记录、对象环境记录和全局环境记录中，函数环境记录则是声明式环境记录的子类，而 class 也同样存在声明式环境记录中。如果感兴趣可以查阅一下 ES6 文档：https://tc39.es/ecma262/#sec-executable-code-and-execution-contexts\n\n# *刚：\n\n> 在写VO到AO的例子中，写了两个AO对象，是否第一个应该是VO对象呢\n\n#     讲师回复：\n\n>     是的，为了方便理解这是同一个对象，因此都使用了 AO 来描述',normalizedContent:'javascript 在运行过程中与其他语言有所不一样，如果你不理解 javascript 的词法环境、执行上下文等内容，很容易会在开发过程中埋下“莫名奇妙”的 bug，比如this指向和预期不一致、某个变量不知道为什么被改了，等等。所以今天我就跟大家聊一聊 javascript 代码的运行过程。\n\n大家都知道，javascript 代码是需要在 javascript 引擎中运行的。我们在说到 javascript 运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。这些概念看起来都差不多，却好像又不大容易区分清楚，它们分别都在描述什么呢？\n\n这些词语都是与 javascript 引擎执行代码的过程有关，为了搞清楚这些概念之间的区别，我们可以回顾下 javascript 代码运行过程中的各个阶段。\n\n\njavascript 代码运行的各个阶段\n\njavascript 是弱类型语言，在运行时才能确定变量类型。即使是如今流行的 typescript，也只是增加了编译时（编译成 javascript）的类型检测（对于编译器相信大家都有所了解，代码编译过程中编译器会进行词法分析、语法分析、语义分析、生成 ast 等处理）。\n\n同样，javascript 引擎在执行 javascript 代码时，也会从上到下进行词法分析、语法分析、语义分析等处理，并在代码解析完成后生成 ast（抽象语法树），最终根据 ast 生成 cpu 可以执行的机器码并执行。\n\n这个过程，我们后面统一描述为语法分析阶段。除了语法分析阶段，javascript 引擎在执行代码时还会进行其他的处理。以 v8 引擎为例，在 v8 引擎中 javascript 代码的运行过程主要分成三个阶段。\n\n 1. 语法分析阶段。 该阶段会对代码进行语法分析，检查是否有语法错误（syntaxerror），如果发现语法错误，会在控制台抛出异常并终止执行。\n\n 2. 编译阶段。 该阶段会进行执行上下文（execution context）的创建，包括创建变量对象、建立作用域链、确定 this 的指向等。每进入一个不同的运行环境时，v8 引擎都会创建一个新的执行上下文。\n\n 3. 执行阶段。 将编译阶段中创建的执行上下文压入调用栈，并成为正在运行的执行上下文，代码执行结束后，将其弹出调用栈。\n\n其中，语法分析阶段属于编译器通用内容，就不再赘述。前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。\n\n> 关于调用栈的内容我们会在下一讲详细讲解，目前我们只需要知道 javascript 在运行过程中会产生一个调用栈，调用栈遵循 lifo（先进后出，后进先出）原则即可。\n\n今天，我们重点介绍编译阶段，而编译阶段的核心便是执行上下文的创建。\n\n\n执行上下文的创建\n\n执行上下文的创建离不开 javascript 的运行环境，javascript 运行环境包括全局环境、函数环境和eval，其中全局环境和函数环境的创建过程如下：\n\n 1. 第一次载入 javascript 代码时，首先会创建一个全局环境。全局环境位于最外层，直到应用程序退出后（例如关闭浏览器和网页）才会被销毁。\n\n 2. 每个函数都有自己的运行环境，当函数被调用时，则会进入该函数的运行环境。当该环境中的代码被全部执行完毕后，该环境会被销毁。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。\n\n在不同的运行环境中，变量和函数可访问的其他数据范围不同，环境的行为（比如创建和销毁）也有所区别。而每进入一个不同的运行环境时，javascript 都会创建一个新的执行上下文，该过程包括：\n\n * 建立作用域链（scope chain）；\n\n * 创建变量对象（variable object，简称 vo）；\n\n * 确定 this 的指向。\n\n由于建立作用域链过程中会涉及变量对象的概念，因此我们先来看看变量对象的创建，再看建立作用域链和确定 this 的指向。\n\n创建变量对象\n\n什么是变量对象呢？每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。\n\n而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 node 中全局环境的变量对象则是global对象。\n\n了解了什么是变量对象之后，我们来看下创建变量对象的过程。创建变量对象将会创建arguments对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。\n\n * 对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。\n\n * 对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。\n\n上述变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 es6 中引入了let和const关键字，从而使 javascript 也拥有了块级作用域。\n\n或许你会感到疑惑，javascript 是怎么支持块级作用域的呢？这就涉及作用域的概念。\n\n在各类编程语言中，作用域分为静态作用域和动态作用域。javascript 采用的是词法作用域（lexical scoping），也就是静态作用域。词法作用域中的变量，在编译过程中会产生一个确定的作用域。\n\n到这里，或许你对会词法作用域、作用域、执行上下文、词法环境之间的关系依然感到混乱，没关系，我这就来给你梳理下。\n\n刚刚说到，词法作用域中的变量，在编译过程中会产生一个确定的作用域，这个作用域即当前的执行上下文，在 es5 后我们使用词法环境（lexical environment）替代作用域来描述该执行上下文。因此，词法环境可理解为我们常说的作用域，同样也指当前的执行上下文（注意，是当前的执行上下文）。\n\n在 javascript 中，词法环境又分为词法环境（lexical environment）和变量环境（variable environment）两种，其中：\n\n * 变量环境用来记录var/function等变量声明；\n\n * 词法环境是用来记录let/const/class等变量声明。\n\n也就是说，创建变量过程中会进行函数提升和变量提升，javascript 会通过词法环境来记录函数和变量声明。通过使用两个词法环境（而不是一个）分别记录不同的变量声明内容，javascript 实现了支持块级作用域的同时，不影响原有的变量声明和函数声明。\n\n这就是创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境，那词法环境是由什么组成的呢？下面我结合作用域链的建立过程一起来进行分析。\n\n建立作用域链\n\n作用域链，顾名思义，就是将各个作用域通过某种方式连接在一起。\n\n前面说过，作用域就是词法环境，而词法环境由两个成员组成。\n\n * 环境记录（environment record）：用于记录自身词法环境中的变量对象。\n\n * 外部词法环境引用（outer lexical environment）：记录外层词法环境的引用。\n\n通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。\n\n那么，这个外部词法环境引用又是怎样指向外层呢？我们来看看 javascript 中是如何通过外部词法环境引用来创建作用域的。\n\n为了方便描述，我们将 javascript 代码运行过程分为定义期和执行期，前面提到的编译阶段则属于定义期。\n\n来看一个例子，我们定义了全局函数foo，并在该函数中定义了函数bar：\n\nfunction foo() {\n  console.dir(bar);\n  var a = 1;\n  function bar() {\n    a = 2;\n  }\n}\nconsole.dir(foo);\nfoo();\n\n\n前面我们说到，javascript 使用的是静态作用域，因此函数的作用域在定义期已经决定了。在上面的例子中，全局函数foo创建了一个foo的[[scope]]属性，包含了全局[[scope]]：\n\nfoo[[scope]] = [globalcontext];\n\n\n而当我们执行foo()时，也会分别进入foo函数的定义期和执行期。\n\n在foo函数的定义期时，函数bar的[[scope]]将会包含全局[[scope]]和foo的[[scope]]：\n\nbar[[scope]] = [foocontext, globalcontext];\n\n\n运行上述代码，我们可以在控制台看到符合预期的输出：\n\n\n\n可以看到：\n\n * foo的[[scope]]属性包含了全局[[scope]]\n\n * bar的[[scope]]将会包含全局[[scope]]和foo的[[scope]]\n\n也就是说，javascript 会通过外部词法环境引用来创建变量对象的一个作用域链，从而保证对执行环境有权访问的变量和函数的有序访问。除了创建作用域链之外，在这个过程中还会对创建的变量对象做一些处理。\n\n前面我们说过，编译阶段会进行变量对象（vo）的创建，该过程会进行函数声明和变量声明，这时候变量的值被初始化为 undefined。在代码进入执行阶段之后，javascript 会对变量进行赋值，此时变量对象会转为活动对象（active object，简称 ao），转换后的活动对象才可被访问，这就是 vo -> ao 的过程。\n\n为了更好地理解这个过程，我们来看个例子，我们在foo函数中定义了变量b、函数c和函数表达式变量d：\n\nfunction foo(a) {\n  var b = 2;\n  function c() {}\n  var d = function() {};\n}\n​\nfoo(1);\n\n\n在执行foo(1)时，首先进入定义期，此时：\n\n * 参数变量a的值为1\n\n * 变量b和d初始化为undefined\n\n * 函数c创建函数并初始化\n\nao = {\n  arguments: {\n    0: 1,\n    length: 1\n  },\n  a: 1,\n  b: undefined,\n  c: reference to function c(){},\n  d: undefined\n}\n\n\n前面我们也有提到，进入执行期之后，会执行赋值语句进行赋值，此时变量b和d会被赋值为 2 和函数表达式：\n\nao = {\n   arguments: {\n    0: 1,\n    length: 1\n  },\n  a: 1,\n  b: 2,\n  c: reference to function c(){},\n  d: reference to functionexpression "d"\n}\n\n\n这就是 vo -> ao 过程。\n\n * 在定义期（编译阶段）：该对象值仍为undefined，且处于不可访问的状态。\n\n * 进入执行期（执行阶段）：vo 被激活，其中变量属性会进行赋值。\n\n实际上在执行的时候，除了 vo 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象，因此 ao 和 vo 的关系可以用以下关系来表达：\n\nao = vo + function parameters + arguments\n\n\n现在，我们知道作用域链是在进入代码的执行阶段时，通过外部词法环境引用来创建的。总结如下：\n\n * 在编译阶段，javascript 在创建执行上下文的时候会先创建变量对象（vo）；\n\n * 在执行阶段，变量对象（vo）被激活为活动对象（ ao），函数内部的变量对象通过外部词法环境的引用创建作用域链。\n\n虽然 javascript 代码的运行过程可以分为语法分析阶段、编译阶段和执行阶段，但由于在 javascript 引擎中是通过调用栈的方式来执行 javascript 代码的（下一讲会介绍），因此并不存在“整个 javascript 运行过程只会在某个阶段中”这一说法，比如上面例子中bar函数的编译阶段，其实是在foo函数的执行阶段中。\n\n一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。\n\n我们已经知道，通过作用域链，我们可以在函数内部可以直接读取外部以及全局变量，但外部环境是无法访问内部函数里的变量。比如下面的例子中，foo函数中定义了变量a：\n\nfunction foo() {\n  var a = 1;\n}\nfoo();\nconsole.log(a); // undefined\n\n\n我们在全局环境下无法访问函数foo中的变量a，这是因为全局函数的作用域链里，不含有函数foo内的作用域。\n\n如果我们想要访问内部函数的变量，可以通过函数foo中的函数bar返回变量a，并将函数bar返回，这样我们在全局环境中也可以通过调用函数foo返回的函数bar，来访问变量a：\n\nfunction foo() {\n  var a = 1;\n  function bar() {\n    return a;\n  }\n  return bar;\n}\nvar b = foo();\nconsole.log(b()); // 1\n\n\n前面我们说到，当函数执行结束之后，执行期上下文将被销毁，其中包括作用域链和激活对象。那么，在这个例子中，当b()执行时，foo函数上下文包括作用域都已经被销毁了，为什么foo作用域下的a依然可以被访问到呢？\n\n这是因为bar函数引用了foo函数变量对象中的值，此时即使创建bar函数的foo函数执行上下文被销毁了，但它的变量对象依然会保留在 javascript 内存中，bar函数依然可以通过bar函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。\n\n闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：\n\n * 用于从外部读取其他函数内部变量的函数；\n\n * 可以使用闭包来模拟私有方法；\n\n * 让这些变量的值始终保持在内存中。\n\n需要注意的是，我们在使用闭包的时候，需要及时清理不再使用到的变量，否则可能导致内存泄漏问题。\n\n相信大家现在已经掌握了作用域链的建立过程，那么作用域链的用途想必大家也已经了解，比如在函数执行过程中变量的解析：\n\n * 从当前词法环境开始，沿着作用域链逐级向外层寻找环境记录，直到找到同名变量为止；\n\n * 找到后不再继续遍历，找不到就报错。\n\n下面我们继续来看，执行上下文的创建过程中还会做的一件事：确定this的指向。\n\n确定 this 的指向\n\n在 javascript 中，this指向执行当前代码对象的所有者，可简单理解为this指向最后调用当前代码的那个对象。相信大家都很熟悉this，因此这里我就进行结论性的简单总结。\n\n根据 javascript 中函数的调用方式不同，this的指向分为以下情况。\n\n\n\n * 在全局环境中，this指向全局对象（在浏览器中为window）\n\n * 在函数内部，this的值取决于函数被调用的方式\n   \n   * 函数作为对象的方法被调用，this指向调用这个方法的对象\n   \n   * 函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象\n   \n   * 在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中\n\n * 在箭头函数中，this指向它被创建时的环境\n\n * 使用apply、call、bind等方式调用：根据 api 不同，可切换函数执行的上下文环境，即this绑定的对象\n\n可以看到，this在不同的情况下会有不同的指向，在 es6 箭头函数还没出现之前，为了能正确获取某个运行环境下this对象，我们常常会使用var that = this;、var self = this;这样的代码将变量分配给this，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。\n\n到这里，围绕 javascript 的编译阶段和执行阶段中执行上下文创建相关的内容已经介绍完毕。\n\n\n小结\n\n今天我主要介绍了 javascript 代码的运行过程，该过程分为语法分析阶段、编译阶段、执行阶段三个阶段。\n\n在编译阶段，javascript会进行执行上下文的创建，包括：\n\n * 创建变量对象，进行变量声明和函数声明，此时会产生变量提升和函数提升；\n\n * 通过添加对外部词法环境的引用，建立作用域链，通过作用域链可以访问外部的变量对象；\n\n * 确定 this 的指向。\n\n在执行阶段，变量对象（vo）会被激活为活动对象（ao），变量会进行赋值，此时活动对象才可被访问。在执行结束之后，作用域链和活动对象均被销毁，使用闭包可使活动对象依然被保留在内存中。这就是 javascript 代码的运行过程。\n\n我们前面也说过，下面这段代码中bar函数的编译阶段是在foo函数的执行阶段中 ：\n\nfunction foo() {\n  console.dir(bar);\n  var a = 1;\n  function bar() {\n    a = 2;\n  }\n}\nconsole.dir(foo);\nfoo();\n\n\n你能说出整段代码的运行过程分别是怎样的，变量对象 ao/vo、作用域链、this 指向在各个阶段中又会怎样表现呢？可以把你的想法写在留言区。\n\n其实，javascript 的运行过程和 eventloop 结合可以有更好的理解，关于 eventloop 我会在下一讲进行介绍，你也可以在学习之后再来结合本讲内容进行总结。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **2951：\n\n> 首先将全局执行上下文栈window压入执行栈中，全局执行上下文中， foo是函数声明，被提升，函数声明提升要优先于变量提升，此时全局执行上下文栈中，只包含一个foo函数声明，同时将全局作用域绑定在foo的作用域链上，执行foo函数时，又为foo新创建一个执行上下文栈，并压入执行栈中，此时执行权由全局window，交到了foo函数上，进行编译阶段的工作，将变量a提升，bar函数声明提升，此时foo的执行上下文栈中，a是undefined， bar是一个函数声明，bar的作用域包含全局作用域和foo的作用域，执行阶段， a 赋值为1， 此时a变量对象变为了活动对象，this指向window。foo函数执行完毕，将foo从执行栈中弹出，执行权又交给window。\n\n# *雨：\n\n> 这一节开始吃力了，有的名词以前没听过\n\n#     编辑回复：\n\n>     哪些名词呢？可以具体说下，小编和讲师也可以针对性的帮你喔！\n\n# *浩：\n\n> 再学基础知识。\n\n# **宇：\n\n> vo里面有a b变量，a可以通过闭包被外界访问，b没有，当前作用域执行完后，整个vo都被保留，还是只保留a这块内存？\n\n#     讲师回复：\n\n>     当函数执行结束之后，执行期上下文将被销毁，其中包括作用域链和激活对象。对于闭包的场景来说，函数执行结束后，执行上下文的作用域链会被销毁，但它的激活对象仍然会被保留在内测中，这里是整个激活对象都会被保存。 因为闭包会保留锁包含函数的作用域，所以会比其他函数更占用内存。\n\n# **4391洪育煌：\n\n> 老师介绍的创建作用域链是在执行阶段出现的，那上文中创建执行上下文不是在编译阶段吗？执行上下文包含了创建作用域链不是矛盾了吗\n\n#     讲师回复：\n\n>     文中有说，虽然 javascript 代码的运行过程可以分为语法分析阶段、编译阶段和执行阶段，但由于在 javascript 引擎中是通过调用栈的方式来执行 javascript 代码的（下一讲会介绍），因此并不存在“整个 javascript 运行过程只会在某个阶段中”这一说法，比如上面例子中 bar 函数的编译阶段，其实是在 foo 函数的执行阶段中。\n\n# **泳：\n\n> "创建变量对象将会创建arguments对象（仅函数环境下）","除了 vo 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象"。老师您好！arguments对象在编译阶段就创建了，vo=ao也就意味着在执行阶段，为什么在执行阶段又会添加一次arguments对象?\n\n#     讲师回复：\n\n>     在创建变量的时候，arguments 对象只是形参，进入代码的执行阶段时，真实的参数才会被传进来，最终代码的执行是以真实的传参为准的。\n\n# *军：\n\n> 问一个问题呀，箭头函数内的执行上下文啥样的，没有arguments对象了吧，另外this应该指向定义箭头函数所在的执行上下文this吧\n\n#     讲师回复：\n\n>     箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super 或 new.target。因此，箭头函数的 this 指向它被创建时的环境。\n\n# *晶：\n\n> 有点点疑问1.编译器分析和v8引擎执行是两部分吗?词法分析、语法分析、语义分析、生成 ast会执行两遍吗？2.变量提升是在编译阶段的创建变量对象过程中吗？不是预解析阶段吗？还是说创建变量对象的过程就是预解析的过程\n\n#     讲师回复：\n\n>     1. 对于 javascript 这样的解释型脚本语言来说，都需要支持编译和解析的环境来运行脚本，对于 javascript 来说这就是 javascript 引擎，而 v8 引擎便是 javascript 引擎的一种。\n\n 2. 变量提升发生在代码执行之前，可理解为在创建变量对象的过程中或者是创建变量之后，它们都在语法分析/ast后到执行代码之前的这个过程中进行的，这个过程也常常被称作预编译/预解析。\n\n# *王：\n\n> 老师这里好像写错了:而当我们执行foo()时，也会分别进入foo函数的定义期和执行期。在foo函数的定义期时，函数bar的scope将会包含全局scope和foo的scope.第二个和第三个foo好像要改为bar\n\n#     讲师回复：\n\n>     代码运行会先进入定义期，再进入执行期，这里描述应该是没有问题的\n\n# **杰：\n\n> js权威指南写的作用域链是在定义的时候创建的，您写的是在执行期间，是否存在冲突？\n\n#     讲师回复：\n\n>     是在定义期哦\n\n# **4391洪育煌：\n\n> 变量和函数提升问题：上文中说函数提升优先级更高，如果变量名和函数名重复了，覆盖问题可以详细说一下吗\n\n#     讲师回复：\n\n>     比如 var a = 1; function a(){} 这段代码执行时，定义期中创建函数 a 并初始化；进入执行期之后，会执行赋值语句进行赋值，因此 a 的值为 1。\n\n# **泳：\n\n> “因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。”请问这一句话怎么理解？我知道变量对象在创建时，当函数名和变量名相同时，函数名优先级大会覆盖变量名。预期外被覆盖和本该被销毁的变量没有被销毁的情况，麻烦您能举个具体的例子吗？想象不出场景\n\n#     讲师回复：\n\n>     变量覆盖比如： var a = 1; function b() { console.log(a); a = 2; console.log(a); } b(); console.log(a);\n\n本该被销毁的变量没有被销毁比如： function a(){ for (var i = 0; i < 7; i++) { } console.log(i); } a()\n\n# *杰：\n\n> 根据最新的ecma规范，变量环境只包含var定义的了， 函数声明已经归词法环境了\n\n# **龙：\n\n> 老师函数名存在哪里？ class词法环境能详细讲一下吗？\n\n#     讲师回复：\n\n>     在 es6 中，环境记录可以分为声明式环境记录、对象环境记录和全局环境记录中，函数环境记录则是声明式环境记录的子类，而 class 也同样存在声明式环境记录中。如果感兴趣可以查阅一下 es6 文档：https://tc39.es/ecma262/#sec-executable-code-and-execution-contexts\n\n# *刚：\n\n> 在写vo到ao的例子中，写了两个ao对象，是否第一个应该是vo对象呢\n\n#     讲师回复：\n\n>     是的，为了方便理解这是同一个对象，因此都使用了 ao 来描述',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"单线程的 JavaScript 如何管理任务？",frontmatter:{title:"单线程的 JavaScript 如何管理任务？",date:"2022-04-14T22:48:01.000Z",permalink:"/pages/c3f2e0/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/05.%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html",relativePath:"01.前端/01.前端开发笔记/05.单线程的 JavaScript 如何管理任务.md",key:"v-e2342726",path:"/pages/c3f2e0/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:6241}],headersStr:"精选评论",content:'如果说 JavaScript 代码运行过程中的语法分析阶段、编译阶段和执行阶段属于微观层面的运行逻辑，那么今天我来介绍下宏观角度下的 JavaScript 运行过程，包括 JavaScript 的单线程设计、事件循环的并发模型设计。\n\n要怎么理解 JavaScript 是单线程这个概念呢？大概需要从浏览器来说起。\n\nJavaScript 最初被设计为浏览器脚本语言，主要用途包括对页面的操作、与浏览器的交互、与用户的交互、页面逻辑处理等。如果将 JavaScript 设计为多线程，那当多个线程同时对同一个 DOM 节点进行操作时，线程间的同步问题会变得很复杂。\n\n因此，为了避免复杂性，JavaScript 被设计为单线程。\n\n这样一个单线程的 JavaScript，意味着任务需要一个接一个地处理。如果有一个任务是等待用户输入，那在用户进行操作前，所有其他任务都处于等待状态，页面会进入假死状态，用户体验会很糟糕。\n\n那么，为了高效进行页面的交互和渲染处理，我们围绕着任务执行是否阻塞 JavaScript 主线程，将 JavaScript 中的任务分为同步任务和异步任务。\n\n\n同步任务与异步任务\n\n * 同步任务：在主线程上排队执行的任务，前一个任务完整地执行完成后，后一个任务才会被执行。\n\n * 异步任务：不会阻塞主线程，在其任务执行完成之后，会再根据一定的规则去执行相关的回调。\n\n我们先来看一下同步任务在浏览器中的是怎样执行的。\n\n同步任务与函数调用栈\n\n在 JavaScript 中，同步任务基本上可以认为是执行 JavaScript 代码。在上一讲内容中，我们提到 JavaScript 在执行过程中每进入一个不同的运行环境时，都会创建一个相应的执行上下文。那么，当我们执行一段 JavaScript 代码时，通常会创建多个执行上下文。\n\n而 JavaScript 解释器会以栈的方式管理这些执行上下文、以及函数之间的调用关系，形成函数调用栈（call stack）（调用栈可理解为一个存储函数调用的栈结构，遵循 FILO（先进后出）的原则）。\n\n我们来看一下 JavaScript 中代码执行的过程：\n\n 1. 首先进入全局环境，全局执行上下文被创建并添加进栈中；\n\n 2. 每调用一个函数，该函数执行上下文会被添加进调用栈，并开始执行；\n\n 3. 如果正在调用栈中执行的 A 函数还调用了 B 函数，那么 B 函数也将会被添加进调用栈；\n\n 4. 一旦 B 函数被调用，便会立即执行；\n\n 5. 当前函数执行完毕后，JavaScript 解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。\n\n由此可见，JavaScript 代码执行过程中，函数调用栈栈底永远是全局执行上下文，栈顶永远是当前执行上下文。\n\n在不考虑全局执行上下文时，我们可以理解为刚开始的时候调用栈是空的，每当有函数被调用，相应的执行上下文都会被添加到调用栈中。执行完函数中相关代码后，该执行上下文又会自动被调用栈移除，最后调用栈又回到了空的状态（同样不考虑全局执行上下文）。\n\n由于栈的容量是有限制的，所以当我们没有合理调用函数的时候，可能会导致爆栈异常，此时控制台便会抛出错误：\n\n\n\n这样的一个函数调用栈结构，可以理解为 JavaScript 中同步任务的执行环境，同步任务也可以理解为 JavaScript 代码片段的执行。\n\n同步任务的执行会阻塞主线程，也就是说，一个函数执行的时候不会被抢占，只有在它执行完毕之后，才会去执行任何其他的代码。这意味着如果我们一个任务执行的时间过长，浏览器就无法处理与用户的交互，例如点击或滚动。\n\n因此，我们还需要用到异步任务。\n\n异步任务与回调队列\n\n异步任务包括一些需要等待响应的任务，包括用户交互、HTTP 请求、定时器等。\n\n我们知道，I/O 类型的任务会有较长的等待时间，对于这类无法立刻得到结果的事件，可以使用异步任务的方式。这个过程中 JavaScript 线程就不用处于等待状态，CPU 也可以处理其他任务。\n\n异步任务需要提供回调函数，当异步任务有了运行结果之后，该任务则会被添加到回调队列中，主线程在适当的时候会从回调队列中取出相应的回调函数并执行。\n\n这里提到的回调队列又是什么呢？\n\n实际上，JavaScript 在运行的时候，除了函数调用栈之外，还包含了一个待处理的回调队列。在回调队列中的都是已经有了运行结果的异步任务，每一个异步任务都会关联着一个回调函数。\n\n回调队列则遵循 FIFO（先进先出）的原则，JavaScript 执行代码过程中，会进行以下的处理：\n\n * 运行时，会从最先进入队列的任务开始，处理队列中的任务；\n\n * 被处理的任务会被移出队列，该任务的运行结果会作为输入参数，并调用与之关联的函数，此时会产生一个函数调用栈；\n\n * 函数会一直处理到调用栈再次为空，然后 Event Loop 将会处理队列中的下一个任务。\n\n这里我们提到了 Event Loop，它主要是用来管理单线程的 JavaScript 中同步任务和异步任务的执行问题。\n\n\n单线程的 JavaScript 是如何管理任务的\n\n我们知道，单线程的设计会存在阻塞问题，为此 JavaScript 中任务被分为同步和异步任务。那么，同步任务和异步任务之间是按照什么顺序来执行的呢？\n\nJavaScript 有一个基于事件循环的并发模型，称为事件循环（Event Loop），它的设计解决了同步任务和异步任务的管理问题。\n\n根据 JavaScript 运行环境的不同，Event Loop 也会被分成浏览器的 Event Loop 和 Node.js 中的 Event Loop。\n\n浏览器的 Event Loop\n\n在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：\n\n * 用户交互事件产生的事件任务，比如输入操作；\n\n * 计时器产生的事件任务，比如setTimeout；\n\n * 异步请求产生的事件任务，比如 HTTP 请求。\n\nJavaScript 的运行过程，可以借用 Philip Roberts 演讲《Help, I\'m stuck in an event-loop》中经典的一张图来描述：\n\n\n\n如图，主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程。\n\n 1. JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。\n\n 2. 同步任务会被放在调用栈中，按照顺序等待主线程依次执行。\n\n 3. 主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。\n\n 4. 同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。\n\n 5. 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。\n\n 6. 调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。\n\n上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。\n\nEvent Loop 的设计会带来一些问题，比如setTimeout、setInterval的时间精确性。这两个方法会设置一个计时器，当计时器计时完成，需要执行回调函数，此时才把回调函数放入回调队列中。\n\n如果当回调函数放入队列时，假设队列中还有大量的回调函数在等待执行，此时就会造成任务执行时间不精确。\n\n要优化这个问题，可以使用系统时钟来补偿计时器的不准确性，从而提升精确度。举个例子，如果你的计时器会在回调时触发二次计时，可以在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的计时器时间。\n\n\nNode.js 中的 Event Loop\n\n除了浏览器，Node.js 中同样存在 Event Loop。由于 JavaScript 是单线程的，Event Loop 的设计使 Node.js 可以通过将操作转移到系统内核中，来执行非阻塞 I/O 操作。\n\nNode.js 中的事件循环执行过程为：\n\n 1. 当 Node.js 启动时将初始化事件循环，处理提供的输入脚本；\n\n 2. 提供的输入脚本可以进行异步 API 调用，然后开始处理事件循环；\n\n 3. 在事件循环的每次运行之间，Node.js 会检查它是否正在等待任何异步 I/O 或计时器，如果没有，则将其干净地关闭。\n\n与浏览器不一样，Node.js 中事件循环分成不同的阶段：\n\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤               |\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n\n\n\n由于事件循环阶段划分不一致，Node.js 和浏览器在对宏任务和微任务的处理上也不一样。\n\n\n宏任务和微任务\n\n事件循环中的异步回调队列有两种：宏任务（MacroTask）和微任务（MicroTask）队列。\n\n什么是宏任务和微任务呢？\n\n * 宏任务：包括 script 全部代码、setTimeout、setInterval、setImmediate（Node.js）、requestAnimationFrame（浏览器）、I/O 操作、UI 渲染（浏览器），这些代码执行便是宏任务。\n\n * 微任务：包括process.nextTick（Node.js）、Promise、MutationObserver，这些代码执行便是微任务。\n\n为什么要将异步任务分为宏任务和微任务呢？这是为了避免回调队列中等待执行的异步任务（宏任务）过多，导致某些异步任务（微任务）的等待时间过长。在每个宏任务执行完成之后，会先将微任务队列中的任务执行完毕，再执行下一个宏任务。\n\n因此，前面我们所说的回调队列可以理解为宏任务队列，同时还有另外一个任务队列为微任务队列。\n\n在浏览器的异步回调队列中，宏任务和微任务的执行过程如下：\n\n 1. 宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务。\n\n 2. 微任务队列中所有的任务都会被依次取出来执行，直到微任务队列为空。\n\n 3. 在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会执行 UI 渲染操作、更新界面。\n\n我们能看到，在浏览器中每个宏任务执行完成后，会执行微任务队列中的任务。而在 Node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。\n\n宏任务和微任务的执行顺序，常常会被用作面试题，比如下面这道考察Promise、setTimeout、async/await等 API 执行顺序的题目：\n\nconsole.log("script start");\n\n\nsetTimeout(() => {\n console.log("setTimeout");\n}, 1000);\n\n\nPromise.resolve()\n.then(function () {\n   console.log("promise1");\n})\n.then(function () {\n   console.log("promise2");\n});\n\n\nasync function errorFunc() {\n try {\n   await Promise.reject("error!!!");\n} catch (e) {\n   console.log("error caught"); // 微1-3\n}\n console.log("errorFunc");\n return Promise.resolve("errorFunc success");\n}\nerrorFunc().then((res) => console.log("errorFunc then res"));\n\n\nconsole.log("script end");\n\n\n你知道这道题的答案是什么吗？欢迎在留言区写下你的解题过程。\n\n\n小结\n\n今天我介绍了 JavaScript 的单线程设计，它的设计初衷是为了让用户获得更好的交互体验。同时，为了避免单线程的任务执行过程中发生阻塞，事件循环（Event Loop）机制便出现了。\n\n在浏览器和 Node.js 中，都存在单线程的 Event Loop 设计，它们之间的不一致主要表现为 Event Loop 阶段划分以及宏任务和微任务的处理。\n\n或许你会感到疑惑，除了应对面试以外，掌握 JavaScript 的事件循环、宏任务和微任务相关机制，对我们有什么用处呢？\n\n要知道，浏览器中在执行 JavaScript 代码的时候不会进行页面渲染，如果一项任务花费的时间太长，浏览器将无法执行其他任务（例如处理用户事件）。因此，当存在大量复杂的计算、或导致了死循环的编程错误时，甚至会使页面终止。\n\n我们可以更合理地利用这些机制来拆分任务，比如考虑将多次触发的数据变更通过微任务收集起来，再一起进行 UI 的更新和渲染，便可以降低浏览器渲染的频率，提升浏览器的性能，给到用户更好的体验。\n\n\n\n----------------------------------------\n\n\n# 精选评论\n\n# **洲：\n\n>  1. 脚本先执行同步代码, 宏任务, 顺序是 "script start", setTimeout, "script end", 由于 setTimeout 是异步任务, 所以程序不会等待它完成, 所以 setTimeout 的回调函数会被挂起, 在将来等待时间完成之后就会把它重新调入回调队列, 第一轮执行完成之后, 此时微任务有 Promise.resolve(), errorFunc(), 它们会被加入回调队列, 顺序是 Promise.resolve() = errorFunc()2. 此时主线程处于空闲状态, 需要从回调队列中提取任务, 队列是先进先出, 所以取出来的是 Promise.resolve(), 此时它就会进入调用栈, 接着主线程就从调用栈中取出它运行, 所以现在就会输出 promise, 与此同时, 产生了下一个微任务, 这个微任务接着也会被加入回调队列, 此时回调队列的顺序是 errorFunc() = Promise.resolve() 产生的微任务(PR)3. 接下来同理, errorFunc() 会被处理, 因为 await 会阻塞异步操作, 所以这个 await 后面的 Promise 不会去回调队列排队, 而是等待完成, 所以 "error caught" 就会被输出, 接着是一段同步代码, 所以就会输出 "errorFunc", 同理, 异步函数返回的 Promise 会被加入回调队列中排队, 此时回调队列是 PR = errorFunc 返回的回调4. 同理, 此时会执行 "promise 2", 接着就会执行 "errorFunc then res"5. 接着就是 setTimeout 的等待时间到了, 其回调函数加入回调队列, 执行 "setTimeout", 因为宏任务一次只执行一次, 然后是执行所有的微任务, 所有微任务执行完之后, 再执行下一次宏任务, 所以就算 setTimeout 计时时间为 0, 也是最后执行6. 最后的运行结果为 "script start", "script end", "promise 1", "error caught", "errorFunc", "promise 2", "errorFunc then res", "setTimeout"\n\n#     讲师回复：\n\n>     分析得很好，还可以考虑下在 Node.js 环境下，是否会是同样的结果呢~~\n\n# *振：\n\n> node11以后的事件循环，执行结果与浏览器是一样的吧\n\n#     讲师回复：\n\n>     没错~在 node 11 之后的版本，的确是浏览器保持一致了~ 以 timers 阶段为例，在 node 11 版本之前，只有全部执行了 timers 阶段队列的全部任务才执行微任务队列；在 node 11 版本开始，timer 阶段的 setTimeout、setInterval 被修改为，执行一个任务就立刻执行微任务队列，与浏览器趋同了~\n\n# *伟：\n\n> 感觉node那块的event loop 没有讲明白啊？有点懵\n\n#     讲师回复：\n\n>     在 Node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。 可以以文中的例子来试试看，在浏览器和 Node.js 环境中的执行结果有什么不一样（当然，Node.js 11 版本之后，两个结果已经一致了，可以参考下其他评论）\n\n# **新：\n\n> 宏观任务和微观任务的案例还是不太懂\n\n#     讲师回复：\n\n>     具体哪里不懂呢？能详细描述下吗？\n\n# **哈：\n\n> 系统时钟指的是屏幕的刷新频率吧\n\n#     讲师回复：\n\n>     指的是 Date.prototype.getTime()，可以手动计算每次定时器中回调执行的时间差，然后调整下一次定时器的时间，从而缓解多个定时器累加后导致的时间差距越来越大的问题\n\n# 856：\n\n> 老是 能解释下I/O 操作吗？\n\n#     讲师回复：\n\n>     I/O，即 input/output 输入输出操作。对网页来说，有用户的交互（点击、拖动等）、存储和 DB 的读取等等。这些操作都需要进行等待，比如等待用户的操作才会触发对应的事件，等待存储读写完成等。\n\n# *龙：\n\n> 有个问题，既然主线程执行完之后，先去宏任务取一个，执行之后，再清空微任务队列，那不是定时器先执行吗\n\n#     讲师回复：\n\n>     定时器有延时噢，会在延时完成后才将回调任务添加到队列\n\n# **东：\n\n> script全部代码是异步任务下的宏任务，那同步任务指javacript代码片段，script不就包括javascript片段了，这不懂\n\n#     讲师回复：\n\n>     这个问题有点没看明白。同步任务可任务是执行 JavaScript 代码片段这个没错，但是 JavaScript 代码在执行过程中会产生异步任务噢，比如 setTimeout，异步任务的回调可以理解为另外的 JavaScript 代码片段，会在异步任务队列等待主线程获取并执行，只不过异步任务队列也分为宏任务和微任务两种而已\n\n# *浩：\n\n> 注意了：浏览器环境下的EventLoop与Node.js环境下的EventLoop模型还是有不同的。',normalizedContent:'如果说 javascript 代码运行过程中的语法分析阶段、编译阶段和执行阶段属于微观层面的运行逻辑，那么今天我来介绍下宏观角度下的 javascript 运行过程，包括 javascript 的单线程设计、事件循环的并发模型设计。\n\n要怎么理解 javascript 是单线程这个概念呢？大概需要从浏览器来说起。\n\njavascript 最初被设计为浏览器脚本语言，主要用途包括对页面的操作、与浏览器的交互、与用户的交互、页面逻辑处理等。如果将 javascript 设计为多线程，那当多个线程同时对同一个 dom 节点进行操作时，线程间的同步问题会变得很复杂。\n\n因此，为了避免复杂性，javascript 被设计为单线程。\n\n这样一个单线程的 javascript，意味着任务需要一个接一个地处理。如果有一个任务是等待用户输入，那在用户进行操作前，所有其他任务都处于等待状态，页面会进入假死状态，用户体验会很糟糕。\n\n那么，为了高效进行页面的交互和渲染处理，我们围绕着任务执行是否阻塞 javascript 主线程，将 javascript 中的任务分为同步任务和异步任务。\n\n\n同步任务与异步任务\n\n * 同步任务：在主线程上排队执行的任务，前一个任务完整地执行完成后，后一个任务才会被执行。\n\n * 异步任务：不会阻塞主线程，在其任务执行完成之后，会再根据一定的规则去执行相关的回调。\n\n我们先来看一下同步任务在浏览器中的是怎样执行的。\n\n同步任务与函数调用栈\n\n在 javascript 中，同步任务基本上可以认为是执行 javascript 代码。在上一讲内容中，我们提到 javascript 在执行过程中每进入一个不同的运行环境时，都会创建一个相应的执行上下文。那么，当我们执行一段 javascript 代码时，通常会创建多个执行上下文。\n\n而 javascript 解释器会以栈的方式管理这些执行上下文、以及函数之间的调用关系，形成函数调用栈（call stack）（调用栈可理解为一个存储函数调用的栈结构，遵循 filo（先进后出）的原则）。\n\n我们来看一下 javascript 中代码执行的过程：\n\n 1. 首先进入全局环境，全局执行上下文被创建并添加进栈中；\n\n 2. 每调用一个函数，该函数执行上下文会被添加进调用栈，并开始执行；\n\n 3. 如果正在调用栈中执行的 a 函数还调用了 b 函数，那么 b 函数也将会被添加进调用栈；\n\n 4. 一旦 b 函数被调用，便会立即执行；\n\n 5. 当前函数执行完毕后，javascript 解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。\n\n由此可见，javascript 代码执行过程中，函数调用栈栈底永远是全局执行上下文，栈顶永远是当前执行上下文。\n\n在不考虑全局执行上下文时，我们可以理解为刚开始的时候调用栈是空的，每当有函数被调用，相应的执行上下文都会被添加到调用栈中。执行完函数中相关代码后，该执行上下文又会自动被调用栈移除，最后调用栈又回到了空的状态（同样不考虑全局执行上下文）。\n\n由于栈的容量是有限制的，所以当我们没有合理调用函数的时候，可能会导致爆栈异常，此时控制台便会抛出错误：\n\n\n\n这样的一个函数调用栈结构，可以理解为 javascript 中同步任务的执行环境，同步任务也可以理解为 javascript 代码片段的执行。\n\n同步任务的执行会阻塞主线程，也就是说，一个函数执行的时候不会被抢占，只有在它执行完毕之后，才会去执行任何其他的代码。这意味着如果我们一个任务执行的时间过长，浏览器就无法处理与用户的交互，例如点击或滚动。\n\n因此，我们还需要用到异步任务。\n\n异步任务与回调队列\n\n异步任务包括一些需要等待响应的任务，包括用户交互、http 请求、定时器等。\n\n我们知道，i/o 类型的任务会有较长的等待时间，对于这类无法立刻得到结果的事件，可以使用异步任务的方式。这个过程中 javascript 线程就不用处于等待状态，cpu 也可以处理其他任务。\n\n异步任务需要提供回调函数，当异步任务有了运行结果之后，该任务则会被添加到回调队列中，主线程在适当的时候会从回调队列中取出相应的回调函数并执行。\n\n这里提到的回调队列又是什么呢？\n\n实际上，javascript 在运行的时候，除了函数调用栈之外，还包含了一个待处理的回调队列。在回调队列中的都是已经有了运行结果的异步任务，每一个异步任务都会关联着一个回调函数。\n\n回调队列则遵循 fifo（先进先出）的原则，javascript 执行代码过程中，会进行以下的处理：\n\n * 运行时，会从最先进入队列的任务开始，处理队列中的任务；\n\n * 被处理的任务会被移出队列，该任务的运行结果会作为输入参数，并调用与之关联的函数，此时会产生一个函数调用栈；\n\n * 函数会一直处理到调用栈再次为空，然后 event loop 将会处理队列中的下一个任务。\n\n这里我们提到了 event loop，它主要是用来管理单线程的 javascript 中同步任务和异步任务的执行问题。\n\n\n单线程的 javascript 是如何管理任务的\n\n我们知道，单线程的设计会存在阻塞问题，为此 javascript 中任务被分为同步和异步任务。那么，同步任务和异步任务之间是按照什么顺序来执行的呢？\n\njavascript 有一个基于事件循环的并发模型，称为事件循环（event loop），它的设计解决了同步任务和异步任务的管理问题。\n\n根据 javascript 运行环境的不同，event loop 也会被分成浏览器的 event loop 和 node.js 中的 event loop。\n\n浏览器的 event loop\n\n在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：\n\n * 用户交互事件产生的事件任务，比如输入操作；\n\n * 计时器产生的事件任务，比如settimeout；\n\n * 异步请求产生的事件任务，比如 http 请求。\n\njavascript 的运行过程，可以借用 philip roberts 演讲《help, i\'m stuck in an event-loop》中经典的一张图来描述：\n\n\n\n如图，主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，event loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程。\n\n 1. javascript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。\n\n 2. 同步任务会被放在调用栈中，按照顺序等待主线程依次执行。\n\n 3. 主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。\n\n 4. 同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 api，此时会产生一些异步任务。\n\n 5. 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。\n\n 6. 调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。\n\n上述过程会不断重复，这就是 javascript 的运行机制，称为事件循环机制（event loop）。\n\nevent loop 的设计会带来一些问题，比如settimeout、setinterval的时间精确性。这两个方法会设置一个计时器，当计时器计时完成，需要执行回调函数，此时才把回调函数放入回调队列中。\n\n如果当回调函数放入队列时，假设队列中还有大量的回调函数在等待执行，此时就会造成任务执行时间不精确。\n\n要优化这个问题，可以使用系统时钟来补偿计时器的不准确性，从而提升精确度。举个例子，如果你的计时器会在回调时触发二次计时，可以在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的计时器时间。\n\n\nnode.js 中的 event loop\n\n除了浏览器，node.js 中同样存在 event loop。由于 javascript 是单线程的，event loop 的设计使 node.js 可以通过将操作转移到系统内核中，来执行非阻塞 i/o 操作。\n\nnode.js 中的事件循环执行过程为：\n\n 1. 当 node.js 启动时将初始化事件循环，处理提供的输入脚本；\n\n 2. 提供的输入脚本可以进行异步 api 调用，然后开始处理事件循环；\n\n 3. 在事件循环的每次运行之间，node.js 会检查它是否正在等待任何异步 i/o 或计时器，如果没有，则将其干净地关闭。\n\n与浏览器不一样，node.js 中事件循环分成不同的阶段：\n\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤               |\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n\n\n\n由于事件循环阶段划分不一致，node.js 和浏览器在对宏任务和微任务的处理上也不一样。\n\n\n宏任务和微任务\n\n事件循环中的异步回调队列有两种：宏任务（macrotask）和微任务（microtask）队列。\n\n什么是宏任务和微任务呢？\n\n * 宏任务：包括 script 全部代码、settimeout、setinterval、setimmediate（node.js）、requestanimationframe（浏览器）、i/o 操作、ui 渲染（浏览器），这些代码执行便是宏任务。\n\n * 微任务：包括process.nexttick（node.js）、promise、mutationobserver，这些代码执行便是微任务。\n\n为什么要将异步任务分为宏任务和微任务呢？这是为了避免回调队列中等待执行的异步任务（宏任务）过多，导致某些异步任务（微任务）的等待时间过长。在每个宏任务执行完成之后，会先将微任务队列中的任务执行完毕，再执行下一个宏任务。\n\n因此，前面我们所说的回调队列可以理解为宏任务队列，同时还有另外一个任务队列为微任务队列。\n\n在浏览器的异步回调队列中，宏任务和微任务的执行过程如下：\n\n 1. 宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务。\n\n 2. 微任务队列中所有的任务都会被依次取出来执行，直到微任务队列为空。\n\n 3. 在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会执行 ui 渲染操作、更新界面。\n\n我们能看到，在浏览器中每个宏任务执行完成后，会执行微任务队列中的任务。而在 node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。\n\n宏任务和微任务的执行顺序，常常会被用作面试题，比如下面这道考察promise、settimeout、async/await等 api 执行顺序的题目：\n\nconsole.log("script start");\n\n\nsettimeout(() => {\n console.log("settimeout");\n}, 1000);\n\n\npromise.resolve()\n.then(function () {\n   console.log("promise1");\n})\n.then(function () {\n   console.log("promise2");\n});\n\n\nasync function errorfunc() {\n try {\n   await promise.reject("error!!!");\n} catch (e) {\n   console.log("error caught"); // 微1-3\n}\n console.log("errorfunc");\n return promise.resolve("errorfunc success");\n}\nerrorfunc().then((res) => console.log("errorfunc then res"));\n\n\nconsole.log("script end");\n\n\n你知道这道题的答案是什么吗？欢迎在留言区写下你的解题过程。\n\n\n小结\n\n今天我介绍了 javascript 的单线程设计，它的设计初衷是为了让用户获得更好的交互体验。同时，为了避免单线程的任务执行过程中发生阻塞，事件循环（event loop）机制便出现了。\n\n在浏览器和 node.js 中，都存在单线程的 event loop 设计，它们之间的不一致主要表现为 event loop 阶段划分以及宏任务和微任务的处理。\n\n或许你会感到疑惑，除了应对面试以外，掌握 javascript 的事件循环、宏任务和微任务相关机制，对我们有什么用处呢？\n\n要知道，浏览器中在执行 javascript 代码的时候不会进行页面渲染，如果一项任务花费的时间太长，浏览器将无法执行其他任务（例如处理用户事件）。因此，当存在大量复杂的计算、或导致了死循环的编程错误时，甚至会使页面终止。\n\n我们可以更合理地利用这些机制来拆分任务，比如考虑将多次触发的数据变更通过微任务收集起来，再一起进行 ui 的更新和渲染，便可以降低浏览器渲染的频率，提升浏览器的性能，给到用户更好的体验。\n\n\n\n----------------------------------------\n\n\n# 精选评论\n\n# **洲：\n\n>  1. 脚本先执行同步代码, 宏任务, 顺序是 "script start", settimeout, "script end", 由于 settimeout 是异步任务, 所以程序不会等待它完成, 所以 settimeout 的回调函数会被挂起, 在将来等待时间完成之后就会把它重新调入回调队列, 第一轮执行完成之后, 此时微任务有 promise.resolve(), errorfunc(), 它们会被加入回调队列, 顺序是 promise.resolve() = errorfunc()2. 此时主线程处于空闲状态, 需要从回调队列中提取任务, 队列是先进先出, 所以取出来的是 promise.resolve(), 此时它就会进入调用栈, 接着主线程就从调用栈中取出它运行, 所以现在就会输出 promise, 与此同时, 产生了下一个微任务, 这个微任务接着也会被加入回调队列, 此时回调队列的顺序是 errorfunc() = promise.resolve() 产生的微任务(pr)3. 接下来同理, errorfunc() 会被处理, 因为 await 会阻塞异步操作, 所以这个 await 后面的 promise 不会去回调队列排队, 而是等待完成, 所以 "error caught" 就会被输出, 接着是一段同步代码, 所以就会输出 "errorfunc", 同理, 异步函数返回的 promise 会被加入回调队列中排队, 此时回调队列是 pr = errorfunc 返回的回调4. 同理, 此时会执行 "promise 2", 接着就会执行 "errorfunc then res"5. 接着就是 settimeout 的等待时间到了, 其回调函数加入回调队列, 执行 "settimeout", 因为宏任务一次只执行一次, 然后是执行所有的微任务, 所有微任务执行完之后, 再执行下一次宏任务, 所以就算 settimeout 计时时间为 0, 也是最后执行6. 最后的运行结果为 "script start", "script end", "promise 1", "error caught", "errorfunc", "promise 2", "errorfunc then res", "settimeout"\n\n#     讲师回复：\n\n>     分析得很好，还可以考虑下在 node.js 环境下，是否会是同样的结果呢~~\n\n# *振：\n\n> node11以后的事件循环，执行结果与浏览器是一样的吧\n\n#     讲师回复：\n\n>     没错~在 node 11 之后的版本，的确是浏览器保持一致了~ 以 timers 阶段为例，在 node 11 版本之前，只有全部执行了 timers 阶段队列的全部任务才执行微任务队列；在 node 11 版本开始，timer 阶段的 settimeout、setinterval 被修改为，执行一个任务就立刻执行微任务队列，与浏览器趋同了~\n\n# *伟：\n\n> 感觉node那块的event loop 没有讲明白啊？有点懵\n\n#     讲师回复：\n\n>     在 node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。 可以以文中的例子来试试看，在浏览器和 node.js 环境中的执行结果有什么不一样（当然，node.js 11 版本之后，两个结果已经一致了，可以参考下其他评论）\n\n# **新：\n\n> 宏观任务和微观任务的案例还是不太懂\n\n#     讲师回复：\n\n>     具体哪里不懂呢？能详细描述下吗？\n\n# **哈：\n\n> 系统时钟指的是屏幕的刷新频率吧\n\n#     讲师回复：\n\n>     指的是 date.prototype.gettime()，可以手动计算每次定时器中回调执行的时间差，然后调整下一次定时器的时间，从而缓解多个定时器累加后导致的时间差距越来越大的问题\n\n# 856：\n\n> 老是 能解释下i/o 操作吗？\n\n#     讲师回复：\n\n>     i/o，即 input/output 输入输出操作。对网页来说，有用户的交互（点击、拖动等）、存储和 db 的读取等等。这些操作都需要进行等待，比如等待用户的操作才会触发对应的事件，等待存储读写完成等。\n\n# *龙：\n\n> 有个问题，既然主线程执行完之后，先去宏任务取一个，执行之后，再清空微任务队列，那不是定时器先执行吗\n\n#     讲师回复：\n\n>     定时器有延时噢，会在延时完成后才将回调任务添加到队列\n\n# **东：\n\n> script全部代码是异步任务下的宏任务，那同步任务指javacript代码片段，script不就包括javascript片段了，这不懂\n\n#     讲师回复：\n\n>     这个问题有点没看明白。同步任务可任务是执行 javascript 代码片段这个没错，但是 javascript 代码在执行过程中会产生异步任务噢，比如 settimeout，异步任务的回调可以理解为另外的 javascript 代码片段，会在异步任务队列等待主线程获取并执行，只不过异步任务队列也分为宏任务和微任务两种而已\n\n# *浩：\n\n> 注意了：浏览器环境下的eventloop与node.js环境下的eventloop模型还是有不同的。',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"一个网络请求是怎么进行的？",frontmatter:{title:"一个网络请求是怎么进行的？",date:"2022-04-14T22:48:01.000Z",permalink:"/pages/6fddea/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/06.%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%9A%84.html",relativePath:"01.前端/01.前端开发笔记/06.一个网络请求是怎么进行的.md",key:"v-624c6ac9",path:"/pages/6fddea/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:6275}],headersStr:"精选评论",content:"从这一讲开始，我会介绍浏览器相关的内容，比如浏览器中的网络请求过程、HTTP 协议在浏览器中的应用、浏览器中页面的渲染过程，等等。\n\n我们知道，浏览器的主要功能是展示网页资源，包括向服务器发起请求、从服务器获取相关资源，并将网页显示在浏览器窗口中。\n\n当我们去面试的时候，常常会被问到一个问题：在浏览器里面输入 url，按下回车键，会发生什么？\n\n这个问题涉及浏览器中的运行机制和页面加载流程，并且这些内容也都穿插在我们日常开发中，包括前后端联调、对网页进行性能优化等。\n\n今天我会先跟你聊一聊浏览器中网络请求是怎么进行的，这样你对整个网页渲染会有个更好的认识。\n\n\n页面的请求过程\n\n当我们打开某个网站的页面，浏览器就会发起网络请求获取该页面的资源，我们也可以从控制台看到以下的请求信息：\n\n\n\n在 Network 面板里，我们能看到所有浏览器发起的网络请求，包括页面、图片、CSS 文件、XHR 请求等，还能看到请求的状态（200 成功、404 找不到、缓存、重定向等等）、耗时、请求头和内容、返回头和内容等。\n\n图中第一个就是网站页面的请求，返回<html>页面。\n\n接下来，浏览器会加载页面，同时页面中涉及的外部资源也会根据需要，在特定的时机触发请求下载，包括我们看到的 PNG 图片、JavaScript 文件（这里没有 CSS 样式，是因为样式被直出在<html>页面内容里了）。\n\n回到前面的问题，实际上当我们在浏览器输入网页地址，按下回车键后，浏览器的处理过程如下：\n\n 1. DNS 域名解析（此处涉及 DNS 的寻址过程），找到网页的存放服务器；\n\n 2. 浏览器与服务器建立 TCP 连接；\n\n 3. 浏览器发起 HTTP 请求；\n\n 4. 服务器响应 HTTP 请求，返回该页面的 HTML 内容；\n\n 5. 浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如 JavaScript、CSS、图片等，此处可能涉及 HTTP 缓存）；\n\n 6. 浏览器对页面进行渲染呈现给用户（此处涉及浏览器的渲染原理）。\n\nHTTP 缓存和浏览器渲染原理会分别在第 7 讲和第 8 讲中讲述，今天我们主要围绕 HTTP 请求相关展开。\n\n首先我们来看 DNS 解析过程。\n\nDNS 解析\n\nDNS 的全称是 Domain Name System，又称域名系统，它负责把www.qq.com这样的域名地址翻译成一个 IP（比如14.18.180.206），而客户端与服务器建立 TCP 连接需要通过 IP 通信。\n\n让客户端和服务器连接并不是靠域名进行，在网络中每个终端之间实现连接和通信是通过一个唯一的 IP 地址来完成。在建立 TCP 连接前，我们需要找到建立连接的服务器，DNS 的解析过程可以让用户通过域名找到存放文件的服务器。\n\nDNS 解析过程会进行递归查询，分别依次尝试从以下途径，按顺序地获取该域名对应的 IP 地址。\n\n * 浏览器缓存\n\n * 系统缓存（用户操作系统 Hosts 文件 DNS 缓存）\n\n * 路由器缓存\n\n * 互联网服务提供商 DNS 缓存（联通、移动、电信等互联网服务提供商的 DNS 缓存服务器）\n\n * 根域名服务器\n\n * 顶级域名服务器\n\n * 主域名服务器\n\nDNS 解析过程会根据上述步骤进行递归查询，如果当前步骤没查到，则自动跳转到到下一步骤通过下一个 DNS 服务器进行查找。如果最终依然没找到，浏览器便会将页面响应为打开失败。\n\n除此之外，我们在前后端联调过程中也常常需要配置 HOST，这个过程便是修改了浏览器缓存或是系统缓存。通过将特定域名指向我们自身的服务器 IP 地址，便可以实现通过域名访问本地环境、测试环境、预发布环境的服务器资源。\n\n那为什么需要配置域名 HOST，而不直接使用 IP 地址进行访问呢？这是因为浏览器的同源策略会导致跨域问题。\n\n同源策略要求，只有当请求的协议、域名和端口都相同的情况下，我们才可以访问当前页面的 Cookie/LocalStorage/IndexDB、获取和操作 DOM 节点，以及发送 Ajax 请求。通过同源策略的限制，可以避免恶意的攻击者盗取用户信息，从而可以保证用户信息的安全。\n\n对于非同源的请求，我们常常称为跨域请求，需要进行跨域处理。常见的跨域解决方案有这几种。\n\n * 使用document.domain + iframe：只有在主域相同的时候才能使用该方法。\n\n * 动态创建 script(JSONP)：通过指定回调函数以及函数的传参数据，让页面执行相应的脚本内容。\n\n * 使用location.hash + iframe：利用location.hash来进行传值。\n\n * 使用window.name + iframe：原理是window.name值在不同的页面（甚至不同域名）加载后依旧存在。\n\n * 使用window.postMessage()实现跨域通信。\n\n * 使用跨域资源共享 CORS（Cross-origin resource sharing）。\n\n * 使用 Websockets。\n\n其中，CORS 作为现在的主流解决方案，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制。实现 CORS 通信的关键是服务器，只要服务端实现了 CORS 接口，就可以进行跨源通信。\n\nDNS 解析完成后，浏览器获得了服务端的 IP 地址，接下来便可以向服务端发起 HTTP 请求。目前大多数 HTTP 请求都建立在 TCP 连接上，因此客户端和服务端会先建立起 TCP 连接。\n\nTCP 连接的建立\n\nTCP 连接的建立过程比较偏通信底层，在前端日常开发过程中不容易接触到。但有时候我们需要优化应用的加载耗时、请求耗时或是定位一些偏底层的问题（请求异常、HTTP 连接无法建立等），都会或多或少依赖这些偏底层的知识。\n\n另外，从面试的角度看，我们需要掌握 TCP/UDP 的区别、TCP 的三次握手和四次挥手内容。\n\n * TCP 协议提供可靠传输服务，UDP 协议则可以更快地进行通信；\n\n * 三次握手：指 TCP 连接的建立过程，该过程中客户端和服务端总共需要发送三个包，从而确认连接存在。\n\n * 四次挥手：指 TCP 连接的断开过程，该过程中需要客户端和服务端总共发送四个包以，从而确认连接关闭。\n\n当客户端和服务端建立起 TCP 连接之后，HTTP 服务器会监听客户端发起的请求，此时客户端会发起 HTTP 请求。\n\nHTTP 请求与 TCP 协议\n\n由客户端发起的 HTTP 请求，服务器收到后会进行回复，回复内容通常包括 HTTP 状态、响应消息等，更具体的会在下一讲 HTTP 协议中进行介绍。\n\n前面说过，目前大多数 HTTP 请求都是基于 TCP 协议。TCP 协议的目的是提供可靠的数据传输，它用来确保可靠传输的途径主要包括两个：\n\n 1. 乱序重建：通过对数据包编号来对其排序，从而使得另一端接收数据时，可以重新根据编号还原顺序。\n\n 2. 丢包重试：可通过发送方是否得到响应，来检测出丢失的数据并重传这些数据。\n\n通过以上方式，TCP 在传输过程中不会丢失或破坏任何数据，这也是即使出现网络故障也不会损坏文件下载的原因。\n\n因此，目前大多数 HTTP 连接基于 TCP 协议。不过，在 HTTP/3 中底层支撑是 QUIC 协议，该协议使用的是 UDP 协议。因为 UDP 协议丢弃了 TCP 协议中所有的错误检查内容，因此可以更快地进行通信，更常用于直播和在线游戏的应用。\n\n也就是说，HTTP/3 基于 UDP 协议实现了数据的快速传输，同时通过 QUIC 协议保证了数据的可靠传输，最终实现了又快又可靠的通信。\n\n除了以上的内容，其实我们还可以去了解关于 TCP/IP 协议的分层模型、IP 寻址过程，以及 IP 协议又是如何将数据包准确无误地传递这些内容，也需要关注 HTTP/2、HTTP/3、HTTPS 这些协议的设计变更了什么、又解决了什么。\n\n或许这些内容对于大多数前端开发来说，都很少会直接接触。但它就像乘法口诀在高考数学题中的角色，基本上所有题目中都会使用到，但我们很少会认为自己是因为掌握了乘法口诀才能顺利解答题目。\n\n同样的，我们对网络请求的认知也常常忽略了底层 TCP/IP 知识，基本上围绕着“前端发起了请求，后台就能收到”“请求没有按预期结果返回，要么是请求包内容有误，要么后台服务异常”这样的理解去进行处理。\n\n但如果某一天，我们的应用整体请求耗时突然变长，这个过程中前端和后台都没有时间上能关联的发布单，我们到底应该如何进行定位呢？如果我们对一个网络请求的完整流程不够了解，又怎么定位到底是哪个步骤出现问题了呢？甚至我们都不会想到，将 HTTP 切换到 HTTPS 也可能会影响到请求耗时。\n\n下面，我们就来看一下 HTTP 请求在前端开发过程中是如何进行编程实现的，这就不得不提到 Ajax 请求了。\n\n\nAjax 请求\n\nAjax 请求这个词会频繁出现在我们的工作对话内容中，但它并不是 JavaScript 的规范，而是 Jesse James Garrett 提出的新术语：Asynchronous JavaScript and XML，意思是用 JavaScript 执行异步网络请求。\n\n网络请求的发展\n\n对于浏览器来说，网络请求是用来从服务端获取需要的信息，然后解析协议和内容，来进行页面渲染或者是信息获取的过程。\n\n在很久以前，我们的网络请求除了静态资源（HTML/CSS/JavaScript 等）文件的获取，主要用于表单的提交。我们在完成表单内容的填写之后，点击提交按钮，接下来表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。\n\n除了页面跳转刷新会影响用户体验，在表单提交过程中，使用同步请求会阻塞进程。此时用户无法继续操作页面，导致页面呈现假死状态，使得用户体验变得糟糕。\n\n为了避免这种情况，我们开始使用异步请求 + 回调的方式，来进行请求处理，这就是 Ajax。\n\n随着时间发展，Ajax 的应用越来越广，如今使用 Ajax 已经是前端开发的基本操作。但 Ajax 是一种解决方案，在前端中的具体实现依赖使用XMLHttpRequest相关 API。页面开始支持局部更新、动态加载，甚至还有懒加载、首屏加载等等，都是以XMLHttpRequest为前提。\n\nXMLHttpRequest\n\nXMLHttpRequest让发送一个 HTTP 请求变得非常容易，我们只需要简单的创建一个请求对象实例，并对它进行操作：\n\nvar request = new XMLHttpRequest(); // 新建XMLHttpRequest对象\n\n\nrequest.onreadystatechange = function () {\n // 状态发生变化时，函数被回调\n if (request.readyState == 4) {\n   // 成功完成\n   // 判断响应结果:\n   if (request.status == 200) {\n     // 成功，通过responseText拿到响应的文本\n     console.log(request.responseText);\n   } else {\n     // 失败，根据响应码判断失败原因:\n     console.log(request.status);\n   }\n}\n};\n\n\n// 发送请求\n// open的参数：\n// 一：请求方法，包括get/post等\n// 二：请求地址\n// 三：表示是否异步请求，若为false则是同步请求，会阻塞进程\nrequest.open(\"GET\", \"/api/categories\", true);\nrequest.send();\n\n\n上面是处理一个 HTTP 请求的方法。我们通常会将它封装成一个通用的方法，方便调用。上面例子中我们根据返回的request.status 是否为200来判断是否成功，但实际上200-400（不包括400）的范围，都可以算是成功的，因为其中还包括使用缓存、重定向等情况。\n\n我们将其封装起来，同时使用 ES6 的Promise的方式，我们可以将其变成一个通过Peomise进行异步回调的请求函数：\n\nfunction Ajax({ method, url, params, contentType }) {\n const xhr = new XMLHttpRequest();\n const formData = new FormData();\n Object.keys(params).forEach((key) => {\n   formData.append(key, params[key]);\n});\n return new Promise((resolve, reject) => {\n   try {\n     xhr.open(method, url, false);\n     xhr.setRequestHeader(\"Content-Type\", contentType);\n     xhr.onreadystatechange = function () {\n       if (xhr.readyState === 4) {\n         if (xhr.status >= 200 && xhr.status < 400) {\n           // 这里我们使用200-400来判断\n           resolve(xhr.responseText);\n         } else {\n           // 返回请求信息\n           reject(xhr);\n         }\n       }\n     };\n     xhr.send(formData);\n   } catch (err) {\n     reject(err);\n   }\n});\n}\n\n\n通过这样简单的封装，我们就可以以 Promise 的方式来发起 Ajax 请求。\n\n但在具体的项目使用过程中，我们通常还需要考虑更多的问题，比如防抖节流、失败重试、缓存能力、浏览器兼容性、参数处理等。\n\n这就是 HTTP 请求的编程实现。\n\n\n小结\n\n对前端开发来说，网络请求是开发过程中最基础却又常常容易被忽略的部分。很多人总认为网络请求不过是“向后台发请求，后台进行响应”这样简单的逻辑，而忽略了它在用户体验中的重要性。\n\n实际上，在前端性能优化中，网络请求的优化往往占据了很大一部分，包括首屏直出、分包加载、数据分片拉取、使用缓存、预加载等，都是通过合理地减少网络请求内容、减少网络请求的等待耗时等方式，达到很不错的优化效果。\n\n那么，学完本讲页面的请求过程之后，你认为可以提升页面加载速度的优化方式都有哪些呢？欢迎在留言区分享你的经验。\n\n\n\n----------------------------------------\n\n\n# 精选评论\n\n# **8923：\n\n> 看了这篇文章，了解一个网址url输入的过程，还有http请求的编码优化，前端性能优化可以从这几方面着手：首屏直出、分包加载，使用缓存，预加载等方式减少网络请求内容，这样提升网页响应的速度\n\n# 856：\n\n> document.domain + iframe 这里的iframe是什么？\n\n#     讲师回复：\n\n>     ，它能够将另一个HTML页面嵌入到当前页面中\n\n# **安：\n\n> 配置host解决的是，根据网页域名来调取其他域名或者ip的接口，相当于做了一个中间者，但是不能解决跨域失败的问题吧？\n\n#     讲师回复：\n\n>     本地调试时，比如使用 npm run dev 起服务，本地地址常常为 localhost 或者是 127.0.0.1，这些地址如果直接发起请求是会跨域且可能被拒绝的，配置 host 很多时候是为了将支持跨域的域名映射到本地，从而可以正常地访问和进行本地调试\n\n# **贤：\n\n> proxy 代理也可以解决跨域问题吧 devServer: { proxy: { '/API': { // 定义代理的名称 changeOrigin: true, // 是否启动代理 target: 'http://xijipan.dev.grdoc.org', // 代理的域名　　　　　pathRewrite: {'^/API','/'} // 如果你的真实的api路径中没有/API这一个路径，把这句加上，如果本来就有/API这一路径的话，这句一定要去掉，要不然会导致域名找不到的 } } },",normalizedContent:"从这一讲开始，我会介绍浏览器相关的内容，比如浏览器中的网络请求过程、http 协议在浏览器中的应用、浏览器中页面的渲染过程，等等。\n\n我们知道，浏览器的主要功能是展示网页资源，包括向服务器发起请求、从服务器获取相关资源，并将网页显示在浏览器窗口中。\n\n当我们去面试的时候，常常会被问到一个问题：在浏览器里面输入 url，按下回车键，会发生什么？\n\n这个问题涉及浏览器中的运行机制和页面加载流程，并且这些内容也都穿插在我们日常开发中，包括前后端联调、对网页进行性能优化等。\n\n今天我会先跟你聊一聊浏览器中网络请求是怎么进行的，这样你对整个网页渲染会有个更好的认识。\n\n\n页面的请求过程\n\n当我们打开某个网站的页面，浏览器就会发起网络请求获取该页面的资源，我们也可以从控制台看到以下的请求信息：\n\n\n\n在 network 面板里，我们能看到所有浏览器发起的网络请求，包括页面、图片、css 文件、xhr 请求等，还能看到请求的状态（200 成功、404 找不到、缓存、重定向等等）、耗时、请求头和内容、返回头和内容等。\n\n图中第一个就是网站页面的请求，返回<html>页面。\n\n接下来，浏览器会加载页面，同时页面中涉及的外部资源也会根据需要，在特定的时机触发请求下载，包括我们看到的 png 图片、javascript 文件（这里没有 css 样式，是因为样式被直出在<html>页面内容里了）。\n\n回到前面的问题，实际上当我们在浏览器输入网页地址，按下回车键后，浏览器的处理过程如下：\n\n 1. dns 域名解析（此处涉及 dns 的寻址过程），找到网页的存放服务器；\n\n 2. 浏览器与服务器建立 tcp 连接；\n\n 3. 浏览器发起 http 请求；\n\n 4. 服务器响应 http 请求，返回该页面的 html 内容；\n\n 5. 浏览器解析 html 代码，并请求 html 代码中的资源（如 javascript、css、图片等，此处可能涉及 http 缓存）；\n\n 6. 浏览器对页面进行渲染呈现给用户（此处涉及浏览器的渲染原理）。\n\nhttp 缓存和浏览器渲染原理会分别在第 7 讲和第 8 讲中讲述，今天我们主要围绕 http 请求相关展开。\n\n首先我们来看 dns 解析过程。\n\ndns 解析\n\ndns 的全称是 domain name system，又称域名系统，它负责把www.qq.com这样的域名地址翻译成一个 ip（比如14.18.180.206），而客户端与服务器建立 tcp 连接需要通过 ip 通信。\n\n让客户端和服务器连接并不是靠域名进行，在网络中每个终端之间实现连接和通信是通过一个唯一的 ip 地址来完成。在建立 tcp 连接前，我们需要找到建立连接的服务器，dns 的解析过程可以让用户通过域名找到存放文件的服务器。\n\ndns 解析过程会进行递归查询，分别依次尝试从以下途径，按顺序地获取该域名对应的 ip 地址。\n\n * 浏览器缓存\n\n * 系统缓存（用户操作系统 hosts 文件 dns 缓存）\n\n * 路由器缓存\n\n * 互联网服务提供商 dns 缓存（联通、移动、电信等互联网服务提供商的 dns 缓存服务器）\n\n * 根域名服务器\n\n * 顶级域名服务器\n\n * 主域名服务器\n\ndns 解析过程会根据上述步骤进行递归查询，如果当前步骤没查到，则自动跳转到到下一步骤通过下一个 dns 服务器进行查找。如果最终依然没找到，浏览器便会将页面响应为打开失败。\n\n除此之外，我们在前后端联调过程中也常常需要配置 host，这个过程便是修改了浏览器缓存或是系统缓存。通过将特定域名指向我们自身的服务器 ip 地址，便可以实现通过域名访问本地环境、测试环境、预发布环境的服务器资源。\n\n那为什么需要配置域名 host，而不直接使用 ip 地址进行访问呢？这是因为浏览器的同源策略会导致跨域问题。\n\n同源策略要求，只有当请求的协议、域名和端口都相同的情况下，我们才可以访问当前页面的 cookie/localstorage/indexdb、获取和操作 dom 节点，以及发送 ajax 请求。通过同源策略的限制，可以避免恶意的攻击者盗取用户信息，从而可以保证用户信息的安全。\n\n对于非同源的请求，我们常常称为跨域请求，需要进行跨域处理。常见的跨域解决方案有这几种。\n\n * 使用document.domain + iframe：只有在主域相同的时候才能使用该方法。\n\n * 动态创建 script(jsonp)：通过指定回调函数以及函数的传参数据，让页面执行相应的脚本内容。\n\n * 使用location.hash + iframe：利用location.hash来进行传值。\n\n * 使用window.name + iframe：原理是window.name值在不同的页面（甚至不同域名）加载后依旧存在。\n\n * 使用window.postmessage()实现跨域通信。\n\n * 使用跨域资源共享 cors（cross-origin resource sharing）。\n\n * 使用 websockets。\n\n其中，cors 作为现在的主流解决方案，它允许浏览器向跨源服务器，发出 xmlhttprequest 请求，从而克服了 ajax 只能同源使用的限制。实现 cors 通信的关键是服务器，只要服务端实现了 cors 接口，就可以进行跨源通信。\n\ndns 解析完成后，浏览器获得了服务端的 ip 地址，接下来便可以向服务端发起 http 请求。目前大多数 http 请求都建立在 tcp 连接上，因此客户端和服务端会先建立起 tcp 连接。\n\ntcp 连接的建立\n\ntcp 连接的建立过程比较偏通信底层，在前端日常开发过程中不容易接触到。但有时候我们需要优化应用的加载耗时、请求耗时或是定位一些偏底层的问题（请求异常、http 连接无法建立等），都会或多或少依赖这些偏底层的知识。\n\n另外，从面试的角度看，我们需要掌握 tcp/udp 的区别、tcp 的三次握手和四次挥手内容。\n\n * tcp 协议提供可靠传输服务，udp 协议则可以更快地进行通信；\n\n * 三次握手：指 tcp 连接的建立过程，该过程中客户端和服务端总共需要发送三个包，从而确认连接存在。\n\n * 四次挥手：指 tcp 连接的断开过程，该过程中需要客户端和服务端总共发送四个包以，从而确认连接关闭。\n\n当客户端和服务端建立起 tcp 连接之后，http 服务器会监听客户端发起的请求，此时客户端会发起 http 请求。\n\nhttp 请求与 tcp 协议\n\n由客户端发起的 http 请求，服务器收到后会进行回复，回复内容通常包括 http 状态、响应消息等，更具体的会在下一讲 http 协议中进行介绍。\n\n前面说过，目前大多数 http 请求都是基于 tcp 协议。tcp 协议的目的是提供可靠的数据传输，它用来确保可靠传输的途径主要包括两个：\n\n 1. 乱序重建：通过对数据包编号来对其排序，从而使得另一端接收数据时，可以重新根据编号还原顺序。\n\n 2. 丢包重试：可通过发送方是否得到响应，来检测出丢失的数据并重传这些数据。\n\n通过以上方式，tcp 在传输过程中不会丢失或破坏任何数据，这也是即使出现网络故障也不会损坏文件下载的原因。\n\n因此，目前大多数 http 连接基于 tcp 协议。不过，在 http/3 中底层支撑是 quic 协议，该协议使用的是 udp 协议。因为 udp 协议丢弃了 tcp 协议中所有的错误检查内容，因此可以更快地进行通信，更常用于直播和在线游戏的应用。\n\n也就是说，http/3 基于 udp 协议实现了数据的快速传输，同时通过 quic 协议保证了数据的可靠传输，最终实现了又快又可靠的通信。\n\n除了以上的内容，其实我们还可以去了解关于 tcp/ip 协议的分层模型、ip 寻址过程，以及 ip 协议又是如何将数据包准确无误地传递这些内容，也需要关注 http/2、http/3、https 这些协议的设计变更了什么、又解决了什么。\n\n或许这些内容对于大多数前端开发来说，都很少会直接接触。但它就像乘法口诀在高考数学题中的角色，基本上所有题目中都会使用到，但我们很少会认为自己是因为掌握了乘法口诀才能顺利解答题目。\n\n同样的，我们对网络请求的认知也常常忽略了底层 tcp/ip 知识，基本上围绕着“前端发起了请求，后台就能收到”“请求没有按预期结果返回，要么是请求包内容有误，要么后台服务异常”这样的理解去进行处理。\n\n但如果某一天，我们的应用整体请求耗时突然变长，这个过程中前端和后台都没有时间上能关联的发布单，我们到底应该如何进行定位呢？如果我们对一个网络请求的完整流程不够了解，又怎么定位到底是哪个步骤出现问题了呢？甚至我们都不会想到，将 http 切换到 https 也可能会影响到请求耗时。\n\n下面，我们就来看一下 http 请求在前端开发过程中是如何进行编程实现的，这就不得不提到 ajax 请求了。\n\n\najax 请求\n\najax 请求这个词会频繁出现在我们的工作对话内容中，但它并不是 javascript 的规范，而是 jesse james garrett 提出的新术语：asynchronous javascript and xml，意思是用 javascript 执行异步网络请求。\n\n网络请求的发展\n\n对于浏览器来说，网络请求是用来从服务端获取需要的信息，然后解析协议和内容，来进行页面渲染或者是信息获取的过程。\n\n在很久以前，我们的网络请求除了静态资源（html/css/javascript 等）文件的获取，主要用于表单的提交。我们在完成表单内容的填写之后，点击提交按钮，接下来表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。\n\n除了页面跳转刷新会影响用户体验，在表单提交过程中，使用同步请求会阻塞进程。此时用户无法继续操作页面，导致页面呈现假死状态，使得用户体验变得糟糕。\n\n为了避免这种情况，我们开始使用异步请求 + 回调的方式，来进行请求处理，这就是 ajax。\n\n随着时间发展，ajax 的应用越来越广，如今使用 ajax 已经是前端开发的基本操作。但 ajax 是一种解决方案，在前端中的具体实现依赖使用xmlhttprequest相关 api。页面开始支持局部更新、动态加载，甚至还有懒加载、首屏加载等等，都是以xmlhttprequest为前提。\n\nxmlhttprequest\n\nxmlhttprequest让发送一个 http 请求变得非常容易，我们只需要简单的创建一个请求对象实例，并对它进行操作：\n\nvar request = new xmlhttprequest(); // 新建xmlhttprequest对象\n\n\nrequest.onreadystatechange = function () {\n // 状态发生变化时，函数被回调\n if (request.readystate == 4) {\n   // 成功完成\n   // 判断响应结果:\n   if (request.status == 200) {\n     // 成功，通过responsetext拿到响应的文本\n     console.log(request.responsetext);\n   } else {\n     // 失败，根据响应码判断失败原因:\n     console.log(request.status);\n   }\n}\n};\n\n\n// 发送请求\n// open的参数：\n// 一：请求方法，包括get/post等\n// 二：请求地址\n// 三：表示是否异步请求，若为false则是同步请求，会阻塞进程\nrequest.open(\"get\", \"/api/categories\", true);\nrequest.send();\n\n\n上面是处理一个 http 请求的方法。我们通常会将它封装成一个通用的方法，方便调用。上面例子中我们根据返回的request.status 是否为200来判断是否成功，但实际上200-400（不包括400）的范围，都可以算是成功的，因为其中还包括使用缓存、重定向等情况。\n\n我们将其封装起来，同时使用 es6 的promise的方式，我们可以将其变成一个通过peomise进行异步回调的请求函数：\n\nfunction ajax({ method, url, params, contenttype }) {\n const xhr = new xmlhttprequest();\n const formdata = new formdata();\n object.keys(params).foreach((key) => {\n   formdata.append(key, params[key]);\n});\n return new promise((resolve, reject) => {\n   try {\n     xhr.open(method, url, false);\n     xhr.setrequestheader(\"content-type\", contenttype);\n     xhr.onreadystatechange = function () {\n       if (xhr.readystate === 4) {\n         if (xhr.status >= 200 && xhr.status < 400) {\n           // 这里我们使用200-400来判断\n           resolve(xhr.responsetext);\n         } else {\n           // 返回请求信息\n           reject(xhr);\n         }\n       }\n     };\n     xhr.send(formdata);\n   } catch (err) {\n     reject(err);\n   }\n});\n}\n\n\n通过这样简单的封装，我们就可以以 promise 的方式来发起 ajax 请求。\n\n但在具体的项目使用过程中，我们通常还需要考虑更多的问题，比如防抖节流、失败重试、缓存能力、浏览器兼容性、参数处理等。\n\n这就是 http 请求的编程实现。\n\n\n小结\n\n对前端开发来说，网络请求是开发过程中最基础却又常常容易被忽略的部分。很多人总认为网络请求不过是“向后台发请求，后台进行响应”这样简单的逻辑，而忽略了它在用户体验中的重要性。\n\n实际上，在前端性能优化中，网络请求的优化往往占据了很大一部分，包括首屏直出、分包加载、数据分片拉取、使用缓存、预加载等，都是通过合理地减少网络请求内容、减少网络请求的等待耗时等方式，达到很不错的优化效果。\n\n那么，学完本讲页面的请求过程之后，你认为可以提升页面加载速度的优化方式都有哪些呢？欢迎在留言区分享你的经验。\n\n\n\n----------------------------------------\n\n\n# 精选评论\n\n# **8923：\n\n> 看了这篇文章，了解一个网址url输入的过程，还有http请求的编码优化，前端性能优化可以从这几方面着手：首屏直出、分包加载，使用缓存，预加载等方式减少网络请求内容，这样提升网页响应的速度\n\n# 856：\n\n> document.domain + iframe 这里的iframe是什么？\n\n#     讲师回复：\n\n>     ，它能够将另一个html页面嵌入到当前页面中\n\n# **安：\n\n> 配置host解决的是，根据网页域名来调取其他域名或者ip的接口，相当于做了一个中间者，但是不能解决跨域失败的问题吧？\n\n#     讲师回复：\n\n>     本地调试时，比如使用 npm run dev 起服务，本地地址常常为 localhost 或者是 127.0.0.1，这些地址如果直接发起请求是会跨域且可能被拒绝的，配置 host 很多时候是为了将支持跨域的域名映射到本地，从而可以正常地访问和进行本地调试\n\n# **贤：\n\n> proxy 代理也可以解决跨域问题吧 devserver: { proxy: { '/api': { // 定义代理的名称 changeorigin: true, // 是否启动代理 target: 'http://xijipan.dev.grdoc.org', // 代理的域名　　　　　pathrewrite: {'^/api','/'} // 如果你的真实的api路径中没有/api这一个路径，把这句加上，如果本来就有/api这一路径的话，这句一定要去掉，要不然会导致域名找不到的 } } },",charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"HTTP 协议和前端开发有什么关系？",frontmatter:{title:"HTTP 协议和前端开发有什么关系？",date:"2022-04-14T22:48:02.000Z",permalink:"/pages/595abe/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/07.HTTP%20%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB.html",relativePath:"01.前端/01.前端开发笔记/07.HTTP 协议和前端开发有什么关系.md",key:"v-896d9d60",path:"/pages/595abe/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5576}],headersStr:"精选评论",content:"HTTP 请求的场景相对复杂，对应的 HTTP 协议也是各式各样的，因此很多时候大家都认为内容太多太杂，认为学习 HTTP 协议性价比太低了。\n\n其实我们日常开发中，经常会使用到 cookie、浏览器的缓存机制、各种形式的网络连接（比如 Websocket），这些网络请求相关的场景都跟 HTTP 协议有密切的关系。\n\n对于前端开发来说，HTTP 协议基本上不会离开嘴边。HTTP 协议的内容很多很杂，这里我先给大家梳理一下它的设计和演变。\n\n\n认识 HTTP 协议\n\n上一讲，我们知道了网络请求的过程，当服务端建立起与客户端的 TCP 连接之后，服务端会持续监听客户端发起的请求。接下来，客户端将发起 HTTP 请求，请求内容通常包括请求方法、请求的资源等，服务端收到请求后会进行回复，回复内容通常包括 HTTP 状态、响应消息等。\n\n可以看到，网络请求的过程包括两个步骤：客户端发送请求，服务器返回响应。这就是HTTP 协议的主要特点：遵循经典的“客户端-服务端”模型。\n\n除此之外，HTTP 协议还被设计得简单易读。在 HTTP/2 之前，HTTP 协议是语义可读的，我们可以直观地获取其中的内容。比如：\n\n * HTTP 请求方法：代表着客户端的动作行为（GET-获取资源/POST-提交资源/PUT-修改资源/DELETE-删除资源）。\n\n * HTTP 状态码：代表着当前请求的状态（1XX-提示信息/2XX-成功/3XX-重定向/4XX-客户端错误/5XX-服务端错误）。\n\n * HTTP 消息头：客户端和服务端通过request和response传递附加信息。\n\n通过 HTTP 协议，我们可以看到该请求是否成功、错误原因是哪些、请求是否使用了缓存、请求和响应数据是否符合预期等。想必这些内容你多少都已经有所了解，因此这里我不再赘述。\n\n前面我们说到，HTTP 协议在 HTTP/2 之前是语义可读的，那么 HTTP/2 之后发生了什么呢？我们可以看一下 HTTP 协议的演变过程。\n\nHTTP 协议的演变\n\nHTTP 协议从被创造以来，一直在不断演变着：从 HTTP/1.0、HTTP/1.1，到 HTTP/2、HTTP/3，HTTP 协议在保持协议简单性的同时，拓展了灵活性，提供越来越快、更加可靠的传输服务。\n\nHTTP/1.0 到 HTTP/1.1，主要实现了对 TCP 连接的复用。 最初在 HTTP/1.0 中，每一对 HTTP 请求和响应都需要打开一个单独的 TCP 连接。这样的方式对资源消耗很大，因此 HTTP/1.1 中引入了持久连接的概念，通过设置Connection头部为keep-alive的方式，可以让 TCP 连接不会关闭。该功能避免了 TCP 连接的重新建立，客户端可在已建立的 TCP 连接上，长时间地对同一个服务端的发起请求。\n\nHTTP/1.1 到 HTTP/2，主要实现了多个请求的复用。 HTTP/2 通过将 HTTP 消息拆分为独立的帧，进行交错发送，实现在同一个连接上并行多个请求，来减少网络请求的延迟。为了实现多路复用，HTTP/2 协议对 HTTP 头部进行了二进制编码，因此不再语义可读。除此之外，HTTP2 还实现了 Header 压缩、服务端主动推动、流优先级等能力。\n\nHTTP/2 到 HTTP/3，主要实现了基于 UDP 协议、更快的传输。 HTTP/3 使用了基于 UDP 的 QUIC 协议，实现了又快又可靠的传输。由于 UDP 协议中没有错误检查内容，因此可以更快地实现通信。同时，QUIC 协议负责合并纠错、重建丢失的数据，解决了 UDP 协议传输丢包的问题。\n\n总的来说，HTTP 协议的演变过程主要围绕着传输效率和速度上的优化，我们可以通过升级 HTTP 协议来优化前端应用。除此之外，我们在日常的工作中，同样可以借鉴 HTTP 协议的优化手段。比如，可以使用资源压缩、资源复用等技术手段，来优化前端性能。技术常常是通用的，我们在学习一些看起来不相关的内容时，会发现其实很多技术转变都是值得思考和参考的。\n\n下面我们来看一下常见的一些 HTTP 协议场景。\n\n\nHTTP Cookie\n\nHTTP 协议是无状态的，这意味着在同一个 TCP 连接中，先后发起的请求之间没有任何关系。这给服务端带来了挑战：用户在同一个网站中进行连续的操作，服务端无法知道这些操作来自哪里。\n\n使用 HTTP Cookie 可以解决这个问题。当服务端将 HTTP 响应返回给客户端时，通过在响应头里面添加一个Set-Cookie信息，浏览器收到带Set-Cookie信息的响应后会将 Cookie 保存，在后面发送给该服务端的每个请求中，都会自动带上 Cookie 信息。服务端根据 Cookie 信息，就能取得客户端的数据信息。\n\n由于 Cookie 信息是被浏览器识别并自动保存和发送的，因此在默认情况下，浏览器关闭之后它就会被自动删除。但我们也可以通过指定过期时间（Expires）或者有效期（Max-Age），来让 Cookie 获得更久的有效期。\n\n需要注意的是，某个网站在设置了 Cookie 之后，所有符合条件（有效期、域名、路径、适用站点等）的请求都会被自动带上 Cookie。这带来了一个 Web 安全隐患：服务端只知道请求来自某个用户的浏览器，却不知道请求本身是否用户自愿发出的。\n\n利用这一漏洞，攻击者可通过一些技术手段（图片地址、超链接等）欺骗用户的浏览器访问曾经认证过的网站，并利用用户的登录态进行一些操作，可能导致用户信息泄露、资产被转移、在不知情的情况下发送信息等，带来了恶劣的后果。这便是我们常说的 Web 安全问题之一：跨站请求伪造（CSRF）。\n\n为了应对这种情况，我们可以校验 HTTP 请求头中的Referer字段，这个字段用以标明请求来源于哪个地址。但由于该字段可能会被篡改，因此只能作为辅助校验手段。\n\n防范跨站请求伪造攻击的有效方法，就是避免依赖浏览器自动带上的 Cookie 信息。我们可以使用其他方式校验用户登录态，比如将用户登录态保存在浏览器缓存中，在发送请求的时候添加用于标识用户的参数值，现在大多数应用也是使用 Token 来进行用户标识。\n\n除了 HTTP Cookie 之外，浏览器中 HTTP 缓存机制也同样依赖 HTTP 协议。\n\n\nHTTP 缓存\n\n缓存常常被用作性能优化的技术方案之一，通过缓存我们可以有效地减少资源获取的耗时，减少用户的等待时长，从而提升用户的体验。\n\n其中，我们可以通过 HTTP 协议，设置浏览器对 HTTP 响应资源进行缓存。使用浏览器缓存后，当我们再发起 HTTP 请求时，如果浏览器缓存发现请求的资源已经被存储，它会拦截请求并返回该资源的副本，不需要再去请求服务端获取资源，因此减少了 HTTP 请求的耗时，同时也能有效地缓解服务端压力。\n\n一般来说，HTTP 缓存只能存储 GET 请求的响应内容，对于这些响应内容可能会存在两种情况：\n\n 1. 不缓存内容，每次请求的时候都会从服务端获取最新的内容；\n\n 2. 设置了缓存内容，则在有效期内会从缓存获取，如果用户刷新或内容过期则去服务端获取最新的内容。\n\n那么，要如何给 GET 请求设置缓存呢？在浏览器中，便是依靠请求和响应中的头信息来控制缓存的。根据缓存的行为，我们可以将它们分为强制缓存和协商缓存两种。\n\n 1. 强制缓存， 在规定有效期内，直接使用缓存。可以通过以下的方式使用强制缓存：\n    \n    1. 服务端通过设置Expires和Cache-Control，和客户端约定缓存内容的有效时间；\n    \n    2. 若符合缓存条件，浏览器响应HTTP 200(from cache)。\n\n 2. 协商缓存， 与服务端协商是否使用缓存。可以通过以下的方式使用协商缓存：\n    \n    1. 服务端通过设置If-Modified-Since和If-None-Match，和客户端约定标识协商缓存的值；\n    \n    2. 当有效期过后，浏览器将缓存信息中的 Etag 和 Last-Modified 信息，分别使用 If-None-Match 和 If-Modified-Since 请求头设置，提交给服务端。\n    \n    3. 若符合缓存条件，服务端则响应HTTP 304，浏览器将从缓存读数据。\n\n若以上缓存条件均不符合，服务端响应HTTP 200，返回更新后的数据，同时通过响应头更新 HTTP 缓存设置。整个过程可以用下面的流程图来表示：\n\n\n\n浏览器会在第一次请求完服务端后得到响应，通过适当地设置响应头信息，我们可以使用更多的缓存资源，从而提升网站的响应速度和性能，给到用户更好的体验。\n\n除了常见的 Cookie 和 GET 请求的缓存，客户端和服务端在实现双向通信的时候，同样会依赖 HTTP 协议来完成。\n\n\n客户端服务端双向通信\n\n客户端和服务端的通信方式有很多种，大多数场景下都是由客户端主动发送数据给服务端，但在特定的场景下（如多人协作、在线游戏）客户端还需要和服务端保持实时通信，此时需要使用双向通信。\n\n常见的双向通信方式包括 HTTP 短轮询（polling）、HTTP 长轮询（long-polling）、XHR Streaming、Server-Sent Events、Websocket 等。\n\n其中，最简单粗暴的莫过于 HTTP 短轮询，客户端每隔特定的时间（比如 1s）便向服务端发起请求，获取最新的资源信息。该方式会造成较多的资源浪费，尤其当服务端内容更新频率低于轮询间隔时，就会造成服务端资源、客户端资源的浪费。除此之外，过于频繁的请求也会给服务端造成额外的压力，当服务端负载较高的时候，甚至可能导致雪崩等情况发生。\n\nHTTP 长轮询解决了短轮询的一些问题，长轮询实现特点主要为当客户端向服务端发起请求后，服务端保持住连接，当数据更新响应之后才断开连接。然后客户端会重新建立连接，并继续等待新数据。此技术的主要问题在于，在重新连接过程中，页面上的数据可能会过时且不准确。\n\n相比 HTTP 长轮询，XHR Streaming 可以维护客户端和服务端之间的连接。但使用 XHR Streaming 过程中，XMLHttpRequest对象的数量将不断增长，因此在使用过程中需要定期关闭连接，来清除缓冲区。\n\nSSE（Server-Sent Events）方案思想便是 XHR Streaming，主要基于浏览器中EventSourceAPI 的封装和协议。它会对 HTTP 服务开启一个持久化的连接，以text/event-stream格式发送事件， 会一直保持开启直到被要求关闭。\n\n最后我们来介绍 WebSocket，它实现了浏览器与服务端全双工通信。前面我们提到，HTTP 短轮询、长轮询都会带来额外的资源浪费，因此 Websocket 在实现实时通信的同时，能更好地节省服务端资源和带宽。\n\nWebsoctet 是如何实现全双工通信的呢？Websocket 建立在 TCP 协议之上，握手阶段采用 HTTP 协议，但这个 HTTP 协议的请求头中，有以下的标识性内容。\n\n * Connection: Upgrade、Upgrade: websocket：表示这个连接将要被转换为 WebSocket 连接。\n\n * Sec-WebSocket-Key：向服务端提供所需的信息，以确认客户端有权请求升级到 WebSocket。\n\n * Sec-WebSocket-Protocol：指定一个或多个的 WebSocket 协议。\n\n * Sec-WebSocket-Version：指定 WebSocket 的协议版本。\n\n如果服务端同意启动 WebSocket 连接，会在握手过程中的 HTTP 协议中返回包含Sec-WebSocket-Accept的响应消息，接下来客户端和服务端便建立 WebSocket 连接，并通过 WebSocket 协议传输数据。\n\n由于不再需要通过 HTTP 协议通信，省去请求头等内容设置，Websocket 数据格式会更加轻量，通信更加高效，性能开销也相应地降低。除此之外，不同于 HTTP 协议，Websocket 协议没有同源限制，因此客户端可以与任意服务端通信。\n\n以上这些，都是客户端和服务端双向通信的一些解决方案，我帮你简单整理成思维导图：\n\n\n\n在依赖双向通信的场景中，这些方案并没有绝对的最优解，更多时候都是不同场景和架构设计下的选择。\n\n如果你去仔细研究在线协作的办公工具，比如谷歌文档、石墨文档、金山文档、腾讯文档，你会发现它们的双向通信都分别使用了不同的解决方案。\n\n\n小结\n\n今天，我主要介绍了 HTTP 协议相关的内容，同时介绍了较常见的一些 HTTP 协议的应用场景，包括 HTTP Cookie、HTTP 缓存、客户端和服务端双向通信。\n\n关于 HTTP 缓存过程想必你也应该掌握了，那你知道当我们在浏览器中分别使用F5和ctrl + F5快捷键刷新页面的时候，HTTP 的缓存过程又是怎样呢？把你的想法写在留言区~\n\n我们在日常开发中就会经常遇到网络请求失败、调试异常等情况，如果不了解 HTTP 协议会极大地影响调试效率。因此对 HTTP 协议的掌握，对于前端的联调和开发过程中是必不可少的。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **北：\n\n> 如果想防止更新自动删除数据，就需要用到本地存储来将刷新前数据存起来然后再设置\n\n#     讲师回复：\n\n>     这是一个思路，但是可能使用场景会少一些~\n\n# **峰：\n\n> 需要注意的是，某个网站在设置了 Cookie 之后，所有符合条件（有效期、域名、路径、适用站点等）的请求都会被自动带上 Cookie。———这里的设置cookie什么意思？浏览器设置的，还是服务器设置的？\n\n#     讲师回复：\n\n>     当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。 也就是说，Cookie 是服务器种下的，后续符合条件的请求会被自动带上则是浏览器默认的行为。\n\n# **飞：\n\n> ctrl + F5 应该等同于 dev tools里面设置 no cache，F5 还是会按照缓存逻辑去命中缓存的。\n\n#     讲师回复：\n\n>     基本上差不多，但是如果服务器忽略无缓存头，则即使Ctrl + F5也会返回该页面的旧版本",normalizedContent:"http 请求的场景相对复杂，对应的 http 协议也是各式各样的，因此很多时候大家都认为内容太多太杂，认为学习 http 协议性价比太低了。\n\n其实我们日常开发中，经常会使用到 cookie、浏览器的缓存机制、各种形式的网络连接（比如 websocket），这些网络请求相关的场景都跟 http 协议有密切的关系。\n\n对于前端开发来说，http 协议基本上不会离开嘴边。http 协议的内容很多很杂，这里我先给大家梳理一下它的设计和演变。\n\n\n认识 http 协议\n\n上一讲，我们知道了网络请求的过程，当服务端建立起与客户端的 tcp 连接之后，服务端会持续监听客户端发起的请求。接下来，客户端将发起 http 请求，请求内容通常包括请求方法、请求的资源等，服务端收到请求后会进行回复，回复内容通常包括 http 状态、响应消息等。\n\n可以看到，网络请求的过程包括两个步骤：客户端发送请求，服务器返回响应。这就是http 协议的主要特点：遵循经典的“客户端-服务端”模型。\n\n除此之外，http 协议还被设计得简单易读。在 http/2 之前，http 协议是语义可读的，我们可以直观地获取其中的内容。比如：\n\n * http 请求方法：代表着客户端的动作行为（get-获取资源/post-提交资源/put-修改资源/delete-删除资源）。\n\n * http 状态码：代表着当前请求的状态（1xx-提示信息/2xx-成功/3xx-重定向/4xx-客户端错误/5xx-服务端错误）。\n\n * http 消息头：客户端和服务端通过request和response传递附加信息。\n\n通过 http 协议，我们可以看到该请求是否成功、错误原因是哪些、请求是否使用了缓存、请求和响应数据是否符合预期等。想必这些内容你多少都已经有所了解，因此这里我不再赘述。\n\n前面我们说到，http 协议在 http/2 之前是语义可读的，那么 http/2 之后发生了什么呢？我们可以看一下 http 协议的演变过程。\n\nhttp 协议的演变\n\nhttp 协议从被创造以来，一直在不断演变着：从 http/1.0、http/1.1，到 http/2、http/3，http 协议在保持协议简单性的同时，拓展了灵活性，提供越来越快、更加可靠的传输服务。\n\nhttp/1.0 到 http/1.1，主要实现了对 tcp 连接的复用。 最初在 http/1.0 中，每一对 http 请求和响应都需要打开一个单独的 tcp 连接。这样的方式对资源消耗很大，因此 http/1.1 中引入了持久连接的概念，通过设置connection头部为keep-alive的方式，可以让 tcp 连接不会关闭。该功能避免了 tcp 连接的重新建立，客户端可在已建立的 tcp 连接上，长时间地对同一个服务端的发起请求。\n\nhttp/1.1 到 http/2，主要实现了多个请求的复用。 http/2 通过将 http 消息拆分为独立的帧，进行交错发送，实现在同一个连接上并行多个请求，来减少网络请求的延迟。为了实现多路复用，http/2 协议对 http 头部进行了二进制编码，因此不再语义可读。除此之外，http2 还实现了 header 压缩、服务端主动推动、流优先级等能力。\n\nhttp/2 到 http/3，主要实现了基于 udp 协议、更快的传输。 http/3 使用了基于 udp 的 quic 协议，实现了又快又可靠的传输。由于 udp 协议中没有错误检查内容，因此可以更快地实现通信。同时，quic 协议负责合并纠错、重建丢失的数据，解决了 udp 协议传输丢包的问题。\n\n总的来说，http 协议的演变过程主要围绕着传输效率和速度上的优化，我们可以通过升级 http 协议来优化前端应用。除此之外，我们在日常的工作中，同样可以借鉴 http 协议的优化手段。比如，可以使用资源压缩、资源复用等技术手段，来优化前端性能。技术常常是通用的，我们在学习一些看起来不相关的内容时，会发现其实很多技术转变都是值得思考和参考的。\n\n下面我们来看一下常见的一些 http 协议场景。\n\n\nhttp cookie\n\nhttp 协议是无状态的，这意味着在同一个 tcp 连接中，先后发起的请求之间没有任何关系。这给服务端带来了挑战：用户在同一个网站中进行连续的操作，服务端无法知道这些操作来自哪里。\n\n使用 http cookie 可以解决这个问题。当服务端将 http 响应返回给客户端时，通过在响应头里面添加一个set-cookie信息，浏览器收到带set-cookie信息的响应后会将 cookie 保存，在后面发送给该服务端的每个请求中，都会自动带上 cookie 信息。服务端根据 cookie 信息，就能取得客户端的数据信息。\n\n由于 cookie 信息是被浏览器识别并自动保存和发送的，因此在默认情况下，浏览器关闭之后它就会被自动删除。但我们也可以通过指定过期时间（expires）或者有效期（max-age），来让 cookie 获得更久的有效期。\n\n需要注意的是，某个网站在设置了 cookie 之后，所有符合条件（有效期、域名、路径、适用站点等）的请求都会被自动带上 cookie。这带来了一个 web 安全隐患：服务端只知道请求来自某个用户的浏览器，却不知道请求本身是否用户自愿发出的。\n\n利用这一漏洞，攻击者可通过一些技术手段（图片地址、超链接等）欺骗用户的浏览器访问曾经认证过的网站，并利用用户的登录态进行一些操作，可能导致用户信息泄露、资产被转移、在不知情的情况下发送信息等，带来了恶劣的后果。这便是我们常说的 web 安全问题之一：跨站请求伪造（csrf）。\n\n为了应对这种情况，我们可以校验 http 请求头中的referer字段，这个字段用以标明请求来源于哪个地址。但由于该字段可能会被篡改，因此只能作为辅助校验手段。\n\n防范跨站请求伪造攻击的有效方法，就是避免依赖浏览器自动带上的 cookie 信息。我们可以使用其他方式校验用户登录态，比如将用户登录态保存在浏览器缓存中，在发送请求的时候添加用于标识用户的参数值，现在大多数应用也是使用 token 来进行用户标识。\n\n除了 http cookie 之外，浏览器中 http 缓存机制也同样依赖 http 协议。\n\n\nhttp 缓存\n\n缓存常常被用作性能优化的技术方案之一，通过缓存我们可以有效地减少资源获取的耗时，减少用户的等待时长，从而提升用户的体验。\n\n其中，我们可以通过 http 协议，设置浏览器对 http 响应资源进行缓存。使用浏览器缓存后，当我们再发起 http 请求时，如果浏览器缓存发现请求的资源已经被存储，它会拦截请求并返回该资源的副本，不需要再去请求服务端获取资源，因此减少了 http 请求的耗时，同时也能有效地缓解服务端压力。\n\n一般来说，http 缓存只能存储 get 请求的响应内容，对于这些响应内容可能会存在两种情况：\n\n 1. 不缓存内容，每次请求的时候都会从服务端获取最新的内容；\n\n 2. 设置了缓存内容，则在有效期内会从缓存获取，如果用户刷新或内容过期则去服务端获取最新的内容。\n\n那么，要如何给 get 请求设置缓存呢？在浏览器中，便是依靠请求和响应中的头信息来控制缓存的。根据缓存的行为，我们可以将它们分为强制缓存和协商缓存两种。\n\n 1. 强制缓存， 在规定有效期内，直接使用缓存。可以通过以下的方式使用强制缓存：\n    \n    1. 服务端通过设置expires和cache-control，和客户端约定缓存内容的有效时间；\n    \n    2. 若符合缓存条件，浏览器响应http 200(from cache)。\n\n 2. 协商缓存， 与服务端协商是否使用缓存。可以通过以下的方式使用协商缓存：\n    \n    1. 服务端通过设置if-modified-since和if-none-match，和客户端约定标识协商缓存的值；\n    \n    2. 当有效期过后，浏览器将缓存信息中的 etag 和 last-modified 信息，分别使用 if-none-match 和 if-modified-since 请求头设置，提交给服务端。\n    \n    3. 若符合缓存条件，服务端则响应http 304，浏览器将从缓存读数据。\n\n若以上缓存条件均不符合，服务端响应http 200，返回更新后的数据，同时通过响应头更新 http 缓存设置。整个过程可以用下面的流程图来表示：\n\n\n\n浏览器会在第一次请求完服务端后得到响应，通过适当地设置响应头信息，我们可以使用更多的缓存资源，从而提升网站的响应速度和性能，给到用户更好的体验。\n\n除了常见的 cookie 和 get 请求的缓存，客户端和服务端在实现双向通信的时候，同样会依赖 http 协议来完成。\n\n\n客户端服务端双向通信\n\n客户端和服务端的通信方式有很多种，大多数场景下都是由客户端主动发送数据给服务端，但在特定的场景下（如多人协作、在线游戏）客户端还需要和服务端保持实时通信，此时需要使用双向通信。\n\n常见的双向通信方式包括 http 短轮询（polling）、http 长轮询（long-polling）、xhr streaming、server-sent events、websocket 等。\n\n其中，最简单粗暴的莫过于 http 短轮询，客户端每隔特定的时间（比如 1s）便向服务端发起请求，获取最新的资源信息。该方式会造成较多的资源浪费，尤其当服务端内容更新频率低于轮询间隔时，就会造成服务端资源、客户端资源的浪费。除此之外，过于频繁的请求也会给服务端造成额外的压力，当服务端负载较高的时候，甚至可能导致雪崩等情况发生。\n\nhttp 长轮询解决了短轮询的一些问题，长轮询实现特点主要为当客户端向服务端发起请求后，服务端保持住连接，当数据更新响应之后才断开连接。然后客户端会重新建立连接，并继续等待新数据。此技术的主要问题在于，在重新连接过程中，页面上的数据可能会过时且不准确。\n\n相比 http 长轮询，xhr streaming 可以维护客户端和服务端之间的连接。但使用 xhr streaming 过程中，xmlhttprequest对象的数量将不断增长，因此在使用过程中需要定期关闭连接，来清除缓冲区。\n\nsse（server-sent events）方案思想便是 xhr streaming，主要基于浏览器中eventsourceapi 的封装和协议。它会对 http 服务开启一个持久化的连接，以text/event-stream格式发送事件， 会一直保持开启直到被要求关闭。\n\n最后我们来介绍 websocket，它实现了浏览器与服务端全双工通信。前面我们提到，http 短轮询、长轮询都会带来额外的资源浪费，因此 websocket 在实现实时通信的同时，能更好地节省服务端资源和带宽。\n\nwebsoctet 是如何实现全双工通信的呢？websocket 建立在 tcp 协议之上，握手阶段采用 http 协议，但这个 http 协议的请求头中，有以下的标识性内容。\n\n * connection: upgrade、upgrade: websocket：表示这个连接将要被转换为 websocket 连接。\n\n * sec-websocket-key：向服务端提供所需的信息，以确认客户端有权请求升级到 websocket。\n\n * sec-websocket-protocol：指定一个或多个的 websocket 协议。\n\n * sec-websocket-version：指定 websocket 的协议版本。\n\n如果服务端同意启动 websocket 连接，会在握手过程中的 http 协议中返回包含sec-websocket-accept的响应消息，接下来客户端和服务端便建立 websocket 连接，并通过 websocket 协议传输数据。\n\n由于不再需要通过 http 协议通信，省去请求头等内容设置，websocket 数据格式会更加轻量，通信更加高效，性能开销也相应地降低。除此之外，不同于 http 协议，websocket 协议没有同源限制，因此客户端可以与任意服务端通信。\n\n以上这些，都是客户端和服务端双向通信的一些解决方案，我帮你简单整理成思维导图：\n\n\n\n在依赖双向通信的场景中，这些方案并没有绝对的最优解，更多时候都是不同场景和架构设计下的选择。\n\n如果你去仔细研究在线协作的办公工具，比如谷歌文档、石墨文档、金山文档、腾讯文档，你会发现它们的双向通信都分别使用了不同的解决方案。\n\n\n小结\n\n今天，我主要介绍了 http 协议相关的内容，同时介绍了较常见的一些 http 协议的应用场景，包括 http cookie、http 缓存、客户端和服务端双向通信。\n\n关于 http 缓存过程想必你也应该掌握了，那你知道当我们在浏览器中分别使用f5和ctrl + f5快捷键刷新页面的时候，http 的缓存过程又是怎样呢？把你的想法写在留言区~\n\n我们在日常开发中就会经常遇到网络请求失败、调试异常等情况，如果不了解 http 协议会极大地影响调试效率。因此对 http 协议的掌握，对于前端的联调和开发过程中是必不可少的。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **北：\n\n> 如果想防止更新自动删除数据，就需要用到本地存储来将刷新前数据存起来然后再设置\n\n#     讲师回复：\n\n>     这是一个思路，但是可能使用场景会少一些~\n\n# **峰：\n\n> 需要注意的是，某个网站在设置了 cookie 之后，所有符合条件（有效期、域名、路径、适用站点等）的请求都会被自动带上 cookie。———这里的设置cookie什么意思？浏览器设置的，还是服务器设置的？\n\n#     讲师回复：\n\n>     当服务器收到 http 请求时，服务器可以在响应头里面添加一个 set-cookie 选项。浏览器收到响应后通常会保存下 cookie，之后对该服务器每一次请求中都通过 cookie 请求头部将 cookie 信息发送给服务器。 也就是说，cookie 是服务器种下的，后续符合条件的请求会被自动带上则是浏览器默认的行为。\n\n# **飞：\n\n> ctrl + f5 应该等同于 dev tools里面设置 no cache，f5 还是会按照缓存逻辑去命中缓存的。\n\n#     讲师回复：\n\n>     基本上差不多，但是如果服务器忽略无缓存头，则即使ctrl + f5也会返回该页面的旧版本",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"深入剖析浏览器中页面的渲染过程",frontmatter:{title:"深入剖析浏览器中页面的渲染过程",date:"2022-04-14T22:48:02.000Z",permalink:"/pages/53ab0a/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/08.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html",relativePath:"01.前端/01.前端开发笔记/08.深入剖析浏览器中页面的渲染过程.md",key:"v-0f49eef1",path:"/pages/53ab0a/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:3970}],headersStr:"精选评论",content:"作为前端开发，我们的日常工作中除了编码以外，几乎大多数时间都在跟浏览器打交道。所以我们更加要吃透浏览器，掌握它到底是怎样将我们编写的代码渲染到页面中的。\n\n所以，今天我主要结合浏览器的内部工作原理，深入剖析下浏览器中页面的渲染过程。\n\n第 6 讲我们介绍了一个 HTTP 请求在浏览器中的请求过程，该过程将浏览器作为单独的对象，描述客户端和服务端之间的通信过程。那么，当我们在浏览器的地址栏中输入 URL，按下回车键，到页面在浏览器中渲染完成，这个过程中浏览器的内部发生了什么了呢？\n\n为了了解这个过程，首先我们要了解浏览器的内部结构。\n\n\n浏览器的内部结构\n\n从结构上来说，浏览器主要包括了八个子系统：用户界面、浏览器引擎、渲染引擎、网络子系统、JavaScript 解释器、XML 解析器、显示后端、数据持久性子系统。\n\n\n\n这些子系统组合构成了我们的浏览器。页面的加载和渲染过程，离不开网络子系统、渲染引擎、JavaScript 解释器和浏览器引擎。\n\n以前端开发最常使用的 Chrome 浏览器为例， Chrome 浏览器是使用多进程架构的方式来管理这些子系统。\n\n\nChrome 多进程架构\n\nChrome 浏览器采用的多进程架构，主要包括四个进程：\n\n\n\n 1. 浏览器进程：选项卡之外的所有内容都由浏览器进程处理，浏览器进程则主要用于控制和处理用户可见的 UI 部分（包括地址栏，书签，后退和前进按钮）和用户不可见的隐藏部分（例如网络请求和文件访问）。\n\n 2. GPU 进程：该进程用于完成图像处理任务，同时还支持分解成多个进程进行处理。\n\n 3. 渲染器进程：Chrome 浏览器中支持多个选项卡，其中每个选项卡在单独的渲染器进程中运行，渲染器进程主要用于控制和处理选项卡中的网站内容显示。\n\n 4. 插件进程：管理 Chrome 浏览器中的各个插件。\n\n对于“在浏览器的地址栏中输入 URL，按下回车键，到浏览器渲染页面”这个过程，浏览器内部会通过浏览器进程和渲染器进程，进行很多交互逻辑，最终才得以将页面内容显示在屏幕上。\n\n其中，浏览器进程和渲染器进程同样支持多线程，包括以下这些线程。\n\n\n\n\n这些线程其实并不陌生，在前面介绍的内容中有提到，比如：\n\n * 在页面的加载过程中，涉及 GUI 渲染线程与 JavaScript 引擎线程间的互斥关系，因此页面中的<script>和<style>元素设计不合理会影响页面加载速度；\n\n * 在 UI 线程、网络线程、存储线程、浏览器事件触发线程、浏览器定时器触发线程中，I/O 事件通过异步任务完成时触发的函数回调，解决了单线程的 Javascript 阻塞问题。\n\n下面我们再来看下 Chrome 浏览器中页面的渲染过程，包括浏览器进程和线程如何通信来显示页面。\n\n\n浏览器中页面的渲染过程\n\n首先我们将浏览器中页面的渲染过程分为两部分。\n\n * 页面导航：用户输入 URL，浏览器进程进行请求和准备处理。\n\n * 页面渲染：获取到相关资源后，渲染器进程负责选项卡内部的渲染处理。\n\n1. 页面导航过程\n\n当用户在地址栏中输入内容时，浏览器内部会进行以下处理。\n\n 1. 首先浏览器进程的 UI 线程会进行处理：如果是 URI，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。\n\n 2. 如果需要发起网络请求，请求过程由网络线程来完成。HTTP 请求响应如果是 HTML 文件，则将数据传递到渲染器进程；如果是其他文件则意味着这是下载请求，此时会将数据传递到下载管理器。\n\n 3. 如果请求响应为 HTML 内容，此时浏览器应导航到请求站点，网络线程便通知 UI 线程数据准备就绪。\n\n 4. 接下来，UI 线程会寻找一个渲染器进程来进行网页渲染。当数据和渲染器进程都准备好后，HTML 数据通过 IPC 从浏览器进程传递到渲染器进程中。\n\n 5. 渲染器进程接收 HTML 数据后，将开始加载资源并渲染页面。\n\n 6. 渲染器进程完成渲染后，通过 IPC 通知浏览器进程页面已加载。\n\n以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。为了方便理解，我帮你梳理了一个流程图：\n\n\n\n如果当前页面跳转到其他网站，浏览器将调用一个单独的渲染进程来处理新导航，同时保留当前渲染进程来处理像unload这类事件。\n\n在上面的过程中可以看到，页面导航主要依赖浏览器进程。其中，上述过程中的步骤 5 便是页面的渲染部分，该过程同样依赖渲染器进程，我们一起来看看。\n\n2. 页面渲染过程\n\n前面说过，渲染器进程负责选项卡内部发生的所有事情，它的核心工作是将 HTML、CSS 和 JavaScript 转换为可交互的页面。\n\n整体上，渲染器进程渲染页面的流程基本如下。\n\n * 解析(Parser)：解析 HTML/CSS/JavaScript 代码。\n\n * 布局(Layout)：定位坐标和大小、是否换行、各种position/overflow/z-index属性等计算。\n\n * 绘制(Paint)：判断元素渲染层级顺序。\n\n * 光栅化(Raster)：将计算后的信息转换为屏幕上的像素。\n\n大致流程如下图：\n\n\n\n我们来分别看下。\n\n1. 解析。\n\n渲染器进程的主线程会解析以下内容：\n\n * 解析 HTML 内容，产生一个 DOM 节点树；\n\n * 解析 CSS，产生 CSS 规则树；\n\n * 解析 Javascript 脚本，由于 Javascript 脚本可以通过 DOM API 和 CSSOM API 来操作 DOM 节点树和 CSS 规则树，因此该过程中会等待 JavaScript 运行完成才继续解析 HTML。\n\n\n\n解析完成后，我们得到了 DOM 节点树和 CSS 规则树，布局过程便是通过 DOM 节点树和 CSS 规则树来构造渲染树（Render Tree）。\n\n2. 布局。\n\n通过解析之后，渲染器进程知道每个节点的结构和样式，但如果需要渲染页面，浏览器还需要进行布局，布局过程便是我们常说的渲染树的创建过程。\n\n在这个过程中，像header或display:none的元素，它们会存在 DOM 节点树中，但不会被添加到渲染树里。\n\n\n\n布局完成后，将会进入绘制环节。\n\n3. 绘制\n\n在绘制步骤中，渲染器主线程会遍历渲染树来创建绘制记录。\n\n需要注意的是，如果渲染树发生了改变，则渲染器会触发重绘（Repaint）和重排（Reflow）。\n\n * 重绘：屏幕的一部分要重画，比如某个 CSS 的背景色变了，但是元素的几何尺寸没有变。\n\n * 重排：元素的几何尺寸变了（渲染树的一部分或全部发生了变化），需要重新验证并计算渲染树。\n\n为了不对每个小的变化都进行完整的布局计算，渲染器会将更改的元素和它的子元素进行脏位标记，表示该元素需要重新布局。其中，全局样式更改会触发全局布局，部分样式或元素更改会触发增量布局，增量布局是异步完成的，全局布局则会同步触发。\n\n重排需要涉及变更的所有的结点几何尺寸和位置，成本比重绘的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 DOM 结点、移动 DOM 的位置、Resize 窗口、滚动等操作，因为这些操作可能会导致性能降低。\n\n4. 光栅化\n\n通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些信息转换为屏幕上的像素，这个过程被称为光栅化。\n\n光栅化可以被 GPU 加速，光栅化后的位图会被存储在 GPU 内存中。根据前面介绍的渲染流程，当页面布局变更了会触发重排和重绘，还需要重新进行光栅化。此时如果页面中有动画，则主线程中过多的计算任务很可能会影响动画的性能。\n\n因此，现代的浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片），并通过合成器线程进行页面的合成。\n\n\n\n合成过程如下：\n\n 1. 当主线程创建了合成层并确定了绘制顺序，便将这些信息提交给合成线程；\n\n 2. 合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程；\n\n 3. 光栅线程栅格化每个瓦片，并将它们存储在 GPU 内存中；\n\n 4. 合成器线程通过 IPC 提交给浏览器进程，这些合成器帧被发送到 GPU 进程处理，并显示在屏幕上。\n\n\n\n合成的真正目的是，在移动合成层的时候不用重新光栅化。因为有了合成器线程，页面才可以独立于主线程进行流畅的滚动。\n\n到这里，页面才真正渲染到屏幕上。\n\n我们在绘制页面的时候，也可能会遇到很多奇怪的渲染问题，比如使用了transform:scale可能会导致某些浏览器中渲染模糊，究其原因则是由于光栅化过程导致的。像前面所说，前端开发需要频繁跟浏览器打交道，所谓知己知彼百战不殆，我们应该对其运行过程有更好的了解。\n\n\n小结\n\n今天我主要介绍了浏览器的组成，可分为用户界面、浏览器引擎、渲染引擎、网络子系统、JavaScript 解释器、XML 解析器、显示后端、数据持久性子系统八个子系统，并以 Chrome 浏览器为例，从浏览器内部分工角度来介绍页面的渲染过程。\n\n掌握页面的渲染过程，有利于我们进行一些性能优化，尤其如果涉及动画、游戏等频繁绘制的场景，渲染性能往往是需要不断进行优化的瓶颈。\n\n今日小作业：\n\n 1. 你认为 Chrome 浏览器中，为什么每个选项卡都在单独的渲染器进程中运行呢？\n\n 2. 如何检测页面是否无响应呢？\n\n把你的想法写在留言区吧！\n\n----------------------------------------\n\n\n# 精选评论\n\n# **2279：\n\n> 老师，看其它的一些关于浏览器渲染过程，都是将渲染树的构建看成是一个独立的阶段呢。看了你的渲染过程不由得让我产生了究竟是渲染树的构建是和布局阶段一起的呢，还是说独立的怀疑，望指正。😅\n\n#     讲师回复：\n\n>     文中介绍渲染过程，主要分为：解析(Parser)、布局(Layout)、绘制(Paint)、光栅化(Raster) 四个过程，渲染树的构建属于布局过程，应该写得比较清楚了，请问你的疑问是？\n\n# **华：\n\n> 老师，是不是分层后，浏览器就能够只渲染某一层的内容，提升效率\n\n#     讲师回复：\n\n>     分层的使用场景很多是一些动画效果，比如 transform 和 opacity 的使用，它们只更改影响合成的属性，不会导致重新计算和布局，会让渲染更加流畅\n\n# **你辣条就跑：\n\n> 老师，检测页面是否无响应的使用场景可以说下吗？\n\n#     讲师回复：\n\n>     可以使用 service worker 对页面进行心跳检测，当心跳断开之后就可以认为页面崩溃/无响应，将相关信息做上报就可以监测的\n\n# **哈：\n\n> 现代浏览器架构网络独立成一个进程了，所以打开一个tab至少包含四个进程：浏览器主进程、渲染进程、网络进程、GPU进程。关于插件，一个插件开启一个进程。\n\n# **4344：\n\n> 老师，您好！我看在栅格化之后进行合成，文中提到了合成线程和光栅线程。请问这两个线程是属于哪个进程呢？\n\n#     讲师回复：\n\n>     合成器线程、光栅线程都运行在渲染器进程内部，从而高效，流畅地渲染页面。\n\n# **波：\n\n> 避免一个选项卡挂了，整个浏览器渲染进程挂了\n\n# **阳：\n\n> 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程，现在应该有五个进程了吧\n\n#     讲师回复：\n\n>     本文写作时是参照《Inside look at modern web browser》该官方文章来进行说明的，当时文章中介绍除了 GPU 进程、浏览器进程、渲染器进程、插件进程以外，还有实体进程和拓展程序进程。 如今，除了以上进程，Chrome 浏览器独立出来的进程还包括 Network、Storage、Audio 等等，如果你想查看 Chrome 中正在运行多少个进程，请点击浏览器右上角的选项菜单，选择“更多工具”，然后选择“任务管理器”，就可以查看了~\n\n# **洲：\n\n> 事件驱动使编写代码的流程更加清晰，但代码量大，维护相对困难，改变一处往往要牵涉好几处的更改数据驱动从应用程序中分离出视图和模型，代码量更少，今后如果要改变某些数据，只需改变对应模型层上的数据\n\n#     讲师回复：\n\n>     赞！\n\n# *聪：\n\n>  1. 每个选项卡都在单独的渲染器进程中运行是为了各个选项卡能保持独立互不干扰，防止因某一个选项卡崩溃导致所有页面都崩溃。2.检查页面无响应是不是可以利用事件循环相关，比如判断setTimeout中的回调是否被执行了，无响应的话，应该是主线程卡死，宏任务和微任务的事件都没有机会运行\n\n#     讲师回复：\n\n>     1. 没错。2. 当前页面无响应，是否可以考虑使用跨页面的技术来支持呢？比如 worker？（啊我竟然说出来了）",normalizedContent:"作为前端开发，我们的日常工作中除了编码以外，几乎大多数时间都在跟浏览器打交道。所以我们更加要吃透浏览器，掌握它到底是怎样将我们编写的代码渲染到页面中的。\n\n所以，今天我主要结合浏览器的内部工作原理，深入剖析下浏览器中页面的渲染过程。\n\n第 6 讲我们介绍了一个 http 请求在浏览器中的请求过程，该过程将浏览器作为单独的对象，描述客户端和服务端之间的通信过程。那么，当我们在浏览器的地址栏中输入 url，按下回车键，到页面在浏览器中渲染完成，这个过程中浏览器的内部发生了什么了呢？\n\n为了了解这个过程，首先我们要了解浏览器的内部结构。\n\n\n浏览器的内部结构\n\n从结构上来说，浏览器主要包括了八个子系统：用户界面、浏览器引擎、渲染引擎、网络子系统、javascript 解释器、xml 解析器、显示后端、数据持久性子系统。\n\n\n\n这些子系统组合构成了我们的浏览器。页面的加载和渲染过程，离不开网络子系统、渲染引擎、javascript 解释器和浏览器引擎。\n\n以前端开发最常使用的 chrome 浏览器为例， chrome 浏览器是使用多进程架构的方式来管理这些子系统。\n\n\nchrome 多进程架构\n\nchrome 浏览器采用的多进程架构，主要包括四个进程：\n\n\n\n 1. 浏览器进程：选项卡之外的所有内容都由浏览器进程处理，浏览器进程则主要用于控制和处理用户可见的 ui 部分（包括地址栏，书签，后退和前进按钮）和用户不可见的隐藏部分（例如网络请求和文件访问）。\n\n 2. gpu 进程：该进程用于完成图像处理任务，同时还支持分解成多个进程进行处理。\n\n 3. 渲染器进程：chrome 浏览器中支持多个选项卡，其中每个选项卡在单独的渲染器进程中运行，渲染器进程主要用于控制和处理选项卡中的网站内容显示。\n\n 4. 插件进程：管理 chrome 浏览器中的各个插件。\n\n对于“在浏览器的地址栏中输入 url，按下回车键，到浏览器渲染页面”这个过程，浏览器内部会通过浏览器进程和渲染器进程，进行很多交互逻辑，最终才得以将页面内容显示在屏幕上。\n\n其中，浏览器进程和渲染器进程同样支持多线程，包括以下这些线程。\n\n\n\n\n这些线程其实并不陌生，在前面介绍的内容中有提到，比如：\n\n * 在页面的加载过程中，涉及 gui 渲染线程与 javascript 引擎线程间的互斥关系，因此页面中的<script>和<style>元素设计不合理会影响页面加载速度；\n\n * 在 ui 线程、网络线程、存储线程、浏览器事件触发线程、浏览器定时器触发线程中，i/o 事件通过异步任务完成时触发的函数回调，解决了单线程的 javascript 阻塞问题。\n\n下面我们再来看下 chrome 浏览器中页面的渲染过程，包括浏览器进程和线程如何通信来显示页面。\n\n\n浏览器中页面的渲染过程\n\n首先我们将浏览器中页面的渲染过程分为两部分。\n\n * 页面导航：用户输入 url，浏览器进程进行请求和准备处理。\n\n * 页面渲染：获取到相关资源后，渲染器进程负责选项卡内部的渲染处理。\n\n1. 页面导航过程\n\n当用户在地址栏中输入内容时，浏览器内部会进行以下处理。\n\n 1. 首先浏览器进程的 ui 线程会进行处理：如果是 uri，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。\n\n 2. 如果需要发起网络请求，请求过程由网络线程来完成。http 请求响应如果是 html 文件，则将数据传递到渲染器进程；如果是其他文件则意味着这是下载请求，此时会将数据传递到下载管理器。\n\n 3. 如果请求响应为 html 内容，此时浏览器应导航到请求站点，网络线程便通知 ui 线程数据准备就绪。\n\n 4. 接下来，ui 线程会寻找一个渲染器进程来进行网页渲染。当数据和渲染器进程都准备好后，html 数据通过 ipc 从浏览器进程传递到渲染器进程中。\n\n 5. 渲染器进程接收 html 数据后，将开始加载资源并渲染页面。\n\n 6. 渲染器进程完成渲染后，通过 ipc 通知浏览器进程页面已加载。\n\n以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。为了方便理解，我帮你梳理了一个流程图：\n\n\n\n如果当前页面跳转到其他网站，浏览器将调用一个单独的渲染进程来处理新导航，同时保留当前渲染进程来处理像unload这类事件。\n\n在上面的过程中可以看到，页面导航主要依赖浏览器进程。其中，上述过程中的步骤 5 便是页面的渲染部分，该过程同样依赖渲染器进程，我们一起来看看。\n\n2. 页面渲染过程\n\n前面说过，渲染器进程负责选项卡内部发生的所有事情，它的核心工作是将 html、css 和 javascript 转换为可交互的页面。\n\n整体上，渲染器进程渲染页面的流程基本如下。\n\n * 解析(parser)：解析 html/css/javascript 代码。\n\n * 布局(layout)：定位坐标和大小、是否换行、各种position/overflow/z-index属性等计算。\n\n * 绘制(paint)：判断元素渲染层级顺序。\n\n * 光栅化(raster)：将计算后的信息转换为屏幕上的像素。\n\n大致流程如下图：\n\n\n\n我们来分别看下。\n\n1. 解析。\n\n渲染器进程的主线程会解析以下内容：\n\n * 解析 html 内容，产生一个 dom 节点树；\n\n * 解析 css，产生 css 规则树；\n\n * 解析 javascript 脚本，由于 javascript 脚本可以通过 dom api 和 cssom api 来操作 dom 节点树和 css 规则树，因此该过程中会等待 javascript 运行完成才继续解析 html。\n\n\n\n解析完成后，我们得到了 dom 节点树和 css 规则树，布局过程便是通过 dom 节点树和 css 规则树来构造渲染树（render tree）。\n\n2. 布局。\n\n通过解析之后，渲染器进程知道每个节点的结构和样式，但如果需要渲染页面，浏览器还需要进行布局，布局过程便是我们常说的渲染树的创建过程。\n\n在这个过程中，像header或display:none的元素，它们会存在 dom 节点树中，但不会被添加到渲染树里。\n\n\n\n布局完成后，将会进入绘制环节。\n\n3. 绘制\n\n在绘制步骤中，渲染器主线程会遍历渲染树来创建绘制记录。\n\n需要注意的是，如果渲染树发生了改变，则渲染器会触发重绘（repaint）和重排（reflow）。\n\n * 重绘：屏幕的一部分要重画，比如某个 css 的背景色变了，但是元素的几何尺寸没有变。\n\n * 重排：元素的几何尺寸变了（渲染树的一部分或全部发生了变化），需要重新验证并计算渲染树。\n\n为了不对每个小的变化都进行完整的布局计算，渲染器会将更改的元素和它的子元素进行脏位标记，表示该元素需要重新布局。其中，全局样式更改会触发全局布局，部分样式或元素更改会触发增量布局，增量布局是异步完成的，全局布局则会同步触发。\n\n重排需要涉及变更的所有的结点几何尺寸和位置，成本比重绘的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 dom 结点、移动 dom 的位置、resize 窗口、滚动等操作，因为这些操作可能会导致性能降低。\n\n4. 光栅化\n\n通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些信息转换为屏幕上的像素，这个过程被称为光栅化。\n\n光栅化可以被 gpu 加速，光栅化后的位图会被存储在 gpu 内存中。根据前面介绍的渲染流程，当页面布局变更了会触发重排和重绘，还需要重新进行光栅化。此时如果页面中有动画，则主线程中过多的计算任务很可能会影响动画的性能。\n\n因此，现代的浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片），并通过合成器线程进行页面的合成。\n\n\n\n合成过程如下：\n\n 1. 当主线程创建了合成层并确定了绘制顺序，便将这些信息提交给合成线程；\n\n 2. 合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程；\n\n 3. 光栅线程栅格化每个瓦片，并将它们存储在 gpu 内存中；\n\n 4. 合成器线程通过 ipc 提交给浏览器进程，这些合成器帧被发送到 gpu 进程处理，并显示在屏幕上。\n\n\n\n合成的真正目的是，在移动合成层的时候不用重新光栅化。因为有了合成器线程，页面才可以独立于主线程进行流畅的滚动。\n\n到这里，页面才真正渲染到屏幕上。\n\n我们在绘制页面的时候，也可能会遇到很多奇怪的渲染问题，比如使用了transform:scale可能会导致某些浏览器中渲染模糊，究其原因则是由于光栅化过程导致的。像前面所说，前端开发需要频繁跟浏览器打交道，所谓知己知彼百战不殆，我们应该对其运行过程有更好的了解。\n\n\n小结\n\n今天我主要介绍了浏览器的组成，可分为用户界面、浏览器引擎、渲染引擎、网络子系统、javascript 解释器、xml 解析器、显示后端、数据持久性子系统八个子系统，并以 chrome 浏览器为例，从浏览器内部分工角度来介绍页面的渲染过程。\n\n掌握页面的渲染过程，有利于我们进行一些性能优化，尤其如果涉及动画、游戏等频繁绘制的场景，渲染性能往往是需要不断进行优化的瓶颈。\n\n今日小作业：\n\n 1. 你认为 chrome 浏览器中，为什么每个选项卡都在单独的渲染器进程中运行呢？\n\n 2. 如何检测页面是否无响应呢？\n\n把你的想法写在留言区吧！\n\n----------------------------------------\n\n\n# 精选评论\n\n# **2279：\n\n> 老师，看其它的一些关于浏览器渲染过程，都是将渲染树的构建看成是一个独立的阶段呢。看了你的渲染过程不由得让我产生了究竟是渲染树的构建是和布局阶段一起的呢，还是说独立的怀疑，望指正。😅\n\n#     讲师回复：\n\n>     文中介绍渲染过程，主要分为：解析(parser)、布局(layout)、绘制(paint)、光栅化(raster) 四个过程，渲染树的构建属于布局过程，应该写得比较清楚了，请问你的疑问是？\n\n# **华：\n\n> 老师，是不是分层后，浏览器就能够只渲染某一层的内容，提升效率\n\n#     讲师回复：\n\n>     分层的使用场景很多是一些动画效果，比如 transform 和 opacity 的使用，它们只更改影响合成的属性，不会导致重新计算和布局，会让渲染更加流畅\n\n# **你辣条就跑：\n\n> 老师，检测页面是否无响应的使用场景可以说下吗？\n\n#     讲师回复：\n\n>     可以使用 service worker 对页面进行心跳检测，当心跳断开之后就可以认为页面崩溃/无响应，将相关信息做上报就可以监测的\n\n# **哈：\n\n> 现代浏览器架构网络独立成一个进程了，所以打开一个tab至少包含四个进程：浏览器主进程、渲染进程、网络进程、gpu进程。关于插件，一个插件开启一个进程。\n\n# **4344：\n\n> 老师，您好！我看在栅格化之后进行合成，文中提到了合成线程和光栅线程。请问这两个线程是属于哪个进程呢？\n\n#     讲师回复：\n\n>     合成器线程、光栅线程都运行在渲染器进程内部，从而高效，流畅地渲染页面。\n\n# **波：\n\n> 避免一个选项卡挂了，整个浏览器渲染进程挂了\n\n# **阳：\n\n> 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程，现在应该有五个进程了吧\n\n#     讲师回复：\n\n>     本文写作时是参照《inside look at modern web browser》该官方文章来进行说明的，当时文章中介绍除了 gpu 进程、浏览器进程、渲染器进程、插件进程以外，还有实体进程和拓展程序进程。 如今，除了以上进程，chrome 浏览器独立出来的进程还包括 network、storage、audio 等等，如果你想查看 chrome 中正在运行多少个进程，请点击浏览器右上角的选项菜单，选择“更多工具”，然后选择“任务管理器”，就可以查看了~\n\n# **洲：\n\n> 事件驱动使编写代码的流程更加清晰，但代码量大，维护相对困难，改变一处往往要牵涉好几处的更改数据驱动从应用程序中分离出视图和模型，代码量更少，今后如果要改变某些数据，只需改变对应模型层上的数据\n\n#     讲师回复：\n\n>     赞！\n\n# *聪：\n\n>  1. 每个选项卡都在单独的渲染器进程中运行是为了各个选项卡能保持独立互不干扰，防止因某一个选项卡崩溃导致所有页面都崩溃。2.检查页面无响应是不是可以利用事件循环相关，比如判断settimeout中的回调是否被执行了，无响应的话，应该是主线程卡死，宏任务和微任务的事件都没有机会运行\n\n#     讲师回复：\n\n>     1. 没错。2. 当前页面无响应，是否可以考虑使用跨页面的技术来支持呢？比如 worker？（啊我竟然说出来了）",charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"重识 HTML，掌握页面基本结构和加载过程",frontmatter:{title:"重识 HTML，掌握页面基本结构和加载过程",date:"2022-04-14T22:48:00.000Z",permalink:"/pages/86005a/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/01.%E9%87%8D%E8%AF%86%20HTML%EF%BC%8C%E6%8E%8C%E6%8F%A1%E9%A1%B5%E9%9D%A2%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html",relativePath:"01.前端/01.前端开发笔记/01.重识 HTML，掌握页面基本结构和加载过程.md",key:"v-b781da14",path:"/pages/86005a/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:6041}],headersStr:"精选评论",content:'对于前端开发者来说，不管是对初学者还是已独当一面的资深前端开发者，HTML 都是最基础的内容。\n\n今天，我主要介绍 HTML 和网页有什么关系，以及与 DOM 有什么不同。通过本讲内容，你将掌握浏览器是怎么处理 HTML 内容的，以及在这个过程中我们可以进行怎样的处理来提升网页的性能，从而提升用户的体验。\n\n\n浏览器页面加载过程\n\n不知你是否有过这样的体验：当打开某个浏览器的时候，发现一直在转圈，或者等了好长时间才打开页面……\n\n此时的你，会选择关掉页面还是耐心等待呢？\n\n这一现象，除了网络不稳定、网速过慢等原因，大多数都是由于页面设计不合理导致加载时间过长导致的。\n\n我们都知道，页面是用 HTML/CSS/JavaScript 来编写的。\n\n> 其中，HTML 的职责在于告知浏览器如何组织页面，以及搭建页面的基本结构；\n> CSS 用来装饰 HTML，让我们的页面更好看；\n> JavaScript 则可以丰富页面功能，使静态页面动起来。\n\nHTML由一系列的元素组成，通常称为HTML元素。HTML 元素通常被用来定义一个网页结构，基本上所有网页都是这样的 HTML 结构：\n\n<html>\n  <head></head>\n  <body></body>\n</html>\n\n\n其中：\n\n * <html>元素是页面的根元素，它描述完整的网页；\n\n * <head>元素包含了我们想包含在 HTML 页面中，但不希望显示在网页里的内容；\n\n * <body>元素包含了我们访问页面时所有显示在页面上的内容，是用户最终能看到的内容。\n\nHTML 中的元素特别多，其中还包括可用于 Web Components 的自定义元素。\n\n前面我们提到页面 HTML 结构不合理可能会导致页面响应慢，这个过程很多时候体现在<script>和<style>元素的设计上，它们会影响页面加载过程中对 Javascript 和 CSS 代码的处理。\n\n因此，如果想要提升页面的加载速度，就需要了解浏览器页面的加载过程是怎样的，从根本上来解决问题。\n\n浏览器在加载页面的时候会用到 GUI 渲染线程和 JavaScript 引擎线程（更详细的浏览器加载和渲染机制将在第 7 讲中介绍）。其中，GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。\n\n由于 JavaScript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 JavaScript 引擎执行时，GUI 线程会被挂起。\n\n以拉勾官网为例，我们来看看网页加载流程。\n\n（1）当我们打开拉勾官网的时候，浏览器会从服务器中获取到 HTML 内容。\n\n（2）浏览器获取到 HTML 内容后，就开始从上到下解析 HTML 的元素。\n\n\n\n从上到下解析 HTML 元素图\n\n（3）<head>元素内容会先被解析，此时浏览器还没开始渲染页面。\n\n> 我们看到<head>元素里有用于描述页面元数据的<meta>元素，还有一些<link>元素涉及外部资源（如图片、CSS 样式等），此时浏览器会去获取这些外部资源。\n> 除此之外，我们还能看到<head>元素中还包含着不少的<script>元素，这些<script>元素通过src属性指向外部资源。\n\n（4）当浏览器解析到这里时（步骤 3），会暂停解析并下载 JavaScript 脚本。\n\n（5）当 JavaScript 脚本下载完成后，浏览器的控制权转交给 JavaScript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 HTML 页面。\n\n（6）此时<body>元素内容开始被解析，浏览器开始渲染页面。\n\n在这个过程中，我们看到<head>中放置的<script>元素会阻塞页面的渲染过程：把 JavaScript 放在<head>里，意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面。\n\n到这里，我们就明白了：如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕。\n\n因此，对于对性能要求较高、需要快速将内容呈现给用户的网页，常常会将 JavaScript 脚本放在<body>的最后面。这样可以避免资源阻塞，页面得以迅速展示。我们还可以使用defer/async/preload等属性来标记<script>标签，来控制 JavaScript 的加载顺序。\n\n我们再来看看百度首页。\n\n\n\n百度首页 HTML 元素图\n\n可以看到，虽然百度首页的<head>元素里也包括了一些<script>元素，但大多数都加上了async属性。async属性会让这些脚本并行进行请求获取资源，同时当资源获取完成后尽快解析和执行，这个过程是异步的，不会阻塞 HTML 的解析和渲染。\n\n对于百度这样的搜索引擎来说，必须要在最短的时间内提供到可用的服务给用户，其中就包括搜索框的显示及可交互，除此之外的内容优先级会相对较低。\n\n浏览器在渲染页面的过程需要解析 HTML、CSS 以得到 DOM 树和 CSS 规则树，它们结合后才生成最终的渲染树并渲染。因此，我们还常常将 CSS 放在<head>里，可用来避免浏览器渲染的重复计算。\n\n\nHTML 与 DOM 有什么不同\n\n我们知道<p>是 HTML 元素，但又常常将<p>这样一个元素称为 DOM 节点，那么 HTML 和 DOM 到底有什么不一样呢？\n\n根据 MDN 官方描述：文档对象模型（DOM）是 HTML 和 XML 文档的编程接口。\n\n也就是说，DOM 是用来操作和描述 HTML 文档的接口。如果说浏览器用 HTML 来描述网页的结构并渲染，那么使用 DOM 则可以获取网页的结构并进行操作。一般来说，我们使用 JavaScript 来操作 DOM 接口，从而实现页面的动态变化，以及用户的交互操作。\n\n在开发过程中，常常用对象的方式来描述某一类事物，用特定的结构集合来描述某些事物的集合。DOM 也一样，它将 HTML 文档解析成一个由 DOM 节点以及包含属性和方法的相关对象组成的结构集合。\n\n比如这里，我们在拉勾官网中检查滚动控制面板的元素，如下图所示：\n\n\n\n控制台元素检查示意图\n\n可以在控制台中获取到该滚动控制面板对应的 DOM 节点，通过右键保存到临时变量后，便可以在 console 面板中通过 DOM 接口获取该节点的信息，或者进行一些修改节点的操作，如下图所示：\n\n\n\n控制台 DOM 对象操作示意图\n\n我们来看看，浏览器中的 HTML 是怎样被解析成 DOM 的。\n\nDOM 解析\n\n我们常见的 HTML 元素，在浏览器中会被解析成节点。比如下面这样的 HTML 内容：\n\n<html>\n  <head>\n    <title>文档标题</title>\n  </head>\n  <body>\n    <a href="xx.com/xx">我的链接</a>\n    <h1>我的标题</h1>\n  </body>\n</html>\n\n\n打开控制台 Elements 面板，可以看到这样的 HTML 结构，如下图所示：\n\n\n\n控制台查看 HTML 元素图\n\n在浏览器中，上面的 HTML 会被解析成这样的 DOM 树，如下图所示：\n\n\n\nDOM 树示意图\n\n我们都知道，对于树状结构来说，常常使用parent/child/sibling等方式来描述各个节点之间的关系，对于 DOM 树也不例外。或许对于很多前端开发者来说，“DOM 是树状结构”已经是个过于基础的认识，因此我们也常常忽略掉开发过程中对它的依赖程度。\n\n举个例子，我们常常会对页面功能进行抽象，并封装成组件。但不管怎么进行整理，页面最终依然是基于 DOM 的树状结构，因此组件也是呈树状结构，组件间的关系也同样可以使用parent/child/sibling这样的方式来描述。\n\n同时，现在大多数应用程序同样以root为根节点展开，我们进行状态管理、数据管理也常常会呈现出树状结构，这在 Angular.js 升级到 Angular 的过程中也有所体现。Angular 增加了树状结构的模块化设计，不管是脏检查机制，还是依赖注入的管理，都由于这样的调整提升了性能、降低了模块间的耦合程度。\n\n操作 DOM\n\n除了获取 DOM 结构以外，通过 HTML DOM 相关接口，我们还可以使用 JavaScript 来访问 DOM 树中的节点，也可以创建或删除节点。比如我们想在上面的滚动控制面板中删除一个播放子列，可以这么操作：\n\n// 获取到 class 为 swiper-control 的第一个节点，这里得到我们的滚动控制面板\nconst controlPanel = document.getElementsByClassName("swiper-control")[0];\n// 获取滚动控制面板的第一个子节点\n// 这里是“就业率口碑训练营限时抄底”文本所在的子列\nconst firstChild = controlPanel.firstElementChild;\n// 删除滚动控制面板的子节点\ncontrolPanel.removeChild(firstChild);\n\n\n操作之后，我们能看到节点被顺利删除，如下图所示：\n\n\n\nDOM 节点删除后示意图\n\n随着应用程序越来越复杂，DOM 操作越来越频繁，需要监听事件和在事件回调更新页面的 DOM 操作也越来越多，频繁的 DOM 操作会导致页面频繁地进行计算和渲染，导致不小的性能开销。于是虚拟 DOM 的想法便被人提出，并在许多框架中都有实现。\n\n虚拟 DOM 其实是用来模拟真实 DOM 的中间产物，它的设计大致可分成 3 个过程：\n\n 1. 用 JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树；\n\n 2. 当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异；\n\n 3. 把差异应用到真正的 DOM 树上。\n\n后面我在介绍前端框架时，会更详细地介绍虚拟 DOM 部分的内容。\n\n事件委托\n\n我们知道，浏览器中各个元素从页面中接收事件的顺序包括事件捕获阶段、目标阶段、事件冒泡阶段。其中，基于事件冒泡机制，我们可以实现将子元素的事件委托给父级元素来进行处理，这便是事件委托。\n\n在拉勾官网上，我们需要监听滚动控制面板中的几个文本被点击，从而控制广告面板的展示内容，如下图所示：\n\n\n\n滚动控制面板 DOM 结构示意图\n\n如果我们在每个元素上都进行监听的话，则需要绑定三个事件。\n\nfunction clickEventFunction(e) {\n  console.log(e.target === this); // logs `true`\n  // 这里可以用 this 获取当前元素\n  // 此处控制广告面板的展示内容\n}\n// 元素2、5、8绑定\nelement2.addEventListener("click", clickEventFunction, false);\nelement5.addEventListener("click", clickEventFunction, false);\nelement8.addEventListener("click", clickEventFunction, false);\n\n\n使用事件委托，可以通过将事件添加到它们的父节点，而将事件委托给父节点来触发处理函数：\n\nfunction clickEventFunction(event) {\n  console.log(e.target === this); // logs `false`\n  // 获取被点击的元素\n  const eventTarget = event.target;\n  // 检查源元素`event.target`是否符合预期\n  // 此处控制广告面板的展示内容\n}\n// 元素1绑定\nelement1.addEventListener("click", clickEventFunction, false);\n\n\n这样能解决什么问题呢？\n\n * 绑定子元素会绑定很多次的事件，而绑定父元素只需要一次绑定。\n\n * 将事件委托给父节点，这样我们对子元素的增加和删除、移动等，都不需要重新进行事件绑定。\n\n常见的使用方式主要是上述这种列表结构，每个选项都可以进行编辑、删除、添加标签等功能，而把事件委托给父元素，不管我们新增、删除、更新选项，都不需要手动去绑定和移除事件。\n\n如果在列表数量内容较大的时候，对成千上万节点进行事件监听，也是不小的性能消耗。使用事件委托的方式，我们可以大量减少浏览器对元素的监听，也是在前端性能优化中比较简单和基础的一个做法。\n\n需要注意的是，如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。\n\n如果我们document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用passive: true选项来解决。\n\n\n小结\n\n关于 HTML，我今天侧重讲了 HTML 的作用，以及它是如何影响浏览器中页面的加载过程的，同时还介绍了使用 DOM 接口来控制 HTML 的展示和功能逻辑。\n\n很多时候，我们对一些基础内容也都需要不定期地进行复习。古人云“温故而知新”，一些原本认为已经固化的认知，在重新学习的过程中，或许你可以得到新的理解。比如，虚拟 DOM 的设计其实参考了网页中 DOM 设计的很多地方（树状结构、DOM 属性），却又通过简化、新旧对比的方式巧妙地避开了容易出现性能瓶颈的地方，从而提升了页面渲染的性能。\n\n再比如，很多前端框架在监测数据变更的时候采用了树状结构（Angular 2.0+、Vue 3.0+），也是因为即使我们对应用进行了模块化、组件化，最终它在浏览器页面中的呈现和组织方式也依然是树状的，而树状的方式也很好地避免了循环依赖的问题。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **洲：\n\n> HTML是web开发的基石，用于告诉浏览器如何组织页面的方式，浏览器会根据实际HTML的内容生成一棵树，就是DOM树，可以通过JavaScript访问这颗树来对页面进行更多额外的操作\n\n# **萍：\n\n> 请问: document.body添加事件委托，每次触发事件时，会产生生等待，为什么会产生等待？passive: true的作用是什么？\n\n#     讲师回复：\n\n>     产生等待是因为合成器线程于主线程进行通信。passive 设置为 true 时，表示 listener 永远不会调用 preventDefault。根据规范，passive 选项的默认值始终为 false，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。\n\n# *聪：\n\n> 老师，CSS会阻塞渲染吗？是CSSOM树构建完成之后，页面才开始渲染的吗？\n\n#     讲师回复：\n\n>     页面渲染会解析HTML和CSS，生成 DOM Tree 和 CSS Rule Tree，两者结合生成渲染树。最终渲染在页面中的便是渲染树，所以为了避免页面重新渲染，CSS应该放在 header 里哦~更详细的我们会在第 8 讲中进行介绍~\n\n# *聪：\n\n> 事件委托的第二个例子：【console.log(e.target === this);】应该为【console.log(event.target === this);】\n\n#     编辑回复：\n\n>     get\n\n# **8635：\n\n> 虚拟dom和实际dom之间是怎么更新替换的，怎么做到页面不会被重新渲染或者局部渲染的呢？\n\n#     讲师回复：\n\n>     其实我们会在第10讲中有比较详细的介绍，这里给点提示：我们平时操作 DOM 的方式有哪些呢？\n\n# **4829：\n\n> 最后一段关于document.body进行事件委托的，不是很明白，能解释一下么？\n\n#     讲师回复：\n\n>     使用 document.body 添加事件委托，每次触发事件时，会产生生等待，产生等待是因为合成器线程于主线程进行通信。passive 设置为 true 时，表示 listener 永远不会调用 preventDefault。根据规范，passive 选项的默认值始终为 false，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。\n\n# **4344：\n\n> 请问对于事件委托不能绑定在body上，还是有点不在明白？passitive是哪个上面的属性呢？我看评论回答这个问题也没怎么明白，还请老师再回复一下，谢谢😀\n\n#     讲师回复：\n\n>     passive 是事件绑定的一个参数，可以看看 addEventListener() 这个API~\n\n# **东：\n\n> React17版本的事件委托就有所修改，从原来的html到React.createElement的根元素上，这个修改的原因和都是上述所说的是不是有相同的原因。还有是个人觉得老师你读讲的语速有点快了，比如有图解的东西可以停一点点吗？，\n\n#     讲师回复：\n\n>     收到~我会努力的\n\n# **蓉：\n\n> 合成层具体是什么，不是很明白\n\n#     讲师回复：\n\n>     合成又称为 Compositing，在现代浏览器渲染过程中，会将将页面的各个部分分成多个层，分别对其进行栅格化并进行合成。这部分内容我们会在第 8 讲中有介绍哦\n\n# *聪：\n\n> HTML的规范中指明defer属性的脚本是异步下载的，等到页面解析完成后按顺序执行，但是实际上浏览器并不保证顺序执行，所以页面中多个脚本有依赖关系的不要使用defer，平时最好只设置一个defer脚本\n\n#     讲师回复：\n\n>     棒~',normalizedContent:'对于前端开发者来说，不管是对初学者还是已独当一面的资深前端开发者，html 都是最基础的内容。\n\n今天，我主要介绍 html 和网页有什么关系，以及与 dom 有什么不同。通过本讲内容，你将掌握浏览器是怎么处理 html 内容的，以及在这个过程中我们可以进行怎样的处理来提升网页的性能，从而提升用户的体验。\n\n\n浏览器页面加载过程\n\n不知你是否有过这样的体验：当打开某个浏览器的时候，发现一直在转圈，或者等了好长时间才打开页面……\n\n此时的你，会选择关掉页面还是耐心等待呢？\n\n这一现象，除了网络不稳定、网速过慢等原因，大多数都是由于页面设计不合理导致加载时间过长导致的。\n\n我们都知道，页面是用 html/css/javascript 来编写的。\n\n> 其中，html 的职责在于告知浏览器如何组织页面，以及搭建页面的基本结构；\n> css 用来装饰 html，让我们的页面更好看；\n> javascript 则可以丰富页面功能，使静态页面动起来。\n\nhtml由一系列的元素组成，通常称为html元素。html 元素通常被用来定义一个网页结构，基本上所有网页都是这样的 html 结构：\n\n<html>\n  <head></head>\n  <body></body>\n</html>\n\n\n其中：\n\n * <html>元素是页面的根元素，它描述完整的网页；\n\n * <head>元素包含了我们想包含在 html 页面中，但不希望显示在网页里的内容；\n\n * <body>元素包含了我们访问页面时所有显示在页面上的内容，是用户最终能看到的内容。\n\nhtml 中的元素特别多，其中还包括可用于 web components 的自定义元素。\n\n前面我们提到页面 html 结构不合理可能会导致页面响应慢，这个过程很多时候体现在<script>和<style>元素的设计上，它们会影响页面加载过程中对 javascript 和 css 代码的处理。\n\n因此，如果想要提升页面的加载速度，就需要了解浏览器页面的加载过程是怎样的，从根本上来解决问题。\n\n浏览器在加载页面的时候会用到 gui 渲染线程和 javascript 引擎线程（更详细的浏览器加载和渲染机制将在第 7 讲中介绍）。其中，gui 渲染线程负责渲染浏览器界面 html 元素，javascript 引擎线程主要负责处理 javascript 脚本程序。\n\n由于 javascript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 javascript 引擎执行时，gui 线程会被挂起。\n\n以拉勾官网为例，我们来看看网页加载流程。\n\n（1）当我们打开拉勾官网的时候，浏览器会从服务器中获取到 html 内容。\n\n（2）浏览器获取到 html 内容后，就开始从上到下解析 html 的元素。\n\n\n\n从上到下解析 html 元素图\n\n（3）<head>元素内容会先被解析，此时浏览器还没开始渲染页面。\n\n> 我们看到<head>元素里有用于描述页面元数据的<meta>元素，还有一些<link>元素涉及外部资源（如图片、css 样式等），此时浏览器会去获取这些外部资源。\n> 除此之外，我们还能看到<head>元素中还包含着不少的<script>元素，这些<script>元素通过src属性指向外部资源。\n\n（4）当浏览器解析到这里时（步骤 3），会暂停解析并下载 javascript 脚本。\n\n（5）当 javascript 脚本下载完成后，浏览器的控制权转交给 javascript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 html 页面。\n\n（6）此时<body>元素内容开始被解析，浏览器开始渲染页面。\n\n在这个过程中，我们看到<head>中放置的<script>元素会阻塞页面的渲染过程：把 javascript 放在<head>里，意味着必须把所有 javascript 代码都下载、解析和解释完成后，才能开始渲染页面。\n\n到这里，我们就明白了：如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕。\n\n因此，对于对性能要求较高、需要快速将内容呈现给用户的网页，常常会将 javascript 脚本放在<body>的最后面。这样可以避免资源阻塞，页面得以迅速展示。我们还可以使用defer/async/preload等属性来标记<script>标签，来控制 javascript 的加载顺序。\n\n我们再来看看百度首页。\n\n\n\n百度首页 html 元素图\n\n可以看到，虽然百度首页的<head>元素里也包括了一些<script>元素，但大多数都加上了async属性。async属性会让这些脚本并行进行请求获取资源，同时当资源获取完成后尽快解析和执行，这个过程是异步的，不会阻塞 html 的解析和渲染。\n\n对于百度这样的搜索引擎来说，必须要在最短的时间内提供到可用的服务给用户，其中就包括搜索框的显示及可交互，除此之外的内容优先级会相对较低。\n\n浏览器在渲染页面的过程需要解析 html、css 以得到 dom 树和 css 规则树，它们结合后才生成最终的渲染树并渲染。因此，我们还常常将 css 放在<head>里，可用来避免浏览器渲染的重复计算。\n\n\nhtml 与 dom 有什么不同\n\n我们知道<p>是 html 元素，但又常常将<p>这样一个元素称为 dom 节点，那么 html 和 dom 到底有什么不一样呢？\n\n根据 mdn 官方描述：文档对象模型（dom）是 html 和 xml 文档的编程接口。\n\n也就是说，dom 是用来操作和描述 html 文档的接口。如果说浏览器用 html 来描述网页的结构并渲染，那么使用 dom 则可以获取网页的结构并进行操作。一般来说，我们使用 javascript 来操作 dom 接口，从而实现页面的动态变化，以及用户的交互操作。\n\n在开发过程中，常常用对象的方式来描述某一类事物，用特定的结构集合来描述某些事物的集合。dom 也一样，它将 html 文档解析成一个由 dom 节点以及包含属性和方法的相关对象组成的结构集合。\n\n比如这里，我们在拉勾官网中检查滚动控制面板的元素，如下图所示：\n\n\n\n控制台元素检查示意图\n\n可以在控制台中获取到该滚动控制面板对应的 dom 节点，通过右键保存到临时变量后，便可以在 console 面板中通过 dom 接口获取该节点的信息，或者进行一些修改节点的操作，如下图所示：\n\n\n\n控制台 dom 对象操作示意图\n\n我们来看看，浏览器中的 html 是怎样被解析成 dom 的。\n\ndom 解析\n\n我们常见的 html 元素，在浏览器中会被解析成节点。比如下面这样的 html 内容：\n\n<html>\n  <head>\n    <title>文档标题</title>\n  </head>\n  <body>\n    <a href="xx.com/xx">我的链接</a>\n    <h1>我的标题</h1>\n  </body>\n</html>\n\n\n打开控制台 elements 面板，可以看到这样的 html 结构，如下图所示：\n\n\n\n控制台查看 html 元素图\n\n在浏览器中，上面的 html 会被解析成这样的 dom 树，如下图所示：\n\n\n\ndom 树示意图\n\n我们都知道，对于树状结构来说，常常使用parent/child/sibling等方式来描述各个节点之间的关系，对于 dom 树也不例外。或许对于很多前端开发者来说，“dom 是树状结构”已经是个过于基础的认识，因此我们也常常忽略掉开发过程中对它的依赖程度。\n\n举个例子，我们常常会对页面功能进行抽象，并封装成组件。但不管怎么进行整理，页面最终依然是基于 dom 的树状结构，因此组件也是呈树状结构，组件间的关系也同样可以使用parent/child/sibling这样的方式来描述。\n\n同时，现在大多数应用程序同样以root为根节点展开，我们进行状态管理、数据管理也常常会呈现出树状结构，这在 angular.js 升级到 angular 的过程中也有所体现。angular 增加了树状结构的模块化设计，不管是脏检查机制，还是依赖注入的管理，都由于这样的调整提升了性能、降低了模块间的耦合程度。\n\n操作 dom\n\n除了获取 dom 结构以外，通过 html dom 相关接口，我们还可以使用 javascript 来访问 dom 树中的节点，也可以创建或删除节点。比如我们想在上面的滚动控制面板中删除一个播放子列，可以这么操作：\n\n// 获取到 class 为 swiper-control 的第一个节点，这里得到我们的滚动控制面板\nconst controlpanel = document.getelementsbyclassname("swiper-control")[0];\n// 获取滚动控制面板的第一个子节点\n// 这里是“就业率口碑训练营限时抄底”文本所在的子列\nconst firstchild = controlpanel.firstelementchild;\n// 删除滚动控制面板的子节点\ncontrolpanel.removechild(firstchild);\n\n\n操作之后，我们能看到节点被顺利删除，如下图所示：\n\n\n\ndom 节点删除后示意图\n\n随着应用程序越来越复杂，dom 操作越来越频繁，需要监听事件和在事件回调更新页面的 dom 操作也越来越多，频繁的 dom 操作会导致页面频繁地进行计算和渲染，导致不小的性能开销。于是虚拟 dom 的想法便被人提出，并在许多框架中都有实现。\n\n虚拟 dom 其实是用来模拟真实 dom 的中间产物，它的设计大致可分成 3 个过程：\n\n 1. 用 javascript 对象模拟 dom 树，得到一棵虚拟 dom 树；\n\n 2. 当页面数据变更时，生成新的虚拟 dom 树，比较新旧两棵虚拟 dom 树的差异；\n\n 3. 把差异应用到真正的 dom 树上。\n\n后面我在介绍前端框架时，会更详细地介绍虚拟 dom 部分的内容。\n\n事件委托\n\n我们知道，浏览器中各个元素从页面中接收事件的顺序包括事件捕获阶段、目标阶段、事件冒泡阶段。其中，基于事件冒泡机制，我们可以实现将子元素的事件委托给父级元素来进行处理，这便是事件委托。\n\n在拉勾官网上，我们需要监听滚动控制面板中的几个文本被点击，从而控制广告面板的展示内容，如下图所示：\n\n\n\n滚动控制面板 dom 结构示意图\n\n如果我们在每个元素上都进行监听的话，则需要绑定三个事件。\n\nfunction clickeventfunction(e) {\n  console.log(e.target === this); // logs `true`\n  // 这里可以用 this 获取当前元素\n  // 此处控制广告面板的展示内容\n}\n// 元素2、5、8绑定\nelement2.addeventlistener("click", clickeventfunction, false);\nelement5.addeventlistener("click", clickeventfunction, false);\nelement8.addeventlistener("click", clickeventfunction, false);\n\n\n使用事件委托，可以通过将事件添加到它们的父节点，而将事件委托给父节点来触发处理函数：\n\nfunction clickeventfunction(event) {\n  console.log(e.target === this); // logs `false`\n  // 获取被点击的元素\n  const eventtarget = event.target;\n  // 检查源元素`event.target`是否符合预期\n  // 此处控制广告面板的展示内容\n}\n// 元素1绑定\nelement1.addeventlistener("click", clickeventfunction, false);\n\n\n这样能解决什么问题呢？\n\n * 绑定子元素会绑定很多次的事件，而绑定父元素只需要一次绑定。\n\n * 将事件委托给父节点，这样我们对子元素的增加和删除、移动等，都不需要重新进行事件绑定。\n\n常见的使用方式主要是上述这种列表结构，每个选项都可以进行编辑、删除、添加标签等功能，而把事件委托给父元素，不管我们新增、删除、更新选项，都不需要手动去绑定和移除事件。\n\n如果在列表数量内容较大的时候，对成千上万节点进行事件监听，也是不小的性能消耗。使用事件委托的方式，我们可以大量减少浏览器对元素的监听，也是在前端性能优化中比较简单和基础的一个做法。\n\n需要注意的是，如果我们直接在document.body上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。\n\n如果我们document.body上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用passive: true选项来解决。\n\n\n小结\n\n关于 html，我今天侧重讲了 html 的作用，以及它是如何影响浏览器中页面的加载过程的，同时还介绍了使用 dom 接口来控制 html 的展示和功能逻辑。\n\n很多时候，我们对一些基础内容也都需要不定期地进行复习。古人云“温故而知新”，一些原本认为已经固化的认知，在重新学习的过程中，或许你可以得到新的理解。比如，虚拟 dom 的设计其实参考了网页中 dom 设计的很多地方（树状结构、dom 属性），却又通过简化、新旧对比的方式巧妙地避开了容易出现性能瓶颈的地方，从而提升了页面渲染的性能。\n\n再比如，很多前端框架在监测数据变更的时候采用了树状结构（angular 2.0+、vue 3.0+），也是因为即使我们对应用进行了模块化、组件化，最终它在浏览器页面中的呈现和组织方式也依然是树状的，而树状的方式也很好地避免了循环依赖的问题。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **洲：\n\n> html是web开发的基石，用于告诉浏览器如何组织页面的方式，浏览器会根据实际html的内容生成一棵树，就是dom树，可以通过javascript访问这颗树来对页面进行更多额外的操作\n\n# **萍：\n\n> 请问: document.body添加事件委托，每次触发事件时，会产生生等待，为什么会产生等待？passive: true的作用是什么？\n\n#     讲师回复：\n\n>     产生等待是因为合成器线程于主线程进行通信。passive 设置为 true 时，表示 listener 永远不会调用 preventdefault。根据规范，passive 选项的默认值始终为 false，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。\n\n# *聪：\n\n> 老师，css会阻塞渲染吗？是cssom树构建完成之后，页面才开始渲染的吗？\n\n#     讲师回复：\n\n>     页面渲染会解析html和css，生成 dom tree 和 css rule tree，两者结合生成渲染树。最终渲染在页面中的便是渲染树，所以为了避免页面重新渲染，css应该放在 header 里哦~更详细的我们会在第 8 讲中进行介绍~\n\n# *聪：\n\n> 事件委托的第二个例子：【console.log(e.target === this);】应该为【console.log(event.target === this);】\n\n#     编辑回复：\n\n>     get\n\n# **8635：\n\n> 虚拟dom和实际dom之间是怎么更新替换的，怎么做到页面不会被重新渲染或者局部渲染的呢？\n\n#     讲师回复：\n\n>     其实我们会在第10讲中有比较详细的介绍，这里给点提示：我们平时操作 dom 的方式有哪些呢？\n\n# **4829：\n\n> 最后一段关于document.body进行事件委托的，不是很明白，能解释一下么？\n\n#     讲师回复：\n\n>     使用 document.body 添加事件委托，每次触发事件时，会产生生等待，产生等待是因为合成器线程于主线程进行通信。passive 设置为 true 时，表示 listener 永远不会调用 preventdefault。根据规范，passive 选项的默认值始终为 false，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。\n\n# **4344：\n\n> 请问对于事件委托不能绑定在body上，还是有点不在明白？passitive是哪个上面的属性呢？我看评论回答这个问题也没怎么明白，还请老师再回复一下，谢谢😀\n\n#     讲师回复：\n\n>     passive 是事件绑定的一个参数，可以看看 addeventlistener() 这个api~\n\n# **东：\n\n> react17版本的事件委托就有所修改，从原来的html到react.createelement的根元素上，这个修改的原因和都是上述所说的是不是有相同的原因。还有是个人觉得老师你读讲的语速有点快了，比如有图解的东西可以停一点点吗？，\n\n#     讲师回复：\n\n>     收到~我会努力的\n\n# **蓉：\n\n> 合成层具体是什么，不是很明白\n\n#     讲师回复：\n\n>     合成又称为 compositing，在现代浏览器渲染过程中，会将将页面的各个部分分成多个层，分别对其进行栅格化并进行合成。这部分内容我们会在第 8 讲中有介绍哦\n\n# *聪：\n\n> html的规范中指明defer属性的脚本是异步下载的，等到页面解析完成后按顺序执行，但是实际上浏览器并不保证顺序执行，所以页面中多个脚本有依赖关系的不要使用defer，平时最好只设置一个defer脚本\n\n#     讲师回复：\n\n>     棒~',charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"改善编程思维：从事件驱动到数据驱动",frontmatter:{title:"改善编程思维：从事件驱动到数据驱动",date:"2022-04-14T22:48:02.000Z",permalink:"/pages/b206ba/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/09.%E6%94%B9%E5%96%84%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%EF%BC%9A%E4%BB%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.html",relativePath:"01.前端/01.前端开发笔记/09.改善编程思维：从事件驱动到数据驱动.md",key:"v-49daadf4",path:"/pages/b206ba/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5662}],headersStr:"精选评论",content:'编程是将逻辑通过代码实现的过程，因此代码的编写效率和质量往往取决于我们的逻辑思维，以及如何将思考的内容使用代码来表达。\n\n今天我会介绍事件驱动和数据驱动两种编码思维模式，给你带来更好的开发体验。\n\n\n事件驱动\n\n首先，我们先来看看什么是事件驱动的编程方式。\n\n前端开发在实现功能的时候，会更倾向于使用事件驱动，这是因为受到 JavaScript 语言的设计和使用场景的影响。\n\n作为浏览器脚本语言，JavaScript 的主要用途是与用户互动、操作 DOM，实现页面 UI 和交互操作，属于 GUI（图形用户界面）编程。而 GUI 则是基于事件 I/O 模式的编程方式。\n\nGUI 与事件\n\nGUI 应用程序注重与用户的交互，大部分的程序执行需要等到用户的交互动作发生之后，所以 GUI 程序的执行取决于与用户的实时交互情况。\n\n然而，用户在访问程序期间，与程序进行交互的频率并不高。若不停轮询获取用户输入（类似 HTTP 短轮询），不仅资源利用率低，还无法做到真正的同步。因此，GUI 程序会将执行流程交由用户控制，当用户触发事件的时候进行响应，调用预先绑定好的代码来对事件进行处理。\n\nJavaScript 也一样，前面我们介绍了事件循环机制，所有的异步事件都会通过执行回调的方式来触发相应的逻辑执行。因此，前端开发在实现业务功能的时候，更容易倾向与用户交互流程（用户输入->事件响应->执行相应的代码逻辑->更新页面状态）结合，来完成与用户的交互操作。\n\n我们在写代码实现页面功能的时候，思路常常是这样的：\n\n 1. 编写静态页面（HTML 和样式）；\n\n 2. 在特定的元素上添加事件监听，监听用户交互（点击、输入、拖拽）等事件；\n\n 3. 将事件绑定到对应的函数和处理逻辑，比如获取用户输入/应用状态、计算并更新状态等；\n\n 4. 根据计算后的数据状态，更新相应的页面元素。\n\n通俗地说，事件驱动思维是从事件响应出发，来完成应用的设计和编程。这种编程方式实现起来既简单又清晰，所以很多开发者会选择（或是下意识地）使用事件驱动方式来写代码。\n\n我们来看看基于事件驱动的编程流程是怎样的。\n\n事件驱动的编码流程\n\n这里我们以实现一个提交表单的页面作为例子，如果用事件驱动的方式来实现，大致分为三个步骤。\n\n第一步：编写静态页面。\n\n\x3c!-- 实现静态页面 --\x3e\n<form>\n  Name:\n  <p id="name-value"></p>\n  <input type="text" name="name" id="name-input" />\n  Email:\n  <p id="email-value"></p>\n  <input type="email" name="email" id="email-input" />\n  <input type="submit" />\n</form>\n\n\n第二步：给对应的元素绑定对应的事件，例如通过addEventListener来监听input输入框的输入事件。\n\nvar nameInputEl = document.getElementById("name-input");\nvar emailInputEl = document.getElementById("email-input");\n// 监听输入事件，此时 updateValue 函数未定义\nnameInputEl.addEventListener("input", updateNameValue);\nemailInputEl.addEventListener("input", updateEmailValue);\n\n\n第三步：事件触发时，进行相关逻辑的处理（发起请求、更新页面内容等），并更新页面内容。我们将用户输入的内容更新到页面中展示。\n\nvar nameValueEl = document.getElementById("name-value");\nvar emailValueEl = document.getElementById("email-value");\n// 定义 updateValue 函数，用来更新页面内容\nfunction updateNameValue(e) {\n  nameValueEl.innerText = e.srcElement.value;\n}\nfunction updateEmailValue(e) {\n  emailValueEl.innerText = e.srcElement.value;\n}\n\n\n上述的三个步骤，便是基于事件驱动的思维实现的，是前端页面开发中很常见的编程思路。即使使用了前端框架（这里以 Vue 为例），也很容易用事件驱动的方式来实现上述功能：\n\n<template>\n  \x3c!-- 1. 绘制 HTML --\x3e\n  <div>\n    Name:\n    <p>{{ name }}</p>\n    \x3c!-- 2. 使用 v-on 绑定事件，这里绑定 updateValue 方法 --\x3e\n    <input type="text" v-bind:value="name" v-on:input="updateValue" />\n    \x3c!-- 上面 input 可以简写为： --\x3e\n    <input type="text" v-model="name" />\n  </div>\n</template>\n<script>\n  export default {\n    data() {\n      return {\n        name: "",\n      };\n    },\n    methods: {\n      // 3. change 事件触发时，更新数据\n      updateValue(event) {\n        this.name = event.target.value;\n      },\n    },\n  };\n<\/script>\n\n\n这里可以看出，使用前端框架帮我们省去了元素选择、HTML 拼接并更新等这些工作，同时还可以直接在模板上绑定事件监听。至于前端框架是如何做到这些的，我们会在下一讲详细介绍。\n现在，我们来回顾下事件驱动的编程思路：\n\n 1. 开发静态页面；\n\n 2. 在对应的元素上绑定事件；\n\n 3. 实现被绑定的事件功能，例如获取数据、更新页面等。\n\n代码实现思路的关注点在于触发了怎样的操作和这个操作会导致什么后果（即需要做怎样的处理），因此事件驱动的思维方式会围绕着“操作”和“响应”进行。\n\n那么，数据驱动又怎样的呢？\n\n\n数据驱动\n\n使用数据驱动的前提，在于将页面内容抽象为数据表达。基于抽象后的数据，这些数据会发生怎样的变化、又是如何被改变的，这些便是数据驱动的关注点。\n\n数据驱动和事件驱动的最大差异是开发的视角。\n\n * 事件驱动会关注于“操作”和“响应”，基于流程实现编码。\n\n * 数据驱动则会关注于“数据”和“数据的变化”，基于状态实现编码。\n\n下面我们同样以实现一个提交表单的页面为例，介绍数据驱动的编码流程（由于篇幅关系，以下代码会基于 Vue.js 实现）。\n\n数据驱动的编码流程\n\n对于提交表单的页面实现，数据驱动的编程方式同样可以分成三个步骤。\n\n第一步：对页面进行抽象设计，使用合适的数据结构来表达。\n\n抽象设计的内容会在第 14、15 讲内容中介绍，在这里我们先使用最简单的方式来设计：将页面中会变化和不会变化的内容隔离开，对其中会变化的内容进行抽象，再根据抽象结果来设计数据结构。\n\n以页面中的表单为例，变化的部分包括两个输入框、两处展示输入框内容的文字。其中，输入框和展示部分关联着相同的内容，因此我们可以使用同一个数据来表达。\n\n// 包括一个 name 和 一个 email 的值\nexport default {\n  data() {\n    return {\n      name: "",\n      email: "",\n    };\n  },\n};\n\n\n通过这样的方式，我们得到了两个抽象后的数据，一个是名字name，另外一个是邮件email，它们都是字符串格式。\n\n第二步：这个表单除了具备name和email两个数据，还包括两个分别用于改变数据的方法。因此，我们给该表单添加上更新值的方法：\n\nexport default {\n  data() {\n    return {\n      name: "",\n      email: "",\n    };\n  },\n  methods: {\n    // 更新 name 值\n    updateNameValue(newName) {\n      this.name = newName;\n    },\n    // 更新 email 值\n    updateEmailValue(newEmail) {\n      this.email = newEmail;\n    },\n  },\n};\n\n\n第三步：实现静态页面，并把数据和事件绑定到页面中。我们将步骤 1 中的数据绑定到页面中书输入框和展示值的地方，同时在需要监听事件的元素上绑定上述的方法。\n\n<form>\n  Name:\n  <p>{{ name }}</p>\n  <input\n    type="text"\n    name="name"\n    v-bind:value="name"\n    v-on:input="updateNameValue($event.target.value)"\n  />\n  Email:\n  <p>{{ email }}</p>\n  <input\n    type="email"\n    name="email"\n    v-bind:value="email"\n    v-on:input="updateEmailValue($event.target.value)"\n  />\n  <input type="submit" />\n</form>\n\n\n如果说步骤 1 和步骤 2 分别是抽象数据和抽象逻辑的过程，那么步骤 3 则是将抽象数据的逻辑具现化的过程。\n\n通过将抽象的逻辑具现化，我们最终将抽象的结果实现为应用的功能，这就是数据驱动的实现过程。\n\n数据驱动和事件驱动的区别\n\n这里或许你会有些疑问，看起来只是写代码的顺序不一样而已，甚至写代码的顺序都是一样的，那事件驱动和数据驱动的区别在哪？\n\n1. 数据驱动更容易将视图与逻辑解绑，能快速适应变更和调整。\n\n对于数据驱动，我们在编程实现的过程中，更多的是思考数据状态的维护和处理，而无需过于考虑 UI 的变化和事件的监听。即使我们页面 UI 全部重构了，影响到的只有模板中绑定的部分（即上面的第 3 个步骤），功能逻辑并不会受到影响。\n\n简单来说，基于数据模型设计的代码，即使经历了需求变更、页面结构调整、服务器接口调整，也可以快速地实现更新和支持。\n\n2. 事件驱动更倾向于流程式开发，数据驱动倾向于数据状态的变更和流动。\n\n事件驱动的特点是，以某个交互操作为起点，流程式地处理逻辑。流程式的代码，在遇到中间某个环节变更，就需要同时更新该变更点前后环节的流程交接。\n\n例如，对于页面加载渲染的过程，可以分成加载页面逻辑->请求服务器->更新页面。如果需要在从服务器获取的基础上，新增读取本地缓存的环节，同时需要在加载页面逻辑、更新页面两个环节进行衔接，并发地支持读取本地缓存和请求服务器。\n\n而数据驱动的思考方式特点是，以数据为中心，思考数据的输入和输出。\n\n * 数据来源：比如从服务器获取、用户输入、重置清空。\n\n * 数据去处：比如提交给服务器。\n\n同样的，如果我们需新增读取本地缓存的环节，在数据驱动的情况下，只是增加了一个数据来源，对于整个模型影响会小很多。\n\n * 数据来源：从服务器获取、用户输入、重置清空、读取本地缓存\n\n事件驱动和数据驱动一个很重要的区别在于，事件驱动是从每个事件的触发（“操作”）为中心来设计我们的代码，数据驱动则是以数据为中心，通过接收事件触发和更新数据状态的方式来实现页面功能。\n\n从事件驱动到数据驱动，可以理解为从用户交互为中心，调整成以数据的状态扭转为中心，来进行一些页面逻辑的实现。\n\n事件驱动的方式相比于数据驱动，少了数据抽象设计的一部分，因此开发的时候可能很快就完成某个功能的实现。但从维护和拓展的角度来说，习惯数据驱动的方式，在遇到功能变更和迭代时可以更高效、更合理地进行调整。\n\n\n小结\n\n今天我介绍了前端开发中两种编程思维模式：事件驱动和数据驱动。其中，由于浏览器属于 GUI 编程，我们在开发过程中常常基于“事件”和“响应”的方式来理解功能，因此大多数会倾向于使用事件驱动的方式。\n\n相比于事件驱动，数据驱动更倾向于以“数据”为中心，通过将页面抽象为数据表达，用数据状态变更的方式来表达功能逻辑。数据驱动更容易将视图与逻辑解绑，能快速适应变更和调整。\n\n在我们日常开发中，更多时候是结合了事件驱动和数据驱动来进行编码。\n\nVue、Angular、React 这些前端框架的出现，处理了很多事件驱动流程上的工作，从而推动了更多开发者从事件驱动转变成数据驱动的方式，更加专注于数据的处理。\n\n技术的迭代、工具的更新和个人的成长，有时候是相辅相成的。思维模式也好，设计模式也好，我们在一次次的开发过程中，会不断地积累和加深一些思考，适合业务场景的才是最好的。\n\n今日思考：你认为事件驱动和数据驱动，各自的优劣分别是什么呢？\n\n----------------------------------------\n\n\n# 精选评论\n\n# 宋：\n\n> 事件驱动：1.开发更加简单直观2.少了数据抽象设计，减少工作量3.对于大量涉及到dom频繁变化的需求，如动画之类，事件驱动开发更合适4.界面和业务逻辑强耦合，代码不易于更改和扩展需求数据驱动：1.需要合理抽象数据设计2.开发工作量梢大一些3.需要好的数据状态管理工具4.界面和业务逻辑分离，方便后期更改和扩展需求\n\n# Kerita：\n\n> 数据驱动可以方便地对复杂的数据进行处理，同时将数据展示在页面上。事件驱动方便与用户进行复杂交互或者展示复杂动画。\n\n# *振：\n\n> 数据驱动怎么不是直接用 v-model，怎么还要绑定输入事件？\n\n#     讲师回复：\n\n>     v-model 只是一个语法糖而已，实际上便是通过 v-bind 和事件绑定实现。这里一是为了方便说明和对比，二是因为并不是所有情况都能用 v-model 解决的~很多时候还是需要绑定事件的~',normalizedContent:'编程是将逻辑通过代码实现的过程，因此代码的编写效率和质量往往取决于我们的逻辑思维，以及如何将思考的内容使用代码来表达。\n\n今天我会介绍事件驱动和数据驱动两种编码思维模式，给你带来更好的开发体验。\n\n\n事件驱动\n\n首先，我们先来看看什么是事件驱动的编程方式。\n\n前端开发在实现功能的时候，会更倾向于使用事件驱动，这是因为受到 javascript 语言的设计和使用场景的影响。\n\n作为浏览器脚本语言，javascript 的主要用途是与用户互动、操作 dom，实现页面 ui 和交互操作，属于 gui（图形用户界面）编程。而 gui 则是基于事件 i/o 模式的编程方式。\n\ngui 与事件\n\ngui 应用程序注重与用户的交互，大部分的程序执行需要等到用户的交互动作发生之后，所以 gui 程序的执行取决于与用户的实时交互情况。\n\n然而，用户在访问程序期间，与程序进行交互的频率并不高。若不停轮询获取用户输入（类似 http 短轮询），不仅资源利用率低，还无法做到真正的同步。因此，gui 程序会将执行流程交由用户控制，当用户触发事件的时候进行响应，调用预先绑定好的代码来对事件进行处理。\n\njavascript 也一样，前面我们介绍了事件循环机制，所有的异步事件都会通过执行回调的方式来触发相应的逻辑执行。因此，前端开发在实现业务功能的时候，更容易倾向与用户交互流程（用户输入->事件响应->执行相应的代码逻辑->更新页面状态）结合，来完成与用户的交互操作。\n\n我们在写代码实现页面功能的时候，思路常常是这样的：\n\n 1. 编写静态页面（html 和样式）；\n\n 2. 在特定的元素上添加事件监听，监听用户交互（点击、输入、拖拽）等事件；\n\n 3. 将事件绑定到对应的函数和处理逻辑，比如获取用户输入/应用状态、计算并更新状态等；\n\n 4. 根据计算后的数据状态，更新相应的页面元素。\n\n通俗地说，事件驱动思维是从事件响应出发，来完成应用的设计和编程。这种编程方式实现起来既简单又清晰，所以很多开发者会选择（或是下意识地）使用事件驱动方式来写代码。\n\n我们来看看基于事件驱动的编程流程是怎样的。\n\n事件驱动的编码流程\n\n这里我们以实现一个提交表单的页面作为例子，如果用事件驱动的方式来实现，大致分为三个步骤。\n\n第一步：编写静态页面。\n\n\x3c!-- 实现静态页面 --\x3e\n<form>\n  name:\n  <p id="name-value"></p>\n  <input type="text" name="name" id="name-input" />\n  email:\n  <p id="email-value"></p>\n  <input type="email" name="email" id="email-input" />\n  <input type="submit" />\n</form>\n\n\n第二步：给对应的元素绑定对应的事件，例如通过addeventlistener来监听input输入框的输入事件。\n\nvar nameinputel = document.getelementbyid("name-input");\nvar emailinputel = document.getelementbyid("email-input");\n// 监听输入事件，此时 updatevalue 函数未定义\nnameinputel.addeventlistener("input", updatenamevalue);\nemailinputel.addeventlistener("input", updateemailvalue);\n\n\n第三步：事件触发时，进行相关逻辑的处理（发起请求、更新页面内容等），并更新页面内容。我们将用户输入的内容更新到页面中展示。\n\nvar namevalueel = document.getelementbyid("name-value");\nvar emailvalueel = document.getelementbyid("email-value");\n// 定义 updatevalue 函数，用来更新页面内容\nfunction updatenamevalue(e) {\n  namevalueel.innertext = e.srcelement.value;\n}\nfunction updateemailvalue(e) {\n  emailvalueel.innertext = e.srcelement.value;\n}\n\n\n上述的三个步骤，便是基于事件驱动的思维实现的，是前端页面开发中很常见的编程思路。即使使用了前端框架（这里以 vue 为例），也很容易用事件驱动的方式来实现上述功能：\n\n<template>\n  \x3c!-- 1. 绘制 html --\x3e\n  <div>\n    name:\n    <p>{{ name }}</p>\n    \x3c!-- 2. 使用 v-on 绑定事件，这里绑定 updatevalue 方法 --\x3e\n    <input type="text" v-bind:value="name" v-on:input="updatevalue" />\n    \x3c!-- 上面 input 可以简写为： --\x3e\n    <input type="text" v-model="name" />\n  </div>\n</template>\n<script>\n  export default {\n    data() {\n      return {\n        name: "",\n      };\n    },\n    methods: {\n      // 3. change 事件触发时，更新数据\n      updatevalue(event) {\n        this.name = event.target.value;\n      },\n    },\n  };\n<\/script>\n\n\n这里可以看出，使用前端框架帮我们省去了元素选择、html 拼接并更新等这些工作，同时还可以直接在模板上绑定事件监听。至于前端框架是如何做到这些的，我们会在下一讲详细介绍。\n现在，我们来回顾下事件驱动的编程思路：\n\n 1. 开发静态页面；\n\n 2. 在对应的元素上绑定事件；\n\n 3. 实现被绑定的事件功能，例如获取数据、更新页面等。\n\n代码实现思路的关注点在于触发了怎样的操作和这个操作会导致什么后果（即需要做怎样的处理），因此事件驱动的思维方式会围绕着“操作”和“响应”进行。\n\n那么，数据驱动又怎样的呢？\n\n\n数据驱动\n\n使用数据驱动的前提，在于将页面内容抽象为数据表达。基于抽象后的数据，这些数据会发生怎样的变化、又是如何被改变的，这些便是数据驱动的关注点。\n\n数据驱动和事件驱动的最大差异是开发的视角。\n\n * 事件驱动会关注于“操作”和“响应”，基于流程实现编码。\n\n * 数据驱动则会关注于“数据”和“数据的变化”，基于状态实现编码。\n\n下面我们同样以实现一个提交表单的页面为例，介绍数据驱动的编码流程（由于篇幅关系，以下代码会基于 vue.js 实现）。\n\n数据驱动的编码流程\n\n对于提交表单的页面实现，数据驱动的编程方式同样可以分成三个步骤。\n\n第一步：对页面进行抽象设计，使用合适的数据结构来表达。\n\n抽象设计的内容会在第 14、15 讲内容中介绍，在这里我们先使用最简单的方式来设计：将页面中会变化和不会变化的内容隔离开，对其中会变化的内容进行抽象，再根据抽象结果来设计数据结构。\n\n以页面中的表单为例，变化的部分包括两个输入框、两处展示输入框内容的文字。其中，输入框和展示部分关联着相同的内容，因此我们可以使用同一个数据来表达。\n\n// 包括一个 name 和 一个 email 的值\nexport default {\n  data() {\n    return {\n      name: "",\n      email: "",\n    };\n  },\n};\n\n\n通过这样的方式，我们得到了两个抽象后的数据，一个是名字name，另外一个是邮件email，它们都是字符串格式。\n\n第二步：这个表单除了具备name和email两个数据，还包括两个分别用于改变数据的方法。因此，我们给该表单添加上更新值的方法：\n\nexport default {\n  data() {\n    return {\n      name: "",\n      email: "",\n    };\n  },\n  methods: {\n    // 更新 name 值\n    updatenamevalue(newname) {\n      this.name = newname;\n    },\n    // 更新 email 值\n    updateemailvalue(newemail) {\n      this.email = newemail;\n    },\n  },\n};\n\n\n第三步：实现静态页面，并把数据和事件绑定到页面中。我们将步骤 1 中的数据绑定到页面中书输入框和展示值的地方，同时在需要监听事件的元素上绑定上述的方法。\n\n<form>\n  name:\n  <p>{{ name }}</p>\n  <input\n    type="text"\n    name="name"\n    v-bind:value="name"\n    v-on:input="updatenamevalue($event.target.value)"\n  />\n  email:\n  <p>{{ email }}</p>\n  <input\n    type="email"\n    name="email"\n    v-bind:value="email"\n    v-on:input="updateemailvalue($event.target.value)"\n  />\n  <input type="submit" />\n</form>\n\n\n如果说步骤 1 和步骤 2 分别是抽象数据和抽象逻辑的过程，那么步骤 3 则是将抽象数据的逻辑具现化的过程。\n\n通过将抽象的逻辑具现化，我们最终将抽象的结果实现为应用的功能，这就是数据驱动的实现过程。\n\n数据驱动和事件驱动的区别\n\n这里或许你会有些疑问，看起来只是写代码的顺序不一样而已，甚至写代码的顺序都是一样的，那事件驱动和数据驱动的区别在哪？\n\n1. 数据驱动更容易将视图与逻辑解绑，能快速适应变更和调整。\n\n对于数据驱动，我们在编程实现的过程中，更多的是思考数据状态的维护和处理，而无需过于考虑 ui 的变化和事件的监听。即使我们页面 ui 全部重构了，影响到的只有模板中绑定的部分（即上面的第 3 个步骤），功能逻辑并不会受到影响。\n\n简单来说，基于数据模型设计的代码，即使经历了需求变更、页面结构调整、服务器接口调整，也可以快速地实现更新和支持。\n\n2. 事件驱动更倾向于流程式开发，数据驱动倾向于数据状态的变更和流动。\n\n事件驱动的特点是，以某个交互操作为起点，流程式地处理逻辑。流程式的代码，在遇到中间某个环节变更，就需要同时更新该变更点前后环节的流程交接。\n\n例如，对于页面加载渲染的过程，可以分成加载页面逻辑->请求服务器->更新页面。如果需要在从服务器获取的基础上，新增读取本地缓存的环节，同时需要在加载页面逻辑、更新页面两个环节进行衔接，并发地支持读取本地缓存和请求服务器。\n\n而数据驱动的思考方式特点是，以数据为中心，思考数据的输入和输出。\n\n * 数据来源：比如从服务器获取、用户输入、重置清空。\n\n * 数据去处：比如提交给服务器。\n\n同样的，如果我们需新增读取本地缓存的环节，在数据驱动的情况下，只是增加了一个数据来源，对于整个模型影响会小很多。\n\n * 数据来源：从服务器获取、用户输入、重置清空、读取本地缓存\n\n事件驱动和数据驱动一个很重要的区别在于，事件驱动是从每个事件的触发（“操作”）为中心来设计我们的代码，数据驱动则是以数据为中心，通过接收事件触发和更新数据状态的方式来实现页面功能。\n\n从事件驱动到数据驱动，可以理解为从用户交互为中心，调整成以数据的状态扭转为中心，来进行一些页面逻辑的实现。\n\n事件驱动的方式相比于数据驱动，少了数据抽象设计的一部分，因此开发的时候可能很快就完成某个功能的实现。但从维护和拓展的角度来说，习惯数据驱动的方式，在遇到功能变更和迭代时可以更高效、更合理地进行调整。\n\n\n小结\n\n今天我介绍了前端开发中两种编程思维模式：事件驱动和数据驱动。其中，由于浏览器属于 gui 编程，我们在开发过程中常常基于“事件”和“响应”的方式来理解功能，因此大多数会倾向于使用事件驱动的方式。\n\n相比于事件驱动，数据驱动更倾向于以“数据”为中心，通过将页面抽象为数据表达，用数据状态变更的方式来表达功能逻辑。数据驱动更容易将视图与逻辑解绑，能快速适应变更和调整。\n\n在我们日常开发中，更多时候是结合了事件驱动和数据驱动来进行编码。\n\nvue、angular、react 这些前端框架的出现，处理了很多事件驱动流程上的工作，从而推动了更多开发者从事件驱动转变成数据驱动的方式，更加专注于数据的处理。\n\n技术的迭代、工具的更新和个人的成长，有时候是相辅相成的。思维模式也好，设计模式也好，我们在一次次的开发过程中，会不断地积累和加深一些思考，适合业务场景的才是最好的。\n\n今日思考：你认为事件驱动和数据驱动，各自的优劣分别是什么呢？\n\n----------------------------------------\n\n\n# 精选评论\n\n# 宋：\n\n> 事件驱动：1.开发更加简单直观2.少了数据抽象设计，减少工作量3.对于大量涉及到dom频繁变化的需求，如动画之类，事件驱动开发更合适4.界面和业务逻辑强耦合，代码不易于更改和扩展需求数据驱动：1.需要合理抽象数据设计2.开发工作量梢大一些3.需要好的数据状态管理工具4.界面和业务逻辑分离，方便后期更改和扩展需求\n\n# kerita：\n\n> 数据驱动可以方便地对复杂的数据进行处理，同时将数据展示在页面上。事件驱动方便与用户进行复杂交互或者展示复杂动画。\n\n# *振：\n\n> 数据驱动怎么不是直接用 v-model，怎么还要绑定输入事件？\n\n#     讲师回复：\n\n>     v-model 只是一个语法糖而已，实际上便是通过 v-bind 和事件绑定实现。这里一是为了方便说明和对比，二是因为并不是所有情况都能用 v-model 解决的~很多时候还是需要绑定事件的~',charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"掌握前端框架模板引擎的实现原理",frontmatter:{title:"掌握前端框架模板引擎的实现原理",date:"2022-04-14T22:48:02.000Z",permalink:"/pages/ea57d2/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/10.%E6%8E%8C%E6%8F%A1%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/01.前端开发笔记/10.掌握前端框架模板引擎的实现原理.md",key:"v-de1b1892",path:"/pages/ea57d2/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:10789}],headersStr:"精选评论",content:'如今说起前端开发，基本上都离不开前端框架。随着前端技术不断迭代，前端框架相关的文档和社区日益完善，前端入门也越来越简单了。我们可以快速上手一些工具和框架，但常常会忽略其中的设计和原理。\n\n对框架和工具的了解不够深入，会导致我们在遇到一些偏门的问题时容易找不到方向，也不利于个人的知识领域扩展，不能很好地进行技术选型。\n\n今天，我会带你了解前端框架为什么会这么热门，以及介绍前端框架的核心能力——模板引擎的实现原理。在讲解的过程中，一些代码会以 Vue.js 作为示例。\n\n我们先来看一下，为什么要使用前端框架。\n\n\n为什么要使用前端框架\n\n一个工具被大多数人使用、成为热门，离不开相关技术发展的历史进程。了解这些工具和框架出现的原因，我们可以及时掌握技术的发展方向，保持对技术的敏感度、更新自身的认知，这些都会成为我们自身的竞争力。\n\n前端框架也一样。在前端框架出现之前，jQuery 也是前端开发必备的工具库，大多数项目中都会使用。短短几年间，前端开发却变得无法离开前端框架，这中间到底发生了什么呢？\n\n前端的飞速发展\n\n曾几何时，一提到前端，大家都会想到 jQuery。那是 jQuery 一把梭的年代，不管前端后台都会用 jQuery 完成页面开发。那时候前端开发的工作倾向于切图和重构，重页面样式而轻逻辑，工作内容常常是拼接 JSP 模板、拼 PHP 模板以及调节浏览器兼容。\n\n为什么 jQuery 那么热门呢？除了超方便的 Sizzle 引擎元素选择器、简单易用的异步请求库 ajax，还有链式调用的编程方式使得代码如行云流水般流畅。jQuery 提供的便捷几乎满足了当时前端的大部分工作（所以说 jQuery 一把梭不是毫无道理的）。\n\n接下来短短的几年时间，前端经历了特别多的改变。随着 Node.js 的出现、NPM 包管理的完善，再加上热闹的开源社区，前端领域获得了千千万万开发者的支援。从页面开发到工具库开发、框架开发、脚本开发、到服务端开发，单线程的 JavaScript 正在不断进行自我革新，从而将领域不断拓宽，形成了如今你所能看到的、获得赋能的前端。\n\n那么，是什么原因导致了 jQuery 被逐渐冷落，前端框架站上了舞台中央呢？其中的原因有很多，包括业务场景的进化、技术的更新迭代，比如前端应用逐渐复杂、单页应用的出现、前端模块化等。\n\n前端框架的出现\n\n前面第 8 讲中，我们知道了浏览器是如何渲染页面的。从用户的角度来看，浏览器生成了最终的渲染树，并通过光栅化来将页面显示在屏幕上，页面渲染的工作就完成了。\n\n实际上，浏览器页面更多的不只是静态页面的渲染，还包括点击、拖拽等事件操作以及接口请求、数据渲染到页面等动态的交互逻辑，因此我们还常常需要更新页面的内容。\n\n要理解前端框架为什么如此重要，需要先看看在框架出现前，前端开发是如何实现和用户进行交互的。\n\n这个过程跟上一讲事件驱动的内容很相似，以一个常见的表单提交作为例子，会包括编写静态页面、给对应的元素绑定对应的事件、事件触发时更新页面内容等步骤，这是最简单的页面交互。\n\n对于更新页面内容这个步骤，如果我们页面中有很多的内容需要更新，光拼接字符串我们可能就有一大堆代码。\n\n> 以下的例子，为了不占用大量的篇幅，使用了 jQuery，否则代码量会更多。\n\n举个例子，抢答活动中常常会出现题目和多个答案进行选择，我们现在需要开发一个管理端，对这些抢答卡片进行管理。假设一个问题会包括两个答案，我们可以通过新增卡片的方式来添加一套问答，编辑卡片的过程包括这些步骤。\n\n1. 新增一个卡片时，通过插入 DOM 节点的方式添加卡片样式。\n\nvar index = 0;\n// 用来新增一个卡片，卡片内需要填写一些内容\nfunction addCard() {\n  // 获取一个id为the-dom的元素\n  var body = $("#the-dom");\n  // 从该元素内获取class为the-class的元素\n  var addDom = body.find(".the-class");\n  // 在the-class元素前方插入一个div\n  addDom.before(\'<div class="col-lg-4" data-index="\' + index + \'"></div>\');\n  // 同时保存下来该DOM节点，方便更新内容\n  var theDom = body.find(\'[data-index="\' + index + \'"]\');\n  theDom.innerHTML(\n    `<input type="text" class="form-control question" placeholder="你的问题">\n         <input type="text" class="form-control option-a" placeholder="回答1">\n         <input type="text" class="form-control option-b" placeholder="回答2">\n        `\n  );\n  // 做完上面这堆之后index自增\n  index++;\n  return theDom;\n}\n\n\n2. 卡片内编辑题目和答案时，会有字数限制（使用 jQuery 对输入框的输入事件进行监听，并限制输入内容）。\n\n// theDom使用上面代码保存下来的引用\n// 问题绑定值\ntheDom\n  .on("keyup", ".question", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 20);\n  })\n  // 答案a绑定值\n  .on("keyup", ".option-a", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 10);\n  })\n  // 答案b绑定值\n  .on("keyup", ".option-b", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 10);\n  });\n\n\n3. 获取输入框内的内容（使用 jQuery 选择元素并获取内容），用于提交到后台。\n\n// 获取卡片的输入值\n// theDom 使用上面代码保存下来的引用\nfunction getCardValue(index) {\n  var body = $("#the-dom");\n  var theDom = body.find(\'[data-index="\' + index + \'"]\');\n  var questionName = theDom.find(".question").val();\n  var optionA = theDom.find(".option-a").val();\n  var optionB = theDom.find(".option-b").val();\n  return { questionName, optionA, optionB };\n}\n\n\n可以看到，仅是实现一个问答卡片的编辑就需要编写不少的代码，大多数代码内容都是为了拼接 HTML 内容、获取 DOM 节点、操作 DOM 节点。\n这些代码逻辑，如果我们使用 Vue 来实现，只需要这么写：\n\n<template>\n  <div v-for="card in cards">\n    <input\n      type="text"\n      class="form-control question"\n      v-model="card.questionName"\n      placeholder="你的问题"\n    />\n    <input\n      type="text"\n      class="form-control option-a"\n      v-model="card.optionA"\n      placeholder="回答1"\n    />\n    <input\n      type="text"\n      class="form-control option-b"\n      v-model="card.optionB"\n      placeholder="回答2"\n    />\n  </div>\n</template>\n<script>\n  export default {\n    name: "Cards",\n    data() {\n      return {\n        cards: [],\n      };\n    },\n    methods: {\n      // 添加一个卡片\n      addCard() {\n        this.cards.push({\n          questionName: "",\n          optionA: "",\n          optionB: "",\n        });\n      },\n      // 获取卡片的输入值\n      getCardValue(index) {\n        return this.cards[index];\n      },\n    },\n  };\n<\/script>\n\n\n可见，前端框架提供了便利的数据绑定、界面更新、事件监听等 API，我们不需要再手动更新前端页面的内容、维护一大堆的 HTML 和变量拼接的动态内容了。\n使用前端框架对开发效率有很大的提升，同时也在一定程度上避免了代码可读性、可维护性等问题。这也是为什么前端框架这么热门，大家都会使用它来进行开发的原因。\n\n那么，前端框架是怎么做到这些的呢？要实现这些能力，离不开其中的模板引擎。\n\n\n前端框架的核心——模板引擎\n\n当用户对页面进行操作、页面内容更新，我们需要实现的功能流程包括：\n\n 1. 监听操作；\n\n 2. 获取数据变量；\n\n 3. 使用数据变量拼接成 HTML 模板；\n\n 4. 将 HTML 内容塞到页面对应的地方；\n\n 5. 将 HTML 片段内需要监听的点击等事件进行绑定。\n\n可以看到，实现逻辑会比较复杂和烦琐。\n\n如果使用前端框架，我们可以：\n\n * 使用将数据变量绑定到 HTML 模板的方式，来控制展示的内容；\n\n * 配合一些条件判断、条件循环等逻辑，控制交互的具体逻辑；\n\n * 通过改变数据变量，框架会自动更新页面内容。\n\n这样，我们可以快速高效地完成功能开发，代码的可读性和维护性都远胜于纯手工实现。\n\n如果使用数据驱动的方式，还可以通过让逻辑与 UI 解耦的方式，提升代码的可维护性。其中的数据绑定、事件绑定等功能，前端框架是依赖模板引擎的方式来实现的。\n\n以 Vue 为例子，对于开发者编写的 Vue 代码，Vue 会将其进行以下处理从而渲染到页面中：\n\n 1. 解析语法生成 AST 对象；\n\n 2. 根据生成的 AST 对象，完成data数据初始化；\n\n 3. 根据 AST 对象和data数据绑定情况，生成虚拟 DOM 对象；\n\n 4. 将虚拟 DOM 对象生成真正的 DOM 元素插入到页面中，此时页面会被渲染。\n\n模板引擎将模板语法进行解析，分别生成 HTML DOM，使用像 HTML 拼接的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 DOM 的设计，可以最大化地提升页面的性能。\n\n这些便是模板引擎主要的工作，我们来分别看一下。\n\n解析语法生成 AST 对象\n\n抽象语法树（Abstract Syntax Tree）也称为 AST 语法树，指的是源代码语法所对应的树状结构。其实我们的 DOM 结构树，也是 AST 的一种，浏览器会对 HTML DOM 进行语法解析、并生成最终的页面。\n\n生成 AST 的过程涉及编译器的原理，一般经过以下过程。\n\n 1. 语法分析。模板引擎需要在这个过程中识别出特定的语法，比如v-if/v-for这样的指令，或是<MyCustomComponent>这样的自定义 DOM 标签，还有@click/:props这样的简化绑定语法等。\n\n 2. 语义分析。这个过程会审查源程序有无语义错误，为代码生成阶段收集类型信息，一般类型检查也会在这个过程中进行。例如我们绑定了某个不存在的变量或者事件，又或者是使用了某个未定义的自定义组件等，都会在这个阶段进行报错提示。\n\n 3. 生成 AST 对象。\n\n以 Vue 为例，生成 AST 的过程包括 HTML 模板解析、元素检查和预处理：\n\n/**\n *  将HTML编译成AST对象\n *  该代码片段基于Vue2.x版本\n */\nexport function parse(\n  template: string,\n  options: CompilerOptions\n): ASTElement | void {\n  // 返回AST对象\n  // 篇幅原因，一些前置定义省略\n  // 此处开始解析HTML模板\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start(tag, attrs, unary) {\n      // 一些前置检查和设置、兼容处理此处省略\n      // 此处定义了初始化的元素AST对象\n      const element: ASTElement = {\n        type: 1,\n        tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: [],\n      };\n      // 检查元素标签是否合法（不是保留命名）\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== "production" &&\n          warn(\n            "Templates should only be responsible for mapping the state to the " +\n              "UI. Avoid placing tags with side-effects in your templates, such as " +\n              `<${tag}>` +\n              ", as they will not be parsed."\n          );\n      }\n      // 执行一些前置的元素预处理\n      for (let i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n      // 是否原生元素\n      if (inVPre) {\n        // 处理元素的一些属性\n        processRawAttrs(element);\n      } else {\n        // 处理指令，此处包括v-for/v-if/v-once/key等等\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element); // 删除结构属性\n        // 确定这是否是一个简单的元素\n        element.plain = !element.key && !attrs.length;\n        // 处理ref/slot/component等属性\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (let i = 0; i < transforms.length; i++) {\n          transforms[i](element, options);\n        }\n        processAttrs(element);\n      }\n      // 后面还有一些父子节点等处理，此处省略\n    },\n    // 其他省略\n  });\n  return root;\n}\n\n\n到这里，Vue 将开发者的模板代码解析成 AST 对象，我们来看看这样的 AST 对象是怎样生成 DOM 元素的。\n\nAST 对象生成 DOM 元素\n\n前面提到，在编译解析和渲染过程中，模板引擎会识别和解析模板语法语义、生成 AST 对象，最后根据 AST 对象会生成最终的 DOM 元素。\n\n举个例子，我们写了以下这么一段 HTML 模板：\n\n<div>\n  <a>123</a>\n  <p>456<span>789</span></p>\n</div>\n\n\n模板引擎可以在语法分析、语义分析等步骤后，得到这样的一个 AST 对象：\n\nthisDiv = {\n  dom: {\n    type: "dom",\n    ele: "div",\n    nodeIndex: 0,\n    children: [\n      {\n        type: "dom",\n        ele: "a",\n        nodeIndex: 1,\n        children: [{ type: "text", value: "123" }],\n      },\n      {\n        type: "dom",\n        ele: "p",\n        nodeIndex: 2,\n        children: [\n          { type: "text", value: "456" },\n          {\n            type: "dom",\n            ele: "span",\n            nodeIndex: 3,\n            children: [{ type: "text", value: "789" }],\n          },\n        ],\n      },\n    ],\n  },\n};\n\n\n这个 AST 对象维护我们需要的一些信息，包括 HTML 元素里：\n\n * 需要绑定哪些变量（变量更新的时候需要更新该节点内容）；\n\n * 是否有其他的逻辑需要处理（比如含有逻辑指令，如v-if、v-for等）；\n\n * 哪些节点绑定了事件监听事件（是否匹配一些常用的事件能力支持，如@click）。\n\n模板引擎会根据 AST 对象生成最终的页面片段和逻辑，在这个过程中会通过添加特殊标识（例如元素 ID、属性标记等）的方式来标记 DOM 节点，配合 DOM 元素选择方式、事件监听方式等，在需要更新的时候可快速定位到该 DOM 节点，并进行节点内容更新，从而实现页面内容的更新。\n\n目前来说，前端模板渲染的实现一般分为以下两种方式。\n\n 1. 字符串模版方式：使用拼接的方式生成 DOM 字符串，直接通过innderHTML()插入页面。\n\n 2. 节点模版方式：使用createElement()/appendChild()/textContent等方法动态地插入 DOM 节点。\n\n在使用字符串模版的时候，我们将nodeIndex绑定在元素属性上，主要用于在数据更新时追寻节点进行内容更新。\n\n在使用节点模版的时候，我们可在创建节点时将该节点保存下来，直接用于数据更新：\n\n// 假设这是一个生成 DOM 的过程，包括 innerHTML 和事件监听\nfunction generateDOM(astObject) {\n  const { dom, binding = [] } = astObject;\n  // 生成DOM，这里假装当前节点是baseDom\n  baseDom.innerHTML = getDOMString(dom);\n  // 对于数据绑定的，来进行监听更新吧\n  baseDom.addEventListener("data:change", (name, value) => {\n    // 寻找匹配的数据绑定\n    const obj = binding.find((x) => x.valueName == name);\n    // 若找到值绑定的对应节点，则更新其值。\n    if (obj) {\n      baseDom.find(`[data-node-index="${obj.nodeIndex}"]`).innerHTML = value;\n    }\n  });\n}\n// 获取DOM字符串，这里简单拼成字符串\nfunction getDOMString(domObj) {\n  // 无效对象返回\'\'\n  if (!domObj) return "";\n  const { type, children = [], nodeIndex, ele, value } = domObj;\n  if (type == "dom") {\n    // 若有子对象，递归返回生成的字符串拼接\n    const childString = "";\n    children.forEach((x) => {\n      childString += getDOMString(x);\n    });\n    // dom对象，拼接生成对象字符串\n    return `<${ele} data-node-index="${nodeIndex}">${childString}</${ele}>`;\n  } else if (type == "text") {\n    // 若为textNode，返回text的值\n    return value;\n  }\n}\n\n\n通过上面的方式，前端框架实现了将 AST 对象生成 DOM 元素，并将这些 DOM 元素渲染或更新到页面上。\n\n或许你会觉得疑惑：原本就是一个<div>HTML 模板，经过 AST 生成一个对象，最终还是生成一个<div>DOM 节点，看起来好像挺多余的。\n\n实际上，在这个过程中，模板引擎可以实现更多功能。\n\n模板引擎可以做更多\n\n将 HTML 模板解析成 AST 对象，再根据 AST 对象生成 DOM 节点，在这个过程中前端框架可以实现以下功能：\n\n 1. 排除无效 DOM 元素（非自定义组件、也非默认组件的 DOM 元素），在构建阶段可及时发现并进行报错；\n\n 2. 可识别出自定义组件，并渲染对应的组件；\n\n 3. 可方便地实现数据绑定、事件绑定等功能；\n\n 4. 为虚拟 DOM Diff 过程打下铺垫；\n\n 5. HTML 转义（预防 XSS 漏洞）。\n\n这里我们以第 5 点预防 XSS 漏洞为例子，详细地介绍一下模板引擎是如何避免 XSS 攻击的。\n\n预防 XSS 漏洞\n\n我们知道 XSS 的整个攻击过程大概为：\n\n 1. 攻击者提交含有恶意代码的内容（比如 JavaScript 脚本）；\n\n 2. 页面渲染的时候，这些内容未被过滤就被加载处理，比如获取 Cookie、执行操作等；\n\n 3. 其他用户在浏览页面的时候，就会在加载到恶意代码时受到攻击。\n\n要避免网站用户受到 XSS 攻击，主要方法是将用户提交的内容进行过滤处理。大多数前端框架会自带 HTML 转义功能，从而避免的 XSS 攻击。\n\n以 Vue 为例，使用默认的数据绑定方式（双大括号、v-bind等）会进行 HTML 转义，将数据解释为普通文本，而非 HTML 代码。\n\n除此预防 XSS 漏洞之外，前端框架还做了一些性能、安全性等方面的优化，也提供了一些用于项目开发配套的工具，包括路由的管理、状态和数据的管理等工具。\n\n\n小结\n\n今天我带大家了解了前端框架的出现，由于前端框架帮开发者解决了很多重复性的工作（拼接 HTML 模板、DOM 元素查找、DOM 元素事件监听等），极大地提升了开发者的效率，同时还提升了代码的可读性和可维护性，因此受到很多前端开发的追捧。\n\n除此之外，我还介绍了前端框架中模板引擎的实现原理，包括解析语法生成 AST 对象、根据 AST 对象生成 DOM 元素，并对生成的 DOM 元素进行标记，则可以在变量改变的时候，解析找到相应的 DOM 元素进行内容的更新。\n\n在了解这些内容之后，我们可以在页面渲染遇到性能问题的时候，根据所使用框架的具体实现，找到可能导致页面渲染卡顿或是不流畅的原因。除此之外，在使用框架的过程中，遇到一些语法报错、XSS 安全漏洞等问题的时候，也可以快速找到解决办法。\n\n今日思考：React.js 中的 JSX 和模板引擎是什么关系？在留言区写出你的想法！\n\n----------------------------------------\n\n\n# 精选评论\n\n# **宇：\n\n> jsx会被babel编译成React.createElement()，用来创建相应的虚拟dom对象，后面会被reactdom或者react native等不同平台的渲染库渲染成ui或者SSR。之所以发明jsx是因为，React.createElement太过繁琐，jsx可以像写html一样写ui，同时也保留了部分js的能力。题外话：其实Facebook最初并没有打算让createElement作为jsx的编译产物，因为它里面的defaultValue，propType，ref key的拦截等等逻辑比较浪费性能，对props的属性有O(n)级别的复杂度，本来只是作为让用户临时手动生产虚拟dom的一个补充手段，但因为当时只有它是最好的选择，所以才这样了，react17以后可能有变化。\n\n# *浩：\n\n> 今日思考的回答：React中的jsx本质是JavaScript语法的扩展，充分具备JavaScript能力，这就能让developer像写JavaScript一样写UI，我们写的虽然是jsx，借助babel等类似的工具的转化，最终还是会编译成React.createElement()这样的函数去生成虚拟DOM，后面生成AST,再由AST生成真实DOM,这些过程应该跟老师经的一样吧，有写错的地方，望老师批评指正。\n\n# 856：\n\n> jsx 是把代码转成react可以解读的代码，并没有生成dom模板引擎是通过自己的语法生成dom 相同点都是用自己的语法 写html ,底层实现操作dom\n\n#     讲师回复：\n\n>     大体上差不多，但也不一定是通过自己的语法生成 DOM，可以考虑下 jsx 是如何对接 react 和 vue 的',normalizedContent:'如今说起前端开发，基本上都离不开前端框架。随着前端技术不断迭代，前端框架相关的文档和社区日益完善，前端入门也越来越简单了。我们可以快速上手一些工具和框架，但常常会忽略其中的设计和原理。\n\n对框架和工具的了解不够深入，会导致我们在遇到一些偏门的问题时容易找不到方向，也不利于个人的知识领域扩展，不能很好地进行技术选型。\n\n今天，我会带你了解前端框架为什么会这么热门，以及介绍前端框架的核心能力——模板引擎的实现原理。在讲解的过程中，一些代码会以 vue.js 作为示例。\n\n我们先来看一下，为什么要使用前端框架。\n\n\n为什么要使用前端框架\n\n一个工具被大多数人使用、成为热门，离不开相关技术发展的历史进程。了解这些工具和框架出现的原因，我们可以及时掌握技术的发展方向，保持对技术的敏感度、更新自身的认知，这些都会成为我们自身的竞争力。\n\n前端框架也一样。在前端框架出现之前，jquery 也是前端开发必备的工具库，大多数项目中都会使用。短短几年间，前端开发却变得无法离开前端框架，这中间到底发生了什么呢？\n\n前端的飞速发展\n\n曾几何时，一提到前端，大家都会想到 jquery。那是 jquery 一把梭的年代，不管前端后台都会用 jquery 完成页面开发。那时候前端开发的工作倾向于切图和重构，重页面样式而轻逻辑，工作内容常常是拼接 jsp 模板、拼 php 模板以及调节浏览器兼容。\n\n为什么 jquery 那么热门呢？除了超方便的 sizzle 引擎元素选择器、简单易用的异步请求库 ajax，还有链式调用的编程方式使得代码如行云流水般流畅。jquery 提供的便捷几乎满足了当时前端的大部分工作（所以说 jquery 一把梭不是毫无道理的）。\n\n接下来短短的几年时间，前端经历了特别多的改变。随着 node.js 的出现、npm 包管理的完善，再加上热闹的开源社区，前端领域获得了千千万万开发者的支援。从页面开发到工具库开发、框架开发、脚本开发、到服务端开发，单线程的 javascript 正在不断进行自我革新，从而将领域不断拓宽，形成了如今你所能看到的、获得赋能的前端。\n\n那么，是什么原因导致了 jquery 被逐渐冷落，前端框架站上了舞台中央呢？其中的原因有很多，包括业务场景的进化、技术的更新迭代，比如前端应用逐渐复杂、单页应用的出现、前端模块化等。\n\n前端框架的出现\n\n前面第 8 讲中，我们知道了浏览器是如何渲染页面的。从用户的角度来看，浏览器生成了最终的渲染树，并通过光栅化来将页面显示在屏幕上，页面渲染的工作就完成了。\n\n实际上，浏览器页面更多的不只是静态页面的渲染，还包括点击、拖拽等事件操作以及接口请求、数据渲染到页面等动态的交互逻辑，因此我们还常常需要更新页面的内容。\n\n要理解前端框架为什么如此重要，需要先看看在框架出现前，前端开发是如何实现和用户进行交互的。\n\n这个过程跟上一讲事件驱动的内容很相似，以一个常见的表单提交作为例子，会包括编写静态页面、给对应的元素绑定对应的事件、事件触发时更新页面内容等步骤，这是最简单的页面交互。\n\n对于更新页面内容这个步骤，如果我们页面中有很多的内容需要更新，光拼接字符串我们可能就有一大堆代码。\n\n> 以下的例子，为了不占用大量的篇幅，使用了 jquery，否则代码量会更多。\n\n举个例子，抢答活动中常常会出现题目和多个答案进行选择，我们现在需要开发一个管理端，对这些抢答卡片进行管理。假设一个问题会包括两个答案，我们可以通过新增卡片的方式来添加一套问答，编辑卡片的过程包括这些步骤。\n\n1. 新增一个卡片时，通过插入 dom 节点的方式添加卡片样式。\n\nvar index = 0;\n// 用来新增一个卡片，卡片内需要填写一些内容\nfunction addcard() {\n  // 获取一个id为the-dom的元素\n  var body = $("#the-dom");\n  // 从该元素内获取class为the-class的元素\n  var adddom = body.find(".the-class");\n  // 在the-class元素前方插入一个div\n  adddom.before(\'<div class="col-lg-4" data-index="\' + index + \'"></div>\');\n  // 同时保存下来该dom节点，方便更新内容\n  var thedom = body.find(\'[data-index="\' + index + \'"]\');\n  thedom.innerhtml(\n    `<input type="text" class="form-control question" placeholder="你的问题">\n         <input type="text" class="form-control option-a" placeholder="回答1">\n         <input type="text" class="form-control option-b" placeholder="回答2">\n        `\n  );\n  // 做完上面这堆之后index自增\n  index++;\n  return thedom;\n}\n\n\n2. 卡片内编辑题目和答案时，会有字数限制（使用 jquery 对输入框的输入事件进行监听，并限制输入内容）。\n\n// thedom使用上面代码保存下来的引用\n// 问题绑定值\nthedom\n  .on("keyup", ".question", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 20);\n  })\n  // 答案a绑定值\n  .on("keyup", ".option-a", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 10);\n  })\n  // 答案b绑定值\n  .on("keyup", ".option-b", function (ev) {\n    ev.target.value = ev.target.value.substr(0, 10);\n  });\n\n\n3. 获取输入框内的内容（使用 jquery 选择元素并获取内容），用于提交到后台。\n\n// 获取卡片的输入值\n// thedom 使用上面代码保存下来的引用\nfunction getcardvalue(index) {\n  var body = $("#the-dom");\n  var thedom = body.find(\'[data-index="\' + index + \'"]\');\n  var questionname = thedom.find(".question").val();\n  var optiona = thedom.find(".option-a").val();\n  var optionb = thedom.find(".option-b").val();\n  return { questionname, optiona, optionb };\n}\n\n\n可以看到，仅是实现一个问答卡片的编辑就需要编写不少的代码，大多数代码内容都是为了拼接 html 内容、获取 dom 节点、操作 dom 节点。\n这些代码逻辑，如果我们使用 vue 来实现，只需要这么写：\n\n<template>\n  <div v-for="card in cards">\n    <input\n      type="text"\n      class="form-control question"\n      v-model="card.questionname"\n      placeholder="你的问题"\n    />\n    <input\n      type="text"\n      class="form-control option-a"\n      v-model="card.optiona"\n      placeholder="回答1"\n    />\n    <input\n      type="text"\n      class="form-control option-b"\n      v-model="card.optionb"\n      placeholder="回答2"\n    />\n  </div>\n</template>\n<script>\n  export default {\n    name: "cards",\n    data() {\n      return {\n        cards: [],\n      };\n    },\n    methods: {\n      // 添加一个卡片\n      addcard() {\n        this.cards.push({\n          questionname: "",\n          optiona: "",\n          optionb: "",\n        });\n      },\n      // 获取卡片的输入值\n      getcardvalue(index) {\n        return this.cards[index];\n      },\n    },\n  };\n<\/script>\n\n\n可见，前端框架提供了便利的数据绑定、界面更新、事件监听等 api，我们不需要再手动更新前端页面的内容、维护一大堆的 html 和变量拼接的动态内容了。\n使用前端框架对开发效率有很大的提升，同时也在一定程度上避免了代码可读性、可维护性等问题。这也是为什么前端框架这么热门，大家都会使用它来进行开发的原因。\n\n那么，前端框架是怎么做到这些的呢？要实现这些能力，离不开其中的模板引擎。\n\n\n前端框架的核心——模板引擎\n\n当用户对页面进行操作、页面内容更新，我们需要实现的功能流程包括：\n\n 1. 监听操作；\n\n 2. 获取数据变量；\n\n 3. 使用数据变量拼接成 html 模板；\n\n 4. 将 html 内容塞到页面对应的地方；\n\n 5. 将 html 片段内需要监听的点击等事件进行绑定。\n\n可以看到，实现逻辑会比较复杂和烦琐。\n\n如果使用前端框架，我们可以：\n\n * 使用将数据变量绑定到 html 模板的方式，来控制展示的内容；\n\n * 配合一些条件判断、条件循环等逻辑，控制交互的具体逻辑；\n\n * 通过改变数据变量，框架会自动更新页面内容。\n\n这样，我们可以快速高效地完成功能开发，代码的可读性和维护性都远胜于纯手工实现。\n\n如果使用数据驱动的方式，还可以通过让逻辑与 ui 解耦的方式，提升代码的可维护性。其中的数据绑定、事件绑定等功能，前端框架是依赖模板引擎的方式来实现的。\n\n以 vue 为例子，对于开发者编写的 vue 代码，vue 会将其进行以下处理从而渲染到页面中：\n\n 1. 解析语法生成 ast 对象；\n\n 2. 根据生成的 ast 对象，完成data数据初始化；\n\n 3. 根据 ast 对象和data数据绑定情况，生成虚拟 dom 对象；\n\n 4. 将虚拟 dom 对象生成真正的 dom 元素插入到页面中，此时页面会被渲染。\n\n模板引擎将模板语法进行解析，分别生成 html dom，使用像 html 拼接的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 dom 的设计，可以最大化地提升页面的性能。\n\n这些便是模板引擎主要的工作，我们来分别看一下。\n\n解析语法生成 ast 对象\n\n抽象语法树（abstract syntax tree）也称为 ast 语法树，指的是源代码语法所对应的树状结构。其实我们的 dom 结构树，也是 ast 的一种，浏览器会对 html dom 进行语法解析、并生成最终的页面。\n\n生成 ast 的过程涉及编译器的原理，一般经过以下过程。\n\n 1. 语法分析。模板引擎需要在这个过程中识别出特定的语法，比如v-if/v-for这样的指令，或是<mycustomcomponent>这样的自定义 dom 标签，还有@click/:props这样的简化绑定语法等。\n\n 2. 语义分析。这个过程会审查源程序有无语义错误，为代码生成阶段收集类型信息，一般类型检查也会在这个过程中进行。例如我们绑定了某个不存在的变量或者事件，又或者是使用了某个未定义的自定义组件等，都会在这个阶段进行报错提示。\n\n 3. 生成 ast 对象。\n\n以 vue 为例，生成 ast 的过程包括 html 模板解析、元素检查和预处理：\n\n/**\n *  将html编译成ast对象\n *  该代码片段基于vue2.x版本\n */\nexport function parse(\n  template: string,\n  options: compileroptions\n): astelement | void {\n  // 返回ast对象\n  // 篇幅原因，一些前置定义省略\n  // 此处开始解析html模板\n  parsehtml(template, {\n    expecthtml: options.expecthtml,\n    isunarytag: options.isunarytag,\n    shoulddecodenewlines: options.shoulddecodenewlines,\n    start(tag, attrs, unary) {\n      // 一些前置检查和设置、兼容处理此处省略\n      // 此处定义了初始化的元素ast对象\n      const element: astelement = {\n        type: 1,\n        tag,\n        attrslist: attrs,\n        attrsmap: makeattrsmap(attrs),\n        parent: currentparent,\n        children: [],\n      };\n      // 检查元素标签是否合法（不是保留命名）\n      if (isforbiddentag(element) && !isserverrendering()) {\n        element.forbidden = true;\n        process.env.node_env !== "production" &&\n          warn(\n            "templates should only be responsible for mapping the state to the " +\n              "ui. avoid placing tags with side-effects in your templates, such as " +\n              `<${tag}>` +\n              ", as they will not be parsed."\n          );\n      }\n      // 执行一些前置的元素预处理\n      for (let i = 0; i < pretransforms.length; i++) {\n        pretransforms[i](element, options);\n      }\n      // 是否原生元素\n      if (invpre) {\n        // 处理元素的一些属性\n        processrawattrs(element);\n      } else {\n        // 处理指令，此处包括v-for/v-if/v-once/key等等\n        processfor(element);\n        processif(element);\n        processonce(element);\n        processkey(element); // 删除结构属性\n        // 确定这是否是一个简单的元素\n        element.plain = !element.key && !attrs.length;\n        // 处理ref/slot/component等属性\n        processref(element);\n        processslot(element);\n        processcomponent(element);\n        for (let i = 0; i < transforms.length; i++) {\n          transforms[i](element, options);\n        }\n        processattrs(element);\n      }\n      // 后面还有一些父子节点等处理，此处省略\n    },\n    // 其他省略\n  });\n  return root;\n}\n\n\n到这里，vue 将开发者的模板代码解析成 ast 对象，我们来看看这样的 ast 对象是怎样生成 dom 元素的。\n\nast 对象生成 dom 元素\n\n前面提到，在编译解析和渲染过程中，模板引擎会识别和解析模板语法语义、生成 ast 对象，最后根据 ast 对象会生成最终的 dom 元素。\n\n举个例子，我们写了以下这么一段 html 模板：\n\n<div>\n  <a>123</a>\n  <p>456<span>789</span></p>\n</div>\n\n\n模板引擎可以在语法分析、语义分析等步骤后，得到这样的一个 ast 对象：\n\nthisdiv = {\n  dom: {\n    type: "dom",\n    ele: "div",\n    nodeindex: 0,\n    children: [\n      {\n        type: "dom",\n        ele: "a",\n        nodeindex: 1,\n        children: [{ type: "text", value: "123" }],\n      },\n      {\n        type: "dom",\n        ele: "p",\n        nodeindex: 2,\n        children: [\n          { type: "text", value: "456" },\n          {\n            type: "dom",\n            ele: "span",\n            nodeindex: 3,\n            children: [{ type: "text", value: "789" }],\n          },\n        ],\n      },\n    ],\n  },\n};\n\n\n这个 ast 对象维护我们需要的一些信息，包括 html 元素里：\n\n * 需要绑定哪些变量（变量更新的时候需要更新该节点内容）；\n\n * 是否有其他的逻辑需要处理（比如含有逻辑指令，如v-if、v-for等）；\n\n * 哪些节点绑定了事件监听事件（是否匹配一些常用的事件能力支持，如@click）。\n\n模板引擎会根据 ast 对象生成最终的页面片段和逻辑，在这个过程中会通过添加特殊标识（例如元素 id、属性标记等）的方式来标记 dom 节点，配合 dom 元素选择方式、事件监听方式等，在需要更新的时候可快速定位到该 dom 节点，并进行节点内容更新，从而实现页面内容的更新。\n\n目前来说，前端模板渲染的实现一般分为以下两种方式。\n\n 1. 字符串模版方式：使用拼接的方式生成 dom 字符串，直接通过innderhtml()插入页面。\n\n 2. 节点模版方式：使用createelement()/appendchild()/textcontent等方法动态地插入 dom 节点。\n\n在使用字符串模版的时候，我们将nodeindex绑定在元素属性上，主要用于在数据更新时追寻节点进行内容更新。\n\n在使用节点模版的时候，我们可在创建节点时将该节点保存下来，直接用于数据更新：\n\n// 假设这是一个生成 dom 的过程，包括 innerhtml 和事件监听\nfunction generatedom(astobject) {\n  const { dom, binding = [] } = astobject;\n  // 生成dom，这里假装当前节点是basedom\n  basedom.innerhtml = getdomstring(dom);\n  // 对于数据绑定的，来进行监听更新吧\n  basedom.addeventlistener("data:change", (name, value) => {\n    // 寻找匹配的数据绑定\n    const obj = binding.find((x) => x.valuename == name);\n    // 若找到值绑定的对应节点，则更新其值。\n    if (obj) {\n      basedom.find(`[data-node-index="${obj.nodeindex}"]`).innerhtml = value;\n    }\n  });\n}\n// 获取dom字符串，这里简单拼成字符串\nfunction getdomstring(domobj) {\n  // 无效对象返回\'\'\n  if (!domobj) return "";\n  const { type, children = [], nodeindex, ele, value } = domobj;\n  if (type == "dom") {\n    // 若有子对象，递归返回生成的字符串拼接\n    const childstring = "";\n    children.foreach((x) => {\n      childstring += getdomstring(x);\n    });\n    // dom对象，拼接生成对象字符串\n    return `<${ele} data-node-index="${nodeindex}">${childstring}</${ele}>`;\n  } else if (type == "text") {\n    // 若为textnode，返回text的值\n    return value;\n  }\n}\n\n\n通过上面的方式，前端框架实现了将 ast 对象生成 dom 元素，并将这些 dom 元素渲染或更新到页面上。\n\n或许你会觉得疑惑：原本就是一个<div>html 模板，经过 ast 生成一个对象，最终还是生成一个<div>dom 节点，看起来好像挺多余的。\n\n实际上，在这个过程中，模板引擎可以实现更多功能。\n\n模板引擎可以做更多\n\n将 html 模板解析成 ast 对象，再根据 ast 对象生成 dom 节点，在这个过程中前端框架可以实现以下功能：\n\n 1. 排除无效 dom 元素（非自定义组件、也非默认组件的 dom 元素），在构建阶段可及时发现并进行报错；\n\n 2. 可识别出自定义组件，并渲染对应的组件；\n\n 3. 可方便地实现数据绑定、事件绑定等功能；\n\n 4. 为虚拟 dom diff 过程打下铺垫；\n\n 5. html 转义（预防 xss 漏洞）。\n\n这里我们以第 5 点预防 xss 漏洞为例子，详细地介绍一下模板引擎是如何避免 xss 攻击的。\n\n预防 xss 漏洞\n\n我们知道 xss 的整个攻击过程大概为：\n\n 1. 攻击者提交含有恶意代码的内容（比如 javascript 脚本）；\n\n 2. 页面渲染的时候，这些内容未被过滤就被加载处理，比如获取 cookie、执行操作等；\n\n 3. 其他用户在浏览页面的时候，就会在加载到恶意代码时受到攻击。\n\n要避免网站用户受到 xss 攻击，主要方法是将用户提交的内容进行过滤处理。大多数前端框架会自带 html 转义功能，从而避免的 xss 攻击。\n\n以 vue 为例，使用默认的数据绑定方式（双大括号、v-bind等）会进行 html 转义，将数据解释为普通文本，而非 html 代码。\n\n除此预防 xss 漏洞之外，前端框架还做了一些性能、安全性等方面的优化，也提供了一些用于项目开发配套的工具，包括路由的管理、状态和数据的管理等工具。\n\n\n小结\n\n今天我带大家了解了前端框架的出现，由于前端框架帮开发者解决了很多重复性的工作（拼接 html 模板、dom 元素查找、dom 元素事件监听等），极大地提升了开发者的效率，同时还提升了代码的可读性和可维护性，因此受到很多前端开发的追捧。\n\n除此之外，我还介绍了前端框架中模板引擎的实现原理，包括解析语法生成 ast 对象、根据 ast 对象生成 dom 元素，并对生成的 dom 元素进行标记，则可以在变量改变的时候，解析找到相应的 dom 元素进行内容的更新。\n\n在了解这些内容之后，我们可以在页面渲染遇到性能问题的时候，根据所使用框架的具体实现，找到可能导致页面渲染卡顿或是不流畅的原因。除此之外，在使用框架的过程中，遇到一些语法报错、xss 安全漏洞等问题的时候，也可以快速找到解决办法。\n\n今日思考：react.js 中的 jsx 和模板引擎是什么关系？在留言区写出你的想法！\n\n----------------------------------------\n\n\n# 精选评论\n\n# **宇：\n\n> jsx会被babel编译成react.createelement()，用来创建相应的虚拟dom对象，后面会被reactdom或者react native等不同平台的渲染库渲染成ui或者ssr。之所以发明jsx是因为，react.createelement太过繁琐，jsx可以像写html一样写ui，同时也保留了部分js的能力。题外话：其实facebook最初并没有打算让createelement作为jsx的编译产物，因为它里面的defaultvalue，proptype，ref key的拦截等等逻辑比较浪费性能，对props的属性有o(n)级别的复杂度，本来只是作为让用户临时手动生产虚拟dom的一个补充手段，但因为当时只有它是最好的选择，所以才这样了，react17以后可能有变化。\n\n# *浩：\n\n> 今日思考的回答：react中的jsx本质是javascript语法的扩展，充分具备javascript能力，这就能让developer像写javascript一样写ui，我们写的虽然是jsx，借助babel等类似的工具的转化，最终还是会编译成react.createelement()这样的函数去生成虚拟dom，后面生成ast,再由ast生成真实dom,这些过程应该跟老师经的一样吧，有写错的地方，望老师批评指正。\n\n# 856：\n\n> jsx 是把代码转成react可以解读的代码，并没有生成dom模板引擎是通过自己的语法生成dom 相同点都是用自己的语法 写html ,底层实现操作dom\n\n#     讲师回复：\n\n>     大体上差不多，但也不一定是通过自己的语法生成 dom，可以考虑下 jsx 是如何对接 react 和 vue 的',charsets:{cjk:!0},lastUpdated:"2022/04/15, 02:26:10",lastUpdatedTimestamp:164998957e4},{title:"为什么小程序特立独行",frontmatter:{title:"为什么小程序特立独行",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/49a69e/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/11.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C.html",relativePath:"01.前端/01.前端开发笔记/11.为什么小程序特立独行.md",key:"v-00f44386",path:"/pages/49a69e/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5427}],headersStr:"精选评论",content:"这几年小程序突然火了起来，其用完就走、无须安装的便捷设计吸引了越来越多的用户愿意使用。用户的热度加上微信给小程序提供的顶级流量入口，也吸引了不少前端开发者的加入。\n\n但当前端开发者带着固有的认知进行小程序开发的时候，却发现很多地方都行不通，比如页面元素无法获取，只能通过setData更新页面，还有各种浏览器接口都无法正常使用。所以，很多人都难以理解，认为小程序偏偏特立独行为难开发者，其实很大程度上是因为小程序基于安全和管控考虑下的设计。\n\n那么，究竟是出于怎样的考虑，小程序才被设计成这样？它到底又做了怎样的事情，来尝试解决以上问题呢？今天，我来带你重新认识下小程序。\n\n\n小程序在思考什么\n\n在微信 App 里，小程序直接开放给所有用户使用，这意味着可能有十几亿人会用到这个工具。面对如此大的流量入口，吸引了很多有心人的眼球。\n\n当年互联网还不成熟的时候，许多网页开发没有做好 XSS 和 CSRF 这样的漏洞保护，导致出现用户账户被盗用、财产被转移等问题。对于小程序来说，不仅需要对各种小程序进行内容的管控，同样需要给用户和开发者提供有安全保障的环境。\n\n小程序如何保障用户安全\n\n我们知道，在 Web 开发中，开发者可以使用 JavaScript 脚本来操作 DOM，这意味着恶意攻击者同样可以通过注入 JavaScript 脚本的方式来操控用户的页面。前面提到的 XSS 攻击便是利用了这样的漏洞，从而危害用户和网站的安全。\n\n除此之外，有些恶意的开发者也可能想要从小程序中盗取用户信息。比如，小程序提供了<open-data>组件，用于无须授权的情况下可展示用户的敏感信息（昵称、头像、性别、地理位置等），如果开发者直接通过 DOM API 获取到这些信息，意味着只要用户打开了这个小程序，在未授权的情况下自己的相关信息就会被盗取。\n\n对于微信来说，这些都是非常危险又不可控的问题，如果可以从平台的角度解决，就可以保障用户和商户小程序的安全。在此基础上，小程序提出了双线程设计。\n\n在介绍小程序的双线程设计之前，我们先来思考一下上面提到的安全问题要怎么避免。\n\n我们能看到，很多风险都来自 JavaScript 脚本对网页中 DOM 的访问和操作。想要解决这个风险就得将 JavaScript 代码放置在没有浏览器环境的沙箱环境中运行。\n\n沙箱环境听起来很复杂，但其实前端开发者经常接触到：除了浏览器环境以外，JavaScript 还会被运行在 Node.js 环境中。Node.js 是基于 Chrome V8 引擎的 JavaScript 运行环境，该环境中不存在 DOM API、window、document等对象 API 和全局对象，因此也更无操作 DOM 节点一说。\n\n小程序也是同样的思路，它使用 iOS 内置的 JavaScriptCore 框架和在 Android 的 JSCore 引擎（最初为腾讯 x5 内核，后来是 V8 引擎），提供了一个没有浏览器相关接口的环境，用于 JavaScript 脚本的执行。\n\n在这样的环境里，开发者无法使用浏览器相关的 API 来改变页面内容、获取敏感信息、随意跳转页面，当然也无法对用户进行恶意的攻击了。也正因为如此，在小程序里，是不存在 XSS 风险的，开发者无须主动进行防范，用户更是可以安心使用。\n\n以上就是小程序双线程设计的背景，下面我们来看一下小程序的双线程是怎样设计的。\n\n小程序的双线程设计\n\n上面我们提到，小程序中使用了沙箱环境来运行 JavaScript 代码，在这个环境中无法进行一些 DOM 操作。那么，开发者如何更新页面内容、控制页面的展示呢？答案是使用setData()。\n\n为什么使用setData()可以更新页面内容呢？这是因为在小程序中，界面渲染相关任务则是由单独的 WebView 线程来完成。也就是说，在小程序中，JavaScript 脚本的执行和界面渲染不在一个线程中。\n\n当我们在 JavaScript 中使用setData()更新数据的时候，实际上这些数据会通过客户端进行跨线程通信，然后传递到 WebView 页面中，WebView 页面则根据约定的规则来更新到页面中，过程如下图所示。\n\n\n\n由于 WebView 页面中获取到的只是类似 JSON 格式的数据，不存在执行 JavaScript 脚本的情况。因此有效地防范了 XSS 攻击，也防止了开发者恶意爬取用户敏感信息。\n\n现在，我们能看到，小程序中分为渲染层（由 WebView 线程管理）和逻辑层（由客户端 JavaScript 解释引擎线程管理）：\n\n\n\n这就是小程序的双线程设计。显然，它带来了一些好处：\n\n 1. 可以防止恶意攻击者的 XSS 攻击；\n\n 2. 可以防止开发者恶意盗取用户敏感信息；\n\n 3. 提升页面加载性能。\n\n关于第 3 点，我们在第 1 讲的时候就讲过，在浏览器中 GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。它们之间是互斥的关系，当 JavaScript 引擎执行时，GUI 线程会被挂起。而在小程序中，由于 JavaScript 的执行和页面渲染不在一个页面中，因此也不存在阻塞的问题，页面加载得以更加流畅。\n\n小程序开发者的痛点\n\n虽然小程序的双线程设计解决了用户安全的问题，但同时也给开发者带来了一些问题：\n\n 1. 在浏览器中可以运行的 DOM、BOM 等对象和 API，都无法在小程序中使用；\n\n 2. 小程序的一些 API 使用方式与浏览器不一致（请求、缓存等）；\n\n 3. 逻辑层和渲染层的通信依赖客户端进行通信，当通信过于频繁的场景可能导致性能问题。\n\n其中，第 1 点和第 2 点导致前端开发者无法将 Web 页面直接在小程序中复用，同时需要掌握小程序自身的 API 才能熟练地进行开发。这意味着进行小程序开发有门槛和学习成本，因此开发者体验并不会很好。\n\n关于第 3 点，页面进行大数据和高频率的setData()时，会出现页面卡顿的问题。因此在强交互的场景下，用户体验会很糟糕。\n\n在这样的种种情况下，我们跑在浏览器中的代码，如果想要在小程序中运行，必须要做很多兼容处理，甚至需要重新开发来实现。\n\n那为什么一定要使用小程序呢，直接用 H5 不好吗？这是因为小程序有微信流量，微信平台提供给小程序的流量对很多开发者来说都是不愿舍弃的。因此即使无法进行从网页开发到小程序开发的平滑过渡，很多开发者依然选择了进行小程序开发。\n\n其实小程序也做了不少的尝试去抹平小程序和 Web 的差距，从而提升小程序的开发体验，比如这些措施。\n\n 1. 提供了Kbone解决方案，用于支持让 Web 项目同时运行在小程序端和 Web 端。Kbone 通过使用适配层的方式，模拟了一套可运行在小程序中的浏览器对象，提供了基础的 DOM/BOM API，因此 Web 应用可通过 Kbone 运行在小程序中。\n\n 2. 由于原生组件的引入带来的渲染层级无法控制的问题，通过提供同屏渲染的方式来让开发者更好地控制组件样式。\n\n 3. 开发者工具提供了丰富的调试能力，也提供了体验评分等功能，来引导开发者如何进行项目优化。\n\n除了这些，小程序还做了很多事情来提升用户体验，我们一起来看一下。\n\n\n小程序如何提升用户体验\n\n目前，主流的 App 主要有 3 种，它们对应了 3 种渲染模式：\n\n 1. Native App，使用了 Native（纯客户端原生技术）渲染；\n\n 2. Web App，使用了 WebView（纯 Web 技术）渲染；\n\n 3. Hybrid App，使用了 WebView+原生组件（Hybrid 技术）渲染。\n\n小程序使用的是 WebView + 原生组件，即 Hybrid 方式。显然，这种方式结合了 Native 和 Webview 的一些优势，让开发者既可以享受 Webview 页面的低门槛和在线更新，又可以使用部分流畅的 Native 原生组件，同时通过代码包上传、审核、发布的方式来对内容进行管控。\n\n那么，使用了 Hybrid 渲染模式的小程序，带来了哪些提升用户体验的优势呢？\n\n引入原生组件提升用户交互体验\n\n我们知道，小程序中每一次逻辑层和渲染层的通信，都需要经过 Native，这意味着一次的用户的交互过程会带来四次的通信：\n\n 1. 渲染层 → Native（点击事件）；\n\n 2. Native → 逻辑层（点击事件）；\n\n 3. 逻辑层 → Native（setData）；\n\n 4. Native → 渲染层（setData）。\n\n对于这种强交互的场景，小程序引入了原生组件，过程如下图所示。\n\n\n\n我们可以看到，引入原生组件之后，原生组件可以直接和逻辑层通信，有效地减少逻辑层和渲染层的频繁通信问题。像<input>、<textarea>这些频繁交互的输入框组件，以及画布<canvas>组件、地图<map>这样交互复杂的组件，直接使用 Native 原生组件的方式既减少了客户端通信，也减轻了渲染层的工作。\n\n引入原生组件的方式提升用户在小程序中频繁操作场景下的交互体验，依赖了 Native 技术的能力。除了这些，小程序在运行机制（包括启动和加载）上也结合客户端做了不少的体验优化工作，我们一起来看一下。\n\n通过页面预渲染减少启动和加载耗时\n\n前面我们介绍了小程序的双线程设计，你应该知道在小程序里 JavaScript 代码运行在逻辑层中，页面渲染的逻辑则运行在 WebView 渲染层中。\n\n我们重新来看这张图：\n\n\n\n我们能看到渲染层里有多个 WebView，这是因为在小程序中为了方便用户可快速地前进和回退，存在着多个界面，而每个界面都是一个单独的 WebView 线程，因此会有多个 WebView。\n\n这和小程序的启动和加载有什么关系呢？\n\n首先，在小程序启动之前，客户端会提前准备好一个 WebView，用于快速展示小程序首页。同时，在每次这个准备好的 WebView 被小程序使用和渲染时，客户端也都会提前准备好一个新的 WebView。因此，开发者在调用wx.navigateTo时，用户可以很快看到新的页面。\n\n除了 WebView 的准备，小程序在启动和加载过程中，客户端还做了这些工作。\n\n 1. 基于 JavaScript 编写的基础库，会被提前内置在客户端中。基础库提供了小程序运行的基础能力，包括渲染机制相关基础代码、封装后的内置组件、逻辑层基础 API 等，因此小程序在启动时，都会先注入基础库代码。\n\n 2. 当用户打开小程序后，客户端开始下载业务代码，同时会在本地创建内置的基础 UI 组件，初始化小程序的首页。此时，小程序展示的是客户端提供的固定的启动界面。\n\n 3. 步骤 2 准备完成后，客户端就会开始注入业务代码并运行。\n\n最后，我们再来梳理下小程序的启动过程。\n\n * 启动前：提前准备好一个 WebView 页面，并进行初始化，在初始化过程中会注入小程序基础库，以提供小程序运行的基础环境。\n\n * 用户打开小程序：下载业务代码，同时初始化小程序的首页，当业务代码下载完成后，开始运行业务代码。\n\n这个过程可以用一张图来表示。\n\n\n\n我们可以看到，微信小程序通过基础库的内置、页面的预渲染、小程序加载时提供友好的交互界面等方式，使小程序可以尽快地加载，给到用户更好的体验。除此之外，小程序还通过使用缓存、热启动机制、提供分包加载和数据预拉取等方式，同样减少了用户的等待时间。\n\n\n小结\n\n或许对于一份工作来说，开发者只想简单快速地完成项目开发。但对于一位前端来说，小程序的设计中有很多值得学习的内容，正如我们今天所介绍的：\n\n * 为了保障用户的安全，提出了双线程的设计（渲染层由 WebView 线程管理、逻辑层由客户端 JavaScript 解释引擎线程管理）；\n\n * 为了减少小程序和 Web 开发的差异，提供了 Knone 解决方案；\n\n * 为了降低开发者的门槛，提供了功能丰富的开发者工具，提供了小程序优化的解决方案；\n\n * 为了提升用户体验，小程序结合客户端的能力引入了原生组件，并优化了小程序的启动和加载过程。\n\n小程序之所以这么特殊，并不是为了特立独行，而是为了从平台的角度来提供给开发者和用户更好的体验和安全保障。\n\n其实，小程序的设计远不止于此。如果你继续深挖，可以看到里面还有虚拟 DOM 的设计、Shadow DOM 模型、自定义组件的渲染过程等，同时还有小程序在载入、启动、更新版本等各种流程中的一些机制。除此之外，小程序和 Serverless 的结合极大地降低了开发者的门槛，同时也降低了开发成本，带来了友好的开发体验。\n\n小程序中的很多设计都可以作为参考，比如页面预渲染的设计可以在提升首屏加载速度时作为参考。你是否也想到在哪些场景下可以参考的设计吗？或者你认为小程序是否还有更好的优化方案呢？欢迎在留言区说说你的想法。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **恒：\n\n> 浏览器中js引擎线程和GUI渲染线程互斥这个理解是错误的吧。 js的执行和 layout计算都是在一个线程一般我们叫js主线程，这也是js执行为什么阻塞页面渲染的原因。但是真正做渲染的也就是做珊格化的是珊格化线程。而珊格化线程和js主线程是不互斥的。顺便问一下 作者的小程序书啥时候出版。\n\n#     讲师回复：\n\n>     HTML 解析器找到",normalizedContent:"这几年小程序突然火了起来，其用完就走、无须安装的便捷设计吸引了越来越多的用户愿意使用。用户的热度加上微信给小程序提供的顶级流量入口，也吸引了不少前端开发者的加入。\n\n但当前端开发者带着固有的认知进行小程序开发的时候，却发现很多地方都行不通，比如页面元素无法获取，只能通过setdata更新页面，还有各种浏览器接口都无法正常使用。所以，很多人都难以理解，认为小程序偏偏特立独行为难开发者，其实很大程度上是因为小程序基于安全和管控考虑下的设计。\n\n那么，究竟是出于怎样的考虑，小程序才被设计成这样？它到底又做了怎样的事情，来尝试解决以上问题呢？今天，我来带你重新认识下小程序。\n\n\n小程序在思考什么\n\n在微信 app 里，小程序直接开放给所有用户使用，这意味着可能有十几亿人会用到这个工具。面对如此大的流量入口，吸引了很多有心人的眼球。\n\n当年互联网还不成熟的时候，许多网页开发没有做好 xss 和 csrf 这样的漏洞保护，导致出现用户账户被盗用、财产被转移等问题。对于小程序来说，不仅需要对各种小程序进行内容的管控，同样需要给用户和开发者提供有安全保障的环境。\n\n小程序如何保障用户安全\n\n我们知道，在 web 开发中，开发者可以使用 javascript 脚本来操作 dom，这意味着恶意攻击者同样可以通过注入 javascript 脚本的方式来操控用户的页面。前面提到的 xss 攻击便是利用了这样的漏洞，从而危害用户和网站的安全。\n\n除此之外，有些恶意的开发者也可能想要从小程序中盗取用户信息。比如，小程序提供了<open-data>组件，用于无须授权的情况下可展示用户的敏感信息（昵称、头像、性别、地理位置等），如果开发者直接通过 dom api 获取到这些信息，意味着只要用户打开了这个小程序，在未授权的情况下自己的相关信息就会被盗取。\n\n对于微信来说，这些都是非常危险又不可控的问题，如果可以从平台的角度解决，就可以保障用户和商户小程序的安全。在此基础上，小程序提出了双线程设计。\n\n在介绍小程序的双线程设计之前，我们先来思考一下上面提到的安全问题要怎么避免。\n\n我们能看到，很多风险都来自 javascript 脚本对网页中 dom 的访问和操作。想要解决这个风险就得将 javascript 代码放置在没有浏览器环境的沙箱环境中运行。\n\n沙箱环境听起来很复杂，但其实前端开发者经常接触到：除了浏览器环境以外，javascript 还会被运行在 node.js 环境中。node.js 是基于 chrome v8 引擎的 javascript 运行环境，该环境中不存在 dom api、window、document等对象 api 和全局对象，因此也更无操作 dom 节点一说。\n\n小程序也是同样的思路，它使用 ios 内置的 javascriptcore 框架和在 android 的 jscore 引擎（最初为腾讯 x5 内核，后来是 v8 引擎），提供了一个没有浏览器相关接口的环境，用于 javascript 脚本的执行。\n\n在这样的环境里，开发者无法使用浏览器相关的 api 来改变页面内容、获取敏感信息、随意跳转页面，当然也无法对用户进行恶意的攻击了。也正因为如此，在小程序里，是不存在 xss 风险的，开发者无须主动进行防范，用户更是可以安心使用。\n\n以上就是小程序双线程设计的背景，下面我们来看一下小程序的双线程是怎样设计的。\n\n小程序的双线程设计\n\n上面我们提到，小程序中使用了沙箱环境来运行 javascript 代码，在这个环境中无法进行一些 dom 操作。那么，开发者如何更新页面内容、控制页面的展示呢？答案是使用setdata()。\n\n为什么使用setdata()可以更新页面内容呢？这是因为在小程序中，界面渲染相关任务则是由单独的 webview 线程来完成。也就是说，在小程序中，javascript 脚本的执行和界面渲染不在一个线程中。\n\n当我们在 javascript 中使用setdata()更新数据的时候，实际上这些数据会通过客户端进行跨线程通信，然后传递到 webview 页面中，webview 页面则根据约定的规则来更新到页面中，过程如下图所示。\n\n\n\n由于 webview 页面中获取到的只是类似 json 格式的数据，不存在执行 javascript 脚本的情况。因此有效地防范了 xss 攻击，也防止了开发者恶意爬取用户敏感信息。\n\n现在，我们能看到，小程序中分为渲染层（由 webview 线程管理）和逻辑层（由客户端 javascript 解释引擎线程管理）：\n\n\n\n这就是小程序的双线程设计。显然，它带来了一些好处：\n\n 1. 可以防止恶意攻击者的 xss 攻击；\n\n 2. 可以防止开发者恶意盗取用户敏感信息；\n\n 3. 提升页面加载性能。\n\n关于第 3 点，我们在第 1 讲的时候就讲过，在浏览器中 gui 渲染线程负责渲染浏览器界面 html 元素，javascript 引擎线程主要负责处理 javascript 脚本程序。它们之间是互斥的关系，当 javascript 引擎执行时，gui 线程会被挂起。而在小程序中，由于 javascript 的执行和页面渲染不在一个页面中，因此也不存在阻塞的问题，页面加载得以更加流畅。\n\n小程序开发者的痛点\n\n虽然小程序的双线程设计解决了用户安全的问题，但同时也给开发者带来了一些问题：\n\n 1. 在浏览器中可以运行的 dom、bom 等对象和 api，都无法在小程序中使用；\n\n 2. 小程序的一些 api 使用方式与浏览器不一致（请求、缓存等）；\n\n 3. 逻辑层和渲染层的通信依赖客户端进行通信，当通信过于频繁的场景可能导致性能问题。\n\n其中，第 1 点和第 2 点导致前端开发者无法将 web 页面直接在小程序中复用，同时需要掌握小程序自身的 api 才能熟练地进行开发。这意味着进行小程序开发有门槛和学习成本，因此开发者体验并不会很好。\n\n关于第 3 点，页面进行大数据和高频率的setdata()时，会出现页面卡顿的问题。因此在强交互的场景下，用户体验会很糟糕。\n\n在这样的种种情况下，我们跑在浏览器中的代码，如果想要在小程序中运行，必须要做很多兼容处理，甚至需要重新开发来实现。\n\n那为什么一定要使用小程序呢，直接用 h5 不好吗？这是因为小程序有微信流量，微信平台提供给小程序的流量对很多开发者来说都是不愿舍弃的。因此即使无法进行从网页开发到小程序开发的平滑过渡，很多开发者依然选择了进行小程序开发。\n\n其实小程序也做了不少的尝试去抹平小程序和 web 的差距，从而提升小程序的开发体验，比如这些措施。\n\n 1. 提供了kbone解决方案，用于支持让 web 项目同时运行在小程序端和 web 端。kbone 通过使用适配层的方式，模拟了一套可运行在小程序中的浏览器对象，提供了基础的 dom/bom api，因此 web 应用可通过 kbone 运行在小程序中。\n\n 2. 由于原生组件的引入带来的渲染层级无法控制的问题，通过提供同屏渲染的方式来让开发者更好地控制组件样式。\n\n 3. 开发者工具提供了丰富的调试能力，也提供了体验评分等功能，来引导开发者如何进行项目优化。\n\n除了这些，小程序还做了很多事情来提升用户体验，我们一起来看一下。\n\n\n小程序如何提升用户体验\n\n目前，主流的 app 主要有 3 种，它们对应了 3 种渲染模式：\n\n 1. native app，使用了 native（纯客户端原生技术）渲染；\n\n 2. web app，使用了 webview（纯 web 技术）渲染；\n\n 3. hybrid app，使用了 webview+原生组件（hybrid 技术）渲染。\n\n小程序使用的是 webview + 原生组件，即 hybrid 方式。显然，这种方式结合了 native 和 webview 的一些优势，让开发者既可以享受 webview 页面的低门槛和在线更新，又可以使用部分流畅的 native 原生组件，同时通过代码包上传、审核、发布的方式来对内容进行管控。\n\n那么，使用了 hybrid 渲染模式的小程序，带来了哪些提升用户体验的优势呢？\n\n引入原生组件提升用户交互体验\n\n我们知道，小程序中每一次逻辑层和渲染层的通信，都需要经过 native，这意味着一次的用户的交互过程会带来四次的通信：\n\n 1. 渲染层 → native（点击事件）；\n\n 2. native → 逻辑层（点击事件）；\n\n 3. 逻辑层 → native（setdata）；\n\n 4. native → 渲染层（setdata）。\n\n对于这种强交互的场景，小程序引入了原生组件，过程如下图所示。\n\n\n\n我们可以看到，引入原生组件之后，原生组件可以直接和逻辑层通信，有效地减少逻辑层和渲染层的频繁通信问题。像<input>、<textarea>这些频繁交互的输入框组件，以及画布<canvas>组件、地图<map>这样交互复杂的组件，直接使用 native 原生组件的方式既减少了客户端通信，也减轻了渲染层的工作。\n\n引入原生组件的方式提升用户在小程序中频繁操作场景下的交互体验，依赖了 native 技术的能力。除了这些，小程序在运行机制（包括启动和加载）上也结合客户端做了不少的体验优化工作，我们一起来看一下。\n\n通过页面预渲染减少启动和加载耗时\n\n前面我们介绍了小程序的双线程设计，你应该知道在小程序里 javascript 代码运行在逻辑层中，页面渲染的逻辑则运行在 webview 渲染层中。\n\n我们重新来看这张图：\n\n\n\n我们能看到渲染层里有多个 webview，这是因为在小程序中为了方便用户可快速地前进和回退，存在着多个界面，而每个界面都是一个单独的 webview 线程，因此会有多个 webview。\n\n这和小程序的启动和加载有什么关系呢？\n\n首先，在小程序启动之前，客户端会提前准备好一个 webview，用于快速展示小程序首页。同时，在每次这个准备好的 webview 被小程序使用和渲染时，客户端也都会提前准备好一个新的 webview。因此，开发者在调用wx.navigateto时，用户可以很快看到新的页面。\n\n除了 webview 的准备，小程序在启动和加载过程中，客户端还做了这些工作。\n\n 1. 基于 javascript 编写的基础库，会被提前内置在客户端中。基础库提供了小程序运行的基础能力，包括渲染机制相关基础代码、封装后的内置组件、逻辑层基础 api 等，因此小程序在启动时，都会先注入基础库代码。\n\n 2. 当用户打开小程序后，客户端开始下载业务代码，同时会在本地创建内置的基础 ui 组件，初始化小程序的首页。此时，小程序展示的是客户端提供的固定的启动界面。\n\n 3. 步骤 2 准备完成后，客户端就会开始注入业务代码并运行。\n\n最后，我们再来梳理下小程序的启动过程。\n\n * 启动前：提前准备好一个 webview 页面，并进行初始化，在初始化过程中会注入小程序基础库，以提供小程序运行的基础环境。\n\n * 用户打开小程序：下载业务代码，同时初始化小程序的首页，当业务代码下载完成后，开始运行业务代码。\n\n这个过程可以用一张图来表示。\n\n\n\n我们可以看到，微信小程序通过基础库的内置、页面的预渲染、小程序加载时提供友好的交互界面等方式，使小程序可以尽快地加载，给到用户更好的体验。除此之外，小程序还通过使用缓存、热启动机制、提供分包加载和数据预拉取等方式，同样减少了用户的等待时间。\n\n\n小结\n\n或许对于一份工作来说，开发者只想简单快速地完成项目开发。但对于一位前端来说，小程序的设计中有很多值得学习的内容，正如我们今天所介绍的：\n\n * 为了保障用户的安全，提出了双线程的设计（渲染层由 webview 线程管理、逻辑层由客户端 javascript 解释引擎线程管理）；\n\n * 为了减少小程序和 web 开发的差异，提供了 knone 解决方案；\n\n * 为了降低开发者的门槛，提供了功能丰富的开发者工具，提供了小程序优化的解决方案；\n\n * 为了提升用户体验，小程序结合客户端的能力引入了原生组件，并优化了小程序的启动和加载过程。\n\n小程序之所以这么特殊，并不是为了特立独行，而是为了从平台的角度来提供给开发者和用户更好的体验和安全保障。\n\n其实，小程序的设计远不止于此。如果你继续深挖，可以看到里面还有虚拟 dom 的设计、shadow dom 模型、自定义组件的渲染过程等，同时还有小程序在载入、启动、更新版本等各种流程中的一些机制。除此之外，小程序和 serverless 的结合极大地降低了开发者的门槛，同时也降低了开发成本，带来了友好的开发体验。\n\n小程序中的很多设计都可以作为参考，比如页面预渲染的设计可以在提升首屏加载速度时作为参考。你是否也想到在哪些场景下可以参考的设计吗？或者你认为小程序是否还有更好的优化方案呢？欢迎在留言区说说你的想法。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **恒：\n\n> 浏览器中js引擎线程和gui渲染线程互斥这个理解是错误的吧。 js的执行和 layout计算都是在一个线程一般我们叫js主线程，这也是js执行为什么阻塞页面渲染的原因。但是真正做渲染的也就是做珊格化的是珊格化线程。而珊格化线程和js主线程是不互斥的。顺便问一下 作者的小程序书啥时候出版。\n\n#     讲师回复：\n\n>     html 解析器找到",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/04.更多.md",key:"v-259c1a0e",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/21, 12:13:04",lastUpdatedTimestamp:1645445584e3},{title:"单页应用与前端路由库设计原理",frontmatter:{title:"单页应用与前端路由库设计原理",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/f761ed/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/12.%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/01.前端开发笔记/12.单页应用与前端路由库设计原理.md",key:"v-764776e4",path:"/pages/f761ed/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4959}],headersStr:"精选评论",content:'在第 6 讲和第 8 讲的内容中，我介绍了浏览器中页面是如何进行请求和渲染的。在单页应用出现以前，浏览器通过 HTTP 请求向服务端请求页面内容的时候，服务端会根据页面不同的 URL 路由，拼接出相应的页面视图片段，最终以 HTML 的方式返回给浏览器，浏览器再进行解析和渲染。\n\n这种多个页面间没有关系、各自为完整页面的应用，称之为多页应用。我们熟悉的 JSP、PHP 也都是通过拼接 HTML 模板的方式，来给浏览器提供完整的页面内容。\n\n如今，大多数的前端应用都使用单页应用的方式来实现。那么什么是单页应用呢？使用单页应用的优势是什么？为什么单页应用流行一段时间之后，现在又有人开始回到多页应用的方式呢？\n\n下面我们来一探究竟。\n\n\n单页应用的出现\n\n首先，单页应用与多页应用的区别在于：\n\n * 多页应用是由服务端进行 HTML 模板拼接的，各个页面间没有直接关系；\n\n * 单页应用便是将页面内容的控制权交给前端来处理，通过使用一个前端页面+多个页面片段的方式进行渲染。\n\n当页面以多页应用的方式进行加载时，如果发生页面间的跳转，常常会导致整个页面都需要重新加载。这是因为当页面路由发生了变化，浏览器会重新向服务端获取相应的内容，而服务端则会根据新的 URL 再次进行 HTML 模板拼接，并返回给前端。\n\n在这个过程中，用户会看到页面重新变回了白屏，然后再出现内容，体验很糟糕。使用这种方式加载页面，整个页面都需要重新加载，导致体验不够友好。\n\n除此之外，由于页面中整个 HTML 内容都需要重新加载，多页应用还存在以下问题：\n\n 1. 静态资源无法有效复用，包括 Javascript 脚本和 CSS 内容；\n\n 2. 原有的页面状态、用户状态无法保留，依赖 URL、Cookie、本地缓存等获取用户数据。\n\n其实在大多数情况下，对于同一个网站，不同 URL 的页面其实整体骨架都很相似，像网站导航栏、顶部菜单栏、底部网站相关内容等都是相同的，使用多页应用的方式会导致这些内容也重新加载。\n\n既然如此，那么是否可以使用页面局部刷新的方式来更新页面内容呢？在第 10 讲中其实我也有介绍，如今流行的 Angular、React、Vue 等这些前端框架都是通过将某个数据变量关联到页面的某块内容展示的方式，实现页面的局部更新。\n\n但只有局部刷新的能力还是不够的，因为即使页面内容更新了，如果页面的 URL 没有发生变化，当用户刷新页面的时候，可能会丢失当前的页面内容。因此，我们需要在前端配合控制路由的方式来控制页面展示，这就是单页应用。\n\n显然，单页应用的出现带来以下的好处：\n\n 1. 通用的静态资源（比如 jQuery、Axios、Boostrap 等）不需要重新加载；\n\n 2. 页面的数据状态和用户状态依然保留；\n\n 3. 局部页面内容更新，页面切换快，用户体验好。\n\n但是，单页应用同样存在着一些问题，这些问题会影响着项目的选型，也因此出现了服务端渲染等解决方案，我们一起来看一下。\n\n\n单页应用的问题\n\n由于要启用单页应用，浏览器在首次打开页面的时候，除了加载固定的脚本和样式文件以外，页面流程大概是这样的。\n\n 1. 浏览器请求服务端，服务端返回固定静态资源+基础的 HTML 内容+前端路由库。\n\n 2. 由于是前端进行渲染，因此在一般情况下，服务端返回的 HTML 内容基本上<body>为空。前端在页面进行加载的时候，需要继续向服务端发起 Ajax 请求，获取页面渲染需要的数据。\n\n 3. 服务端根据请求内容，给前端返回相应的数据。\n\n 4. 前端拿到数据后，根据当前的 URL 信息来生成相应的内容，进行页面的二次渲染，此时页面才最终加载完成。\n\n可以看到，单页应用相比多页应用的优势主要在于页面切换时。在首次打开的时候，多页应用可以直接返回用于最终渲染的页面，而单页应用则需要自行进行计算和组装，中间过程很可能还涉及数据的二次请求，因此会比多页应用慢。\n\n除此之外，由于搜索引擎只识别 HTML 内容，单页应用更多依赖 Javascript 进行 HTML 拼接，因此对 SEO（search engine optimization 简写为 SEO，搜索引擎优化）的支持不友好，很可能会影响搜索引擎中的排名。\n\n基于这些原因，如今不少前端框架也支持服务端渲染（SSR，Server-Side-Rendering），通过提供 Node.js 服务的方式，在服务端完成页面内容的拼接，直接返回给前端。相对的，单页应用的渲染方式，也被称为客户端渲染（CSR，Client-Side-Rendering）。\n\n服务端渲染听起来跟多页应用很相似，都是由服务端完成 HTML 内容拼接的，那是否可以认为服务端渲染就是多页应用呢？\n\n并不是，服务端渲染可以只用来控制首屏直出，而在页面进行切换的时候，依然使用单页应用的方式，这样的解决方案结合了多页应用和单页应用的优势，如今也在不少项目中使用。\n\n那么，页面切换的时候，如何避免页面重新加载，又能正确渲染页面内容呢？大多数项目中都会使用前端路由库（比如 ngRouter/vue-router/react-router 等），这些路由库的设计原理又是怎样的呢？\n\n我们一起来看一下。\n\n\n前端路由库的设计与实现\n\n页面的跳转、局部内容的刷新是 Web 应用中使用最多的场景。想象一下，如果我们只刷新了页面的内容，但是 URL 并没有改变，当用户刷新当前页面的时候，原先的内容会丢失，需要重新操作进入到对应的页面中，这是比较糟糕的一种体验。\n\n所以，我们可以把页面的内容匹配到对应的路由信息中，即使是强制刷新，URL 信息也不会丢，用户依然可以快速恢复原先的页面浏览信息，这也是我们项目中设计和使用路由的很重要的原因。\n\n前面说到，单页应用使用了局部刷新的能力，配合路由信息变更的时候进行局部页面内容的刷新（而不是重新加载一个完整的页面），可以让用户获取更好的体验。\n\n要实现前端路由，离不开浏览器提供的 History API、Location API 这些 API，因此后面介绍路由能力实现时，我们也会进行一些介绍。\n\n一般来说，前端路由的实现，会包括两种模式：\n\n 1. History 模式\n\n 2. Hash 模式\n\n我们先来看看 History 模式。\n\nHistory 模式\n\nHistory 的路由模式，依赖了一个关键的属性window.history，该属性可用来获取用于操作浏览器历史记录的 History 对象。也就是说，通过使用window.history，我们可以实现以下与路由相关的重要能力。比如：\n\n * 在 history 中跳转\n\n使用window.history.back()、window.history.forward()和window.history.go()方法，可以实现在用户历史记录中向后和向前的跳转。\n\n * 添加和修改历史记录中的条目\n\n使用history.pushState()和history.replaceState()方法，它可以操作浏览器的历史栈，同时不会引起页面的刷新（可避免页面重新加载）。\n\n * 监听页面路由切换\n\n当同一个页面在历史记录间切换时，就会产生popstate事件，可以通过window.popstate监听页面路由切换的情况。\n\n也就是说，使用pushState()和replaceState()来修改路由信息，通过popstate事件监听页面路由变化，来进行页面的局部更新，这便是 History 的路由模式。\n\n但 History 的路由模式需要依赖 HTML5 History API（IE10 以上），以及服务器的配置来支持，所以也有不少的开发者会使用 Hash 模式来管理 Web 应用的路由。\n\n那么 Hash 模式又是怎样的呢？\n\nHash 模式\n\nHash 模式使用的是从井号(#)开始的 URL（锚）片段，主要依赖 Location 对象的 hash 属性（location.hash）和hashchange事件，包括：\n\n * 使用location.hash来设置和获取 hash\n\nlocation.hash的设置和获取，并不会造成页面重新加载，利用这一点，我们可以记录页面关键信息的同时，提升页面体验。\n\n * 监听hashchange事件\n\n当页面的 hash 改变时，hashchange事件会被触发，同时提供了两个属性：newURL（当前页面新的 URL）和oldURL（当前页面旧的 URL）。\n\n部分浏览器不支持onhashchange事件，我们可以自行使用定时器检测和触发的方式来进行兼容，可以使用以下的代码逻辑来实现：\n\n(function (window) {\n  // 如果浏览器原生支持该事件，则退出\n  if ("onhashchange" in window.document.body) {\n    return;\n  }\n  var location = window.location,\n    oldURL = location.href,\n    oldHash = location.hash;\n  // 每隔100ms检测一下location.hash是否发生变化\n  setInterval(function () {\n    var newURL = location.href,\n      newHash = location.hash;\n    // 如果hash发生了变化，且绑定了处理函数...\n    if (newHash != oldHash && typeof window.onhashchange === "function") {\n      // 执行事件触发\n      window.onhashchange({\n        type: "hashchange",\n        oldURL: oldURL,\n        newURL: newURL,\n      });\n      oldURL = newURL;\n      oldHash = newHash;\n    }\n  }, 100);\n})(window);\n\n\n我们可以看到，Hash 路由模式使用location.hash来设置和获取 hash，并通过window.onhashchange监听基于 hash 的路由变化，来进行页面更新处理的。\n\n\n路由结合前端框架\n\n不管是 History 模式还是 Hash 模式，路由的实现原理都很简单，因此一般来说大家也都会直接使用前端框架自带的路由库。\n\n路由库结合前端框架的工作流程是这样的：\n\n 1. 设置监听器，监听popstate或者hashchange事件；\n\n 2. 根据当前 URL 信息匹配设置的路径，根据路由设置加载对应模块，通过前端框架进行更新和渲染；\n\n 3. 页面更新的同时，使用location.hash或者history.pushState/replaceState更新页面的路由信息。\n\n以上是简单的实现，很多路由工具库还会提供除事件监听和通知之外的一些更高级的能力，比如与渲染层结合解析和处理的能力，以及路由的钩子、路由监听、路由鉴权、匹配和映射、懒加载打包等这种能力，减轻业务开发过程中的处理工作。\n\n\n小结\n\n其实，不管是单页应用/多页应用、服务端渲染/客户端渲染，还是前端路由的设计，都是在前端项目中使用频率很高的功能，也有很多成熟的解决方案和配套工具。\n\n但在了解一个工具如何使用的同时，我们更应该了解工具的实现、为什么需要这样来使用。只有掌握和理解了工具的设计原理、相关的解决方案，我们才可以将这些知识化为己用。\n\n你最近也有在用什么工具库吗？你是否有去了解其中的设计原理呢？欢迎在留言区留下你的思考。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *鑫：\n\n> 小姐姐，那么ssr方案只能解决首屏seo问题吗？\n\n#     讲师回复：\n\n>     不只是这样哦，SSR 可以有效地提升首屏渲染的性能，很多前端应用会使用 SSR 来优化首屏耗时\n\n# *雨：\n\n> 被删，nuxt页面刷新时是node服务器端直出，那页面切换时，是如何做到让数据出现在“查看源代码”中的呢？明明没走node服务器啊！\n\n#     讲师回复：\n\n>     有点没看懂让数据出现在“查看源代码”是什么意思，nuxt 我也没研究过，但我理解路由异步加载的时候，也同样可以把数据直出在异步加载的代码里吧？\n\n# **沫：\n\n> 更新太慢啦~被删小姐姐，每个星期都迫不及待啊！！！！不够看＞︿＜\n\n# *聪：\n\n> 【部分浏览器不支持onhashchange事件，我们可以自行使用定时器检测和触发的方式来进行兼容】，既然不支持onhashchange事件了，为啥代码中还判断typeof window.onhashchange === "function"并执行呢？\n\n#     讲师回复：\n\n>     这里 window.onhashchange 是用来判断，业务代码中是否有依赖该事件的触发，如果有依赖但是浏览器又不支持的话，则需要手动触发该事件，达到 onhashchange 的效果',normalizedContent:'在第 6 讲和第 8 讲的内容中，我介绍了浏览器中页面是如何进行请求和渲染的。在单页应用出现以前，浏览器通过 http 请求向服务端请求页面内容的时候，服务端会根据页面不同的 url 路由，拼接出相应的页面视图片段，最终以 html 的方式返回给浏览器，浏览器再进行解析和渲染。\n\n这种多个页面间没有关系、各自为完整页面的应用，称之为多页应用。我们熟悉的 jsp、php 也都是通过拼接 html 模板的方式，来给浏览器提供完整的页面内容。\n\n如今，大多数的前端应用都使用单页应用的方式来实现。那么什么是单页应用呢？使用单页应用的优势是什么？为什么单页应用流行一段时间之后，现在又有人开始回到多页应用的方式呢？\n\n下面我们来一探究竟。\n\n\n单页应用的出现\n\n首先，单页应用与多页应用的区别在于：\n\n * 多页应用是由服务端进行 html 模板拼接的，各个页面间没有直接关系；\n\n * 单页应用便是将页面内容的控制权交给前端来处理，通过使用一个前端页面+多个页面片段的方式进行渲染。\n\n当页面以多页应用的方式进行加载时，如果发生页面间的跳转，常常会导致整个页面都需要重新加载。这是因为当页面路由发生了变化，浏览器会重新向服务端获取相应的内容，而服务端则会根据新的 url 再次进行 html 模板拼接，并返回给前端。\n\n在这个过程中，用户会看到页面重新变回了白屏，然后再出现内容，体验很糟糕。使用这种方式加载页面，整个页面都需要重新加载，导致体验不够友好。\n\n除此之外，由于页面中整个 html 内容都需要重新加载，多页应用还存在以下问题：\n\n 1. 静态资源无法有效复用，包括 javascript 脚本和 css 内容；\n\n 2. 原有的页面状态、用户状态无法保留，依赖 url、cookie、本地缓存等获取用户数据。\n\n其实在大多数情况下，对于同一个网站，不同 url 的页面其实整体骨架都很相似，像网站导航栏、顶部菜单栏、底部网站相关内容等都是相同的，使用多页应用的方式会导致这些内容也重新加载。\n\n既然如此，那么是否可以使用页面局部刷新的方式来更新页面内容呢？在第 10 讲中其实我也有介绍，如今流行的 angular、react、vue 等这些前端框架都是通过将某个数据变量关联到页面的某块内容展示的方式，实现页面的局部更新。\n\n但只有局部刷新的能力还是不够的，因为即使页面内容更新了，如果页面的 url 没有发生变化，当用户刷新页面的时候，可能会丢失当前的页面内容。因此，我们需要在前端配合控制路由的方式来控制页面展示，这就是单页应用。\n\n显然，单页应用的出现带来以下的好处：\n\n 1. 通用的静态资源（比如 jquery、axios、boostrap 等）不需要重新加载；\n\n 2. 页面的数据状态和用户状态依然保留；\n\n 3. 局部页面内容更新，页面切换快，用户体验好。\n\n但是，单页应用同样存在着一些问题，这些问题会影响着项目的选型，也因此出现了服务端渲染等解决方案，我们一起来看一下。\n\n\n单页应用的问题\n\n由于要启用单页应用，浏览器在首次打开页面的时候，除了加载固定的脚本和样式文件以外，页面流程大概是这样的。\n\n 1. 浏览器请求服务端，服务端返回固定静态资源+基础的 html 内容+前端路由库。\n\n 2. 由于是前端进行渲染，因此在一般情况下，服务端返回的 html 内容基本上<body>为空。前端在页面进行加载的时候，需要继续向服务端发起 ajax 请求，获取页面渲染需要的数据。\n\n 3. 服务端根据请求内容，给前端返回相应的数据。\n\n 4. 前端拿到数据后，根据当前的 url 信息来生成相应的内容，进行页面的二次渲染，此时页面才最终加载完成。\n\n可以看到，单页应用相比多页应用的优势主要在于页面切换时。在首次打开的时候，多页应用可以直接返回用于最终渲染的页面，而单页应用则需要自行进行计算和组装，中间过程很可能还涉及数据的二次请求，因此会比多页应用慢。\n\n除此之外，由于搜索引擎只识别 html 内容，单页应用更多依赖 javascript 进行 html 拼接，因此对 seo（search engine optimization 简写为 seo，搜索引擎优化）的支持不友好，很可能会影响搜索引擎中的排名。\n\n基于这些原因，如今不少前端框架也支持服务端渲染（ssr，server-side-rendering），通过提供 node.js 服务的方式，在服务端完成页面内容的拼接，直接返回给前端。相对的，单页应用的渲染方式，也被称为客户端渲染（csr，client-side-rendering）。\n\n服务端渲染听起来跟多页应用很相似，都是由服务端完成 html 内容拼接的，那是否可以认为服务端渲染就是多页应用呢？\n\n并不是，服务端渲染可以只用来控制首屏直出，而在页面进行切换的时候，依然使用单页应用的方式，这样的解决方案结合了多页应用和单页应用的优势，如今也在不少项目中使用。\n\n那么，页面切换的时候，如何避免页面重新加载，又能正确渲染页面内容呢？大多数项目中都会使用前端路由库（比如 ngrouter/vue-router/react-router 等），这些路由库的设计原理又是怎样的呢？\n\n我们一起来看一下。\n\n\n前端路由库的设计与实现\n\n页面的跳转、局部内容的刷新是 web 应用中使用最多的场景。想象一下，如果我们只刷新了页面的内容，但是 url 并没有改变，当用户刷新当前页面的时候，原先的内容会丢失，需要重新操作进入到对应的页面中，这是比较糟糕的一种体验。\n\n所以，我们可以把页面的内容匹配到对应的路由信息中，即使是强制刷新，url 信息也不会丢，用户依然可以快速恢复原先的页面浏览信息，这也是我们项目中设计和使用路由的很重要的原因。\n\n前面说到，单页应用使用了局部刷新的能力，配合路由信息变更的时候进行局部页面内容的刷新（而不是重新加载一个完整的页面），可以让用户获取更好的体验。\n\n要实现前端路由，离不开浏览器提供的 history api、location api 这些 api，因此后面介绍路由能力实现时，我们也会进行一些介绍。\n\n一般来说，前端路由的实现，会包括两种模式：\n\n 1. history 模式\n\n 2. hash 模式\n\n我们先来看看 history 模式。\n\nhistory 模式\n\nhistory 的路由模式，依赖了一个关键的属性window.history，该属性可用来获取用于操作浏览器历史记录的 history 对象。也就是说，通过使用window.history，我们可以实现以下与路由相关的重要能力。比如：\n\n * 在 history 中跳转\n\n使用window.history.back()、window.history.forward()和window.history.go()方法，可以实现在用户历史记录中向后和向前的跳转。\n\n * 添加和修改历史记录中的条目\n\n使用history.pushstate()和history.replacestate()方法，它可以操作浏览器的历史栈，同时不会引起页面的刷新（可避免页面重新加载）。\n\n * 监听页面路由切换\n\n当同一个页面在历史记录间切换时，就会产生popstate事件，可以通过window.popstate监听页面路由切换的情况。\n\n也就是说，使用pushstate()和replacestate()来修改路由信息，通过popstate事件监听页面路由变化，来进行页面的局部更新，这便是 history 的路由模式。\n\n但 history 的路由模式需要依赖 html5 history api（ie10 以上），以及服务器的配置来支持，所以也有不少的开发者会使用 hash 模式来管理 web 应用的路由。\n\n那么 hash 模式又是怎样的呢？\n\nhash 模式\n\nhash 模式使用的是从井号(#)开始的 url（锚）片段，主要依赖 location 对象的 hash 属性（location.hash）和hashchange事件，包括：\n\n * 使用location.hash来设置和获取 hash\n\nlocation.hash的设置和获取，并不会造成页面重新加载，利用这一点，我们可以记录页面关键信息的同时，提升页面体验。\n\n * 监听hashchange事件\n\n当页面的 hash 改变时，hashchange事件会被触发，同时提供了两个属性：newurl（当前页面新的 url）和oldurl（当前页面旧的 url）。\n\n部分浏览器不支持onhashchange事件，我们可以自行使用定时器检测和触发的方式来进行兼容，可以使用以下的代码逻辑来实现：\n\n(function (window) {\n  // 如果浏览器原生支持该事件，则退出\n  if ("onhashchange" in window.document.body) {\n    return;\n  }\n  var location = window.location,\n    oldurl = location.href,\n    oldhash = location.hash;\n  // 每隔100ms检测一下location.hash是否发生变化\n  setinterval(function () {\n    var newurl = location.href,\n      newhash = location.hash;\n    // 如果hash发生了变化，且绑定了处理函数...\n    if (newhash != oldhash && typeof window.onhashchange === "function") {\n      // 执行事件触发\n      window.onhashchange({\n        type: "hashchange",\n        oldurl: oldurl,\n        newurl: newurl,\n      });\n      oldurl = newurl;\n      oldhash = newhash;\n    }\n  }, 100);\n})(window);\n\n\n我们可以看到，hash 路由模式使用location.hash来设置和获取 hash，并通过window.onhashchange监听基于 hash 的路由变化，来进行页面更新处理的。\n\n\n路由结合前端框架\n\n不管是 history 模式还是 hash 模式，路由的实现原理都很简单，因此一般来说大家也都会直接使用前端框架自带的路由库。\n\n路由库结合前端框架的工作流程是这样的：\n\n 1. 设置监听器，监听popstate或者hashchange事件；\n\n 2. 根据当前 url 信息匹配设置的路径，根据路由设置加载对应模块，通过前端框架进行更新和渲染；\n\n 3. 页面更新的同时，使用location.hash或者history.pushstate/replacestate更新页面的路由信息。\n\n以上是简单的实现，很多路由工具库还会提供除事件监听和通知之外的一些更高级的能力，比如与渲染层结合解析和处理的能力，以及路由的钩子、路由监听、路由鉴权、匹配和映射、懒加载打包等这种能力，减轻业务开发过程中的处理工作。\n\n\n小结\n\n其实，不管是单页应用/多页应用、服务端渲染/客户端渲染，还是前端路由的设计，都是在前端项目中使用频率很高的功能，也有很多成熟的解决方案和配套工具。\n\n但在了解一个工具如何使用的同时，我们更应该了解工具的实现、为什么需要这样来使用。只有掌握和理解了工具的设计原理、相关的解决方案，我们才可以将这些知识化为己用。\n\n你最近也有在用什么工具库吗？你是否有去了解其中的设计原理呢？欢迎在留言区留下你的思考。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *鑫：\n\n> 小姐姐，那么ssr方案只能解决首屏seo问题吗？\n\n#     讲师回复：\n\n>     不只是这样哦，ssr 可以有效地提升首屏渲染的性能，很多前端应用会使用 ssr 来优化首屏耗时\n\n# *雨：\n\n> 被删，nuxt页面刷新时是node服务器端直出，那页面切换时，是如何做到让数据出现在“查看源代码”中的呢？明明没走node服务器啊！\n\n#     讲师回复：\n\n>     有点没看懂让数据出现在“查看源代码”是什么意思，nuxt 我也没研究过，但我理解路由异步加载的时候，也同样可以把数据直出在异步加载的代码里吧？\n\n# **沫：\n\n> 更新太慢啦~被删小姐姐，每个星期都迫不及待啊！！！！不够看＞︿＜\n\n# *聪：\n\n> 【部分浏览器不支持onhashchange事件，我们可以自行使用定时器检测和触发的方式来进行兼容】，既然不支持onhashchange事件了，为啥代码中还判断typeof window.onhashchange === "function"并执行呢？\n\n#     讲师回复：\n\n>     这里 window.onhashchange 是用来判断，业务代码中是否有依赖该事件的触发，如果有依赖但是浏览器又不支持的话，则需要手动触发该事件，达到 onhashchange 的效果',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"代码构建与 Webpack 必备技能",frontmatter:{title:"代码构建与 Webpack 必备技能",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/596343/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/13.%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA%E4%B8%8E%20Webpack%20%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD.html",relativePath:"01.前端/01.前端开发笔记/13.代码构建与 Webpack 必备技能.md",key:"v-63e62d2f",path:"/pages/596343/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:6274}],headersStr:"精选评论",content:'最初的页面开发中，前端实现一个页面只需要在一个文件里完成，包括 HTML/CSS/JavaScript 各种内容。后来，通常将常用的静态资源放置在 CDN，并使用<link>和<script>的 src 属性引入的方式，来减少页面开发过程中的重复代码编写。\n\n如今前端页面的功能越来越复杂，规模也越来越大。为了提升代码的可读性、项目的可维护性，我们会将一些通用的工具和组件进行抽象，代码被有组织地按照一定规则进行划分，比如按照功能划分为页面、组件、工具库、脚本等。\n\n这个过程便是模块化，而 JavaScript 中的模块规范不止一种。\n\n\nJavaScript 模块\n\n在 JavaScript 中，我们常说的模块规范包括 CommonJS/AMD/UMD/ES6 Module 四种。这些模块规范和定义之间的区别常常容易搞混，我们先来分别看一下。\n\nCommonJS 规范\n\nCommonJS 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n\n我们来看一个 CommonJS 规范的模块示例：\n\nvar beta = require(\'beta\');\nfunction verb {\n  return beta.verb();\n}\nmodule.exports = {\n  verb: verb\n};\n\n\n在该示例中，使用require()载入模块，使用module.exports输出模块 。\n一般来说，CommonJS 有以下特点：\n\n * 一个文件就是一个模块；\n\n * 使用require()载入模块，使用module.exports输出模块，因此各个模块间可以进行交互；\n\n * 不支持异步加载。\n\n或许你已经知道，Node.js 环境使用的便是基于 CommonJS 规范实现的模块系统，而如今我们提到 CommonJS 规范，也基本上认为是 Node.js 系统。\n\n为什么浏览器环境不使用 CommonJS 规范呢？这是因为 CommonJS 不支持异步加载，而前面我们也说过，浏览器环境中同步任务的执行会带来性能问题，但对于异步模块定义（AMD）来说就不存在这样的问题。\n\nAMD\n\n顾名思义，异步模块定义（AMD）主要为了解决异步加载模块而提出，它通过指定模块和依赖项的方式来定义模块。\n\nRequireJS 便是基于 AMD 的实现，我们同样可以看一个模块示例：\n\ndefine("alpha", ["require", "exports", "beta"], function (\n  require,\n  exports,\n  beta\n) {\n  exports.verb = function () {\n    return beta.verb();\n    // 或者可以这么写\n    return require("beta").verb();\n  };\n});\n\n\n在该示例中，导出 ID 为 alpha 的模块，依赖了 ID 为 beta 的模块。\n\n现在我们知道，Node.js 环境中的模块系统基于 CommonJS 规范，而浏览器环境中需要使用 AMD 实现。\n\n那么如果我们有一个模块，需要同时能运行在 Node.js 环境和浏览器环境中，要怎么办？我们可以使用 UMD 模式。\n\nUMD\n\n为了兼容 AMD 和 CommonJS 的规范，通用模块定义（UMD）模式被提出，它在兼容两者的同时，也支持了传统的全局变量模式。\n\n我们来看一个 UMD 模式的模块示例：\n\n(function (root, factory) {\n  if (typeof define === "function" && define.amd) {\n    // AMD\n    define(["jquery"], factory);\n  } else if (typeof exports === "object") {\n    // CommonJS\n    module.exports = factory(require("jquery"));\n  } else {\n    // 全局变量\n    root.returnExports = factory(root.jQuery);\n  }\n})(this, function ($) {\n  // ...\n});\n\n\n可以看到，UMD 模块头部通常都会有用来判断模块加载器环境的代码，并根据不同的环境提供了不同的方式进行加载。\n\n到这里，似乎不管是 Node.js 环境还是浏览器环境，都有支持的模块规范，也有能相互兼容的模块规范了。那么，ES6 模块又是什么呢？\n\nES6 模块\n\n相比于运行时进行加载的 CommonJS 规范，ES6 模块化主要是为了在编译阶段就可以确定各个模块之间的依赖关系。\n\n我们同样来看一个 ES6 模块的示例代码：\n\n// import 导入\nimport BaseTask, { TaskType } from "./BaseTask";\n// export 导出\nexport { BaseTask };\n\n\n在该示例中，使用import加载模块，使用export输出模块。\n\nES6 模块的特点如下：\n\n * 使用import加载和export输出；\n\n * 一个模块只会加载一次（CommonJS 也是一样）；\n\n * 导出的模块为变量引用，因此可以在内存中共享。\n\n现在大多数前端项目中都使用 ES6 模块，由于 ES6 模块化目的是编译阶段确定模块间依赖关系，因此我们需要在编译的时候使用 Babel、Webpack 等方式构建依赖关系树。\n\n除此之外，ES6 模块化在各个浏览器里的兼容性差异较大，因此同样需要进行 Babal 编译以及 Webpack 进行打包，这个过程我们称之为代码构建。\n\n我们来总结一下 CommonJS/AMD/UMD/ES6 Module 这四种模块规范：\n\n 1. CommonJS 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n\n 2. CommonJS 不支持异步加载，因此异步模块定义（AMD）主要为了解决异步加载模块而提出。\n\n 3. 通用模块定义（UMD）模式用于兼容 AMD 和 CommonJS 的规范。\n\n 4. CommonJS 规范用于运行时进行模块加载，ES6 模块化可以在编译阶段确定各个模块之间的依赖关系。\n\n下面，我们一起来看看 Webpack 这个在前端项目中经常出现的工具。\n\n\nWebpack 工具都做了些什么\n\n如今前端项目大多数都使用了模块化，而如果想要将多个文件的代码打包成最终可按照预期运行的代码，则需要使用到代码构建工具。\n\n不管项目代码是如何进行组织的，项目中又有多少个文件，最终浏览器依然会从 HTML 内容进行解析和加载，因此我们需要对项目中的代码进行构建（包括编译和打包），生成浏览器可正常解析和加载的内容。\n\n我们先来认识下常见的前端构建相关的工具。\n\n常见的前端构建工具\n\n对于前端开发来说，我们会用到各式各样的构建/打包工具，比如这些。\n\n\n\n其中，涉及模块化代码打包的主要有 Grunt/Gulp/Webpack/Rollup。很多同学会搞混这几个工具，这里我简单介绍下它们之间的区别。\n\n 1. Gulp/Grunt 是一种能够优化前端工作流程的工具，比如自动刷新页面、combo、压缩 CSS/JavaScript、编译 Less/Sass 等。\n\n 2. Webpack/Rollup 是一个 JavaScript 的模块打包器，用于整合编译成最终的代码。\n\n 3. 其中，Rollup 通常用来构建库，Webpack 更适合用来构建应用程序。\n\n对于业务团队来说，进行代码的模块打包更多情况下会选择 Webpack。那么，下面我们主要围绕 Webpack 工具，来介绍代码模块化打包的过程。\n\n\n认识 Webpack\n\n相信你肯定也认识 Webpack，要了解一个工具，最好的方式就是从如何使用它开始熟悉。\n\nWebpack 的使用中有 4 个核心概念：入口（entry）、输出（output）、Loader、插件（plugins），我们先来分别看看。\n\n入口（entry）\n\n首先便是入口（entry），entry 指向我们前端应用的第一个启动文件。例如，在 Vue 中是new Vue()位置所在的文件，在 Angular 中是启动.bootstrap()的文件，在 React 中则是ReactDOM.render()或者是React.render()的启动文件。\n\n// 将entry指向启动文件即可\nmodule.exports = {\n  entry: "./path/to/my/entry/file.js",\n};\n\n\n或许你会疑惑，入口的一个文件，又是怎样把整个前端项目中的代码关联起来，并进行打包的呢？\n\n实际上， Webpack 会从 entry 开始，通过解析模块间的依赖关系，递归地构建出一个依赖图。我们如果在项目中使用webpack-bundle-analyzer插件，也可以看到生成的这样一个依赖图。\n\n\n\nWebpack 会根据依赖图来对各个模块进行整合，最终打包成一个或多个的文件，来提供给浏览器进行加载。\n\n既然有入口，那当然就有出口，Webpack 中的出口由输出（output）字段来描述。\n\n输出（output）\n\n输出（output）字段用于告诉 Webpack 要将打包后的代码生成的文件名是什么（filename），以及将它们放在哪里（path）。\n\nmodule.exports = {\n  output: {\n    filename: "bundle.js", // 编译文件的文件名，比如 main.js/bundle.js/index.js\n    path: "/home/proj/public/assets", // 对应一个绝对路径，此路径是你希望一次性打包的目录\n  },\n};\n\n\n有了 entry 和 output，我们来看看 Webpack 中间的编译过程中，是怎样用到 Loader 和 Plugins 的。\n\nLoader\n\n要了解 Loader，你需要知道在 Webpack 中，每个文件(.css,.html,.scss,.jpg等) 都会被作为模块处理。如果你看过生成的 bundle.js 代码就会发现，Webpack 将所有的模块打包一起，每个模块添加标记 id，通过这样一个 id 去获取所需模块的代码。\n\n但实际上，Webpack 只理解 JavaScript，因此 Loader 的作用就是把不同的模块和文件（比如 HTML、CSS、JSX、Typescript 等）转换为 JavaScript 模块。\n\n而不同的应用场景需要不同的 Loader，比如我们经常会使用到的 CSS 相关 Loader 和其他资源 Loader。\n\n\n\n前面我们说到，ES6 模块需要依赖 Babel 编译和 Webpack 打包，而 Babel 在 Webpack 中就是使用 Loader 的方式来进行编译的。\n\nbabel-loader 将 ES6/ES7 语法编译生成 ES5，其中部分特性还需要 babel-polyfill 支持。这是因为 Babel 默认只转换新的 JavaScript 语法（比如const/let），但不会对新的 API（比如Promise）进行处理。\n\nWebpack 在编译过程中，支持多个 Loader 通过流水线的方式进行先后编译，编译的顺序为从后往前，最终以 JavaScript 模块的方式输出。\n\n到这里，我们知道 Webpack 以 entry 为入口，链式调用各个 Loader 进行编译生成 JavaScript，最终打包放置在 output 中。其中 Loader 只负责将其他非 JavaScript 模块转换成 JavaScript 模块。\n\n那 Webpack 又是怎样地对这些代码进行组织并生成文件呢？这就是插件 Plugins 负责的事情。\n\n插件（plugins）\n\n插件（plugins）主要负责解决 Loader 无法做到的事情，它可以访问在 Webpack 编译过程中的关键事件，对 Webpack 内部示例的一些数据进行处理，处理完成后回调 Webpack 让其继续。\n\n这样说或许有些抽象，我们直接来看看几个常用的插件就明白了。\n\n * HtmlwebpackPlugin：可以生成创建 HTML 入口文件，也可以为 HTML 文件中引入的外部资源如 script、link 动态添加每次编译后的哈希值，防止引用缓存的外部文件问题。\n\n * CommonsChunkPlugin：用来提取代码中的公共模块，并将这些公共模块按照预期进行打包生成独立的文件。\n\n * ProvidePlugin：用来定义标识符，当遇到指定标识符的时候自动加载模块，适合引入的全局变量（比如 jQuery）。\n\n * ExtractTextPlugin：可以将样式从 JavaScript 中抽出，生成单独的 .css 样式文件。\n\n看到这里你应该已经明白了，插件可以用来控制最终生成的代码是如何进行组织和输出的，包括对代码的打包优化、压缩，甚至是启用模块热替换、重新定义环境中的变量，等等。\n\n那么，现在我们已经知道 Webpack 到底对项目代码做了什么。\n\n 1. 通过 entry 指定的入口开始，解析各个文件模块间的依赖。\n\n 2. 根据模块间的依赖关系，开始对各个模块进行编译。\n\n 3. 编译过程中，根据配置的规则对一些模块使用 Loader 进行编译处理。\n\n 4. 根据插件的配置，对 Loader 编译后的代码进行封装、优化、分块、压缩等。\n\n 5. 最终 Webpack 整合各个模块，根据依赖关系将它们打包成最终的一个或者多个文件。\n\n这便是 Webpack 做的事情：让前端项目中模块化的代码能最终在浏览器中进行加载、并正常地工作。\n\n\n小结\n\n如今几乎大多数框架的代码构建工具（比如 Vue CLI、Create React App 等）底层实现都依赖 Webpack。虽然这些前端框架都提供了完善的脚手架，也提供了丰富的配置功能，但如果想要对自己的项目进行更多优化，我们依然需要自己调整 Webpack 配置，因此对它的掌握也是不可少的。\n\n对于前端来说，自动化工具的出现，大大降低了应用的开发和维护成本，也因此前端生态也日益丰富和完善。善用这些工具来解决开发过程中的痛点，是作为现代前端开发的必备技能。比如，我们可以使用 Webpack 的 Loader 和插件，实现自己的 AST 语法分析和代码处理过程，这也是许多前端框架在做的事情。\n\n如果你要做一个在编译时自动给 Class 类加上指定装饰器的能力，你认为是应该使用 Loader 还是 Plugins 呢？可以在留言区留下你的想法和实现逻辑。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *庆：\n\n> 在编译时自动给 Class 类加上指定装饰器的能力: 由于这需要在编译时进行处理，所以应该是使用Loader，因为Loader就是根据特定的规则对模块进行编译处理，而Plugins是对Loader编译后的代码进行处理\n\n#     讲师回复：\n\n>     嗯，可以使用 babel loader 提供的能力实现\n\n# console_man：\n\n> 涉及到代码修改都是loader，plugin并不负责代码修改\n\n# *振：\n\n> 我猜应该是插件吧，一旦 webpack 即将处理 js 文件，就加上装饰器，然后返回给 webpack 继续执行。\n\n#     讲师回复：\n\n>     Loader 可以做到哦，babel loader 就提供了这样的能力\n\n# *雨：\n\n> 用Plugins，类似HtmlwebpackPlugin，生成文档DOM对象，遍历每个node的class\n\n#     讲师回复：\n\n>     可以通过 loader 处理的 AST 对象中加上装饰器\n\n# *军：\n\n> 简单点就是只要涉及改变输出结果的那就是plugin，loader只是辅助webpack进行解析\n\n#     讲师回复：\n\n>     实际上，loader 在解析过程中可以拿到 AST，因此也可以对 AST 进行修改，比如 babel 相关的 loader 便会在适当的时候在代码中添加 polyfill。\n\n# *聪：\n\n> Loader 的作用就是把不同的模块和文件（比如 HTML、CSS、JSX、Typescript 等）转换为 JavaScript 模块。其他的功能应该都是使用Plugins吧\n\n#     讲师回复：\n\n>     Loader 在转换过程中也可以进行自定义的处理哦',normalizedContent:'最初的页面开发中，前端实现一个页面只需要在一个文件里完成，包括 html/css/javascript 各种内容。后来，通常将常用的静态资源放置在 cdn，并使用<link>和<script>的 src 属性引入的方式，来减少页面开发过程中的重复代码编写。\n\n如今前端页面的功能越来越复杂，规模也越来越大。为了提升代码的可读性、项目的可维护性，我们会将一些通用的工具和组件进行抽象，代码被有组织地按照一定规则进行划分，比如按照功能划分为页面、组件、工具库、脚本等。\n\n这个过程便是模块化，而 javascript 中的模块规范不止一种。\n\n\njavascript 模块\n\n在 javascript 中，我们常说的模块规范包括 commonjs/amd/umd/es6 module 四种。这些模块规范和定义之间的区别常常容易搞混，我们先来分别看一下。\n\ncommonjs 规范\n\ncommonjs 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n\n我们来看一个 commonjs 规范的模块示例：\n\nvar beta = require(\'beta\');\nfunction verb {\n  return beta.verb();\n}\nmodule.exports = {\n  verb: verb\n};\n\n\n在该示例中，使用require()载入模块，使用module.exports输出模块 。\n一般来说，commonjs 有以下特点：\n\n * 一个文件就是一个模块；\n\n * 使用require()载入模块，使用module.exports输出模块，因此各个模块间可以进行交互；\n\n * 不支持异步加载。\n\n或许你已经知道，node.js 环境使用的便是基于 commonjs 规范实现的模块系统，而如今我们提到 commonjs 规范，也基本上认为是 node.js 系统。\n\n为什么浏览器环境不使用 commonjs 规范呢？这是因为 commonjs 不支持异步加载，而前面我们也说过，浏览器环境中同步任务的执行会带来性能问题，但对于异步模块定义（amd）来说就不存在这样的问题。\n\namd\n\n顾名思义，异步模块定义（amd）主要为了解决异步加载模块而提出，它通过指定模块和依赖项的方式来定义模块。\n\nrequirejs 便是基于 amd 的实现，我们同样可以看一个模块示例：\n\ndefine("alpha", ["require", "exports", "beta"], function (\n  require,\n  exports,\n  beta\n) {\n  exports.verb = function () {\n    return beta.verb();\n    // 或者可以这么写\n    return require("beta").verb();\n  };\n});\n\n\n在该示例中，导出 id 为 alpha 的模块，依赖了 id 为 beta 的模块。\n\n现在我们知道，node.js 环境中的模块系统基于 commonjs 规范，而浏览器环境中需要使用 amd 实现。\n\n那么如果我们有一个模块，需要同时能运行在 node.js 环境和浏览器环境中，要怎么办？我们可以使用 umd 模式。\n\numd\n\n为了兼容 amd 和 commonjs 的规范，通用模块定义（umd）模式被提出，它在兼容两者的同时，也支持了传统的全局变量模式。\n\n我们来看一个 umd 模式的模块示例：\n\n(function (root, factory) {\n  if (typeof define === "function" && define.amd) {\n    // amd\n    define(["jquery"], factory);\n  } else if (typeof exports === "object") {\n    // commonjs\n    module.exports = factory(require("jquery"));\n  } else {\n    // 全局变量\n    root.returnexports = factory(root.jquery);\n  }\n})(this, function ($) {\n  // ...\n});\n\n\n可以看到，umd 模块头部通常都会有用来判断模块加载器环境的代码，并根据不同的环境提供了不同的方式进行加载。\n\n到这里，似乎不管是 node.js 环境还是浏览器环境，都有支持的模块规范，也有能相互兼容的模块规范了。那么，es6 模块又是什么呢？\n\nes6 模块\n\n相比于运行时进行加载的 commonjs 规范，es6 模块化主要是为了在编译阶段就可以确定各个模块之间的依赖关系。\n\n我们同样来看一个 es6 模块的示例代码：\n\n// import 导入\nimport basetask, { tasktype } from "./basetask";\n// export 导出\nexport { basetask };\n\n\n在该示例中，使用import加载模块，使用export输出模块。\n\nes6 模块的特点如下：\n\n * 使用import加载和export输出；\n\n * 一个模块只会加载一次（commonjs 也是一样）；\n\n * 导出的模块为变量引用，因此可以在内存中共享。\n\n现在大多数前端项目中都使用 es6 模块，由于 es6 模块化目的是编译阶段确定模块间依赖关系，因此我们需要在编译的时候使用 babel、webpack 等方式构建依赖关系树。\n\n除此之外，es6 模块化在各个浏览器里的兼容性差异较大，因此同样需要进行 babal 编译以及 webpack 进行打包，这个过程我们称之为代码构建。\n\n我们来总结一下 commonjs/amd/umd/es6 module 这四种模块规范：\n\n 1. commonjs 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n\n 2. commonjs 不支持异步加载，因此异步模块定义（amd）主要为了解决异步加载模块而提出。\n\n 3. 通用模块定义（umd）模式用于兼容 amd 和 commonjs 的规范。\n\n 4. commonjs 规范用于运行时进行模块加载，es6 模块化可以在编译阶段确定各个模块之间的依赖关系。\n\n下面，我们一起来看看 webpack 这个在前端项目中经常出现的工具。\n\n\nwebpack 工具都做了些什么\n\n如今前端项目大多数都使用了模块化，而如果想要将多个文件的代码打包成最终可按照预期运行的代码，则需要使用到代码构建工具。\n\n不管项目代码是如何进行组织的，项目中又有多少个文件，最终浏览器依然会从 html 内容进行解析和加载，因此我们需要对项目中的代码进行构建（包括编译和打包），生成浏览器可正常解析和加载的内容。\n\n我们先来认识下常见的前端构建相关的工具。\n\n常见的前端构建工具\n\n对于前端开发来说，我们会用到各式各样的构建/打包工具，比如这些。\n\n\n\n其中，涉及模块化代码打包的主要有 grunt/gulp/webpack/rollup。很多同学会搞混这几个工具，这里我简单介绍下它们之间的区别。\n\n 1. gulp/grunt 是一种能够优化前端工作流程的工具，比如自动刷新页面、combo、压缩 css/javascript、编译 less/sass 等。\n\n 2. webpack/rollup 是一个 javascript 的模块打包器，用于整合编译成最终的代码。\n\n 3. 其中，rollup 通常用来构建库，webpack 更适合用来构建应用程序。\n\n对于业务团队来说，进行代码的模块打包更多情况下会选择 webpack。那么，下面我们主要围绕 webpack 工具，来介绍代码模块化打包的过程。\n\n\n认识 webpack\n\n相信你肯定也认识 webpack，要了解一个工具，最好的方式就是从如何使用它开始熟悉。\n\nwebpack 的使用中有 4 个核心概念：入口（entry）、输出（output）、loader、插件（plugins），我们先来分别看看。\n\n入口（entry）\n\n首先便是入口（entry），entry 指向我们前端应用的第一个启动文件。例如，在 vue 中是new vue()位置所在的文件，在 angular 中是启动.bootstrap()的文件，在 react 中则是reactdom.render()或者是react.render()的启动文件。\n\n// 将entry指向启动文件即可\nmodule.exports = {\n  entry: "./path/to/my/entry/file.js",\n};\n\n\n或许你会疑惑，入口的一个文件，又是怎样把整个前端项目中的代码关联起来，并进行打包的呢？\n\n实际上， webpack 会从 entry 开始，通过解析模块间的依赖关系，递归地构建出一个依赖图。我们如果在项目中使用webpack-bundle-analyzer插件，也可以看到生成的这样一个依赖图。\n\n\n\nwebpack 会根据依赖图来对各个模块进行整合，最终打包成一个或多个的文件，来提供给浏览器进行加载。\n\n既然有入口，那当然就有出口，webpack 中的出口由输出（output）字段来描述。\n\n输出（output）\n\n输出（output）字段用于告诉 webpack 要将打包后的代码生成的文件名是什么（filename），以及将它们放在哪里（path）。\n\nmodule.exports = {\n  output: {\n    filename: "bundle.js", // 编译文件的文件名，比如 main.js/bundle.js/index.js\n    path: "/home/proj/public/assets", // 对应一个绝对路径，此路径是你希望一次性打包的目录\n  },\n};\n\n\n有了 entry 和 output，我们来看看 webpack 中间的编译过程中，是怎样用到 loader 和 plugins 的。\n\nloader\n\n要了解 loader，你需要知道在 webpack 中，每个文件(.css,.html,.scss,.jpg等) 都会被作为模块处理。如果你看过生成的 bundle.js 代码就会发现，webpack 将所有的模块打包一起，每个模块添加标记 id，通过这样一个 id 去获取所需模块的代码。\n\n但实际上，webpack 只理解 javascript，因此 loader 的作用就是把不同的模块和文件（比如 html、css、jsx、typescript 等）转换为 javascript 模块。\n\n而不同的应用场景需要不同的 loader，比如我们经常会使用到的 css 相关 loader 和其他资源 loader。\n\n\n\n前面我们说到，es6 模块需要依赖 babel 编译和 webpack 打包，而 babel 在 webpack 中就是使用 loader 的方式来进行编译的。\n\nbabel-loader 将 es6/es7 语法编译生成 es5，其中部分特性还需要 babel-polyfill 支持。这是因为 babel 默认只转换新的 javascript 语法（比如const/let），但不会对新的 api（比如promise）进行处理。\n\nwebpack 在编译过程中，支持多个 loader 通过流水线的方式进行先后编译，编译的顺序为从后往前，最终以 javascript 模块的方式输出。\n\n到这里，我们知道 webpack 以 entry 为入口，链式调用各个 loader 进行编译生成 javascript，最终打包放置在 output 中。其中 loader 只负责将其他非 javascript 模块转换成 javascript 模块。\n\n那 webpack 又是怎样地对这些代码进行组织并生成文件呢？这就是插件 plugins 负责的事情。\n\n插件（plugins）\n\n插件（plugins）主要负责解决 loader 无法做到的事情，它可以访问在 webpack 编译过程中的关键事件，对 webpack 内部示例的一些数据进行处理，处理完成后回调 webpack 让其继续。\n\n这样说或许有些抽象，我们直接来看看几个常用的插件就明白了。\n\n * htmlwebpackplugin：可以生成创建 html 入口文件，也可以为 html 文件中引入的外部资源如 script、link 动态添加每次编译后的哈希值，防止引用缓存的外部文件问题。\n\n * commonschunkplugin：用来提取代码中的公共模块，并将这些公共模块按照预期进行打包生成独立的文件。\n\n * provideplugin：用来定义标识符，当遇到指定标识符的时候自动加载模块，适合引入的全局变量（比如 jquery）。\n\n * extracttextplugin：可以将样式从 javascript 中抽出，生成单独的 .css 样式文件。\n\n看到这里你应该已经明白了，插件可以用来控制最终生成的代码是如何进行组织和输出的，包括对代码的打包优化、压缩，甚至是启用模块热替换、重新定义环境中的变量，等等。\n\n那么，现在我们已经知道 webpack 到底对项目代码做了什么。\n\n 1. 通过 entry 指定的入口开始，解析各个文件模块间的依赖。\n\n 2. 根据模块间的依赖关系，开始对各个模块进行编译。\n\n 3. 编译过程中，根据配置的规则对一些模块使用 loader 进行编译处理。\n\n 4. 根据插件的配置，对 loader 编译后的代码进行封装、优化、分块、压缩等。\n\n 5. 最终 webpack 整合各个模块，根据依赖关系将它们打包成最终的一个或者多个文件。\n\n这便是 webpack 做的事情：让前端项目中模块化的代码能最终在浏览器中进行加载、并正常地工作。\n\n\n小结\n\n如今几乎大多数框架的代码构建工具（比如 vue cli、create react app 等）底层实现都依赖 webpack。虽然这些前端框架都提供了完善的脚手架，也提供了丰富的配置功能，但如果想要对自己的项目进行更多优化，我们依然需要自己调整 webpack 配置，因此对它的掌握也是不可少的。\n\n对于前端来说，自动化工具的出现，大大降低了应用的开发和维护成本，也因此前端生态也日益丰富和完善。善用这些工具来解决开发过程中的痛点，是作为现代前端开发的必备技能。比如，我们可以使用 webpack 的 loader 和插件，实现自己的 ast 语法分析和代码处理过程，这也是许多前端框架在做的事情。\n\n如果你要做一个在编译时自动给 class 类加上指定装饰器的能力，你认为是应该使用 loader 还是 plugins 呢？可以在留言区留下你的想法和实现逻辑。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *庆：\n\n> 在编译时自动给 class 类加上指定装饰器的能力: 由于这需要在编译时进行处理，所以应该是使用loader，因为loader就是根据特定的规则对模块进行编译处理，而plugins是对loader编译后的代码进行处理\n\n#     讲师回复：\n\n>     嗯，可以使用 babel loader 提供的能力实现\n\n# console_man：\n\n> 涉及到代码修改都是loader，plugin并不负责代码修改\n\n# *振：\n\n> 我猜应该是插件吧，一旦 webpack 即将处理 js 文件，就加上装饰器，然后返回给 webpack 继续执行。\n\n#     讲师回复：\n\n>     loader 可以做到哦，babel loader 就提供了这样的能力\n\n# *雨：\n\n> 用plugins，类似htmlwebpackplugin，生成文档dom对象，遍历每个node的class\n\n#     讲师回复：\n\n>     可以通过 loader 处理的 ast 对象中加上装饰器\n\n# *军：\n\n> 简单点就是只要涉及改变输出结果的那就是plugin，loader只是辅助webpack进行解析\n\n#     讲师回复：\n\n>     实际上，loader 在解析过程中可以拿到 ast，因此也可以对 ast 进行修改，比如 babel 相关的 loader 便会在适当的时候在代码中添加 polyfill。\n\n# *聪：\n\n> loader 的作用就是把不同的模块和文件（比如 html、css、jsx、typescript 等）转换为 javascript 模块。其他的功能应该都是使用plugins吧\n\n#     讲师回复：\n\n>     loader 在转换过程中也可以进行自定义的处理哦',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"提升编程体验：组件化与模块化设计",frontmatter:{title:"提升编程体验：组件化与模块化设计",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/996215/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/14.%E6%8F%90%E5%8D%87%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1.html",relativePath:"01.前端/01.前端开发笔记/14.提升编程体验：组件化与模块化设计.md",key:"v-382edf72",path:"/pages/996215/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5690}],headersStr:"精选评论",content:'对于写业务代码，很多前端开发都觉得枯燥无趣，且认为容易达到技术瓶颈。其实并不是这样的，几乎所有被我们称之为“技术需求”“技术工具”的开发，它都来自业务的需要，Angular、React、Vue 这类框架也是。\n\n在前端领域，业务开发就真的只是调整样式、拼接模板、绑定事件、接口请求、更新页面这些内容吗？其实我们可以通过更好的代码设计，来提升写业务代码过程中的编程体验。\n\n今天我就介绍一下如何对应用进行模块化和组件化的设计。\n\n其实，在我们开始写重复的代码或是进行较多的复制粘贴时，我们大概就需要考虑对应用进行适当的抽象了，下面我们一起来看一下。\n\n\n如何进行应用的模块化设计\n\n当拿到一个设计好的应用之后，为避免出现文件内容过多、功能之间耦合严重等问题，提升项目代码的可用性和可维护性，我们需要对它进行模块拆分。\n\n应用的模块与层级划分\n\n每个人对于模块的理解都有所区别，因此模块的拆分有很多的方式。\n\n 1. 对于简单的管理端应用，可以采用类似 MVC 这样的结构进行模块拆分，比如拆分成视图模块、数据模块、逻辑控制模块等。\n\n 2. 对于页面内容较丰富的应用，可以结合业务进行更加细致的模块和组件拆分，比如拆分成核心模块、功能模块、公共组件模块等。\n\n 3. 对于交互和逻辑复杂的应用，可以根据系统架构将应用进行模块和层级的划分，比如拆分成渲染层、数据层、网络层等。\n\n举个例子，常见的客户端和服务端的通信过程可以根据功能模块进行分层，如图：\n\n\n\n对于大型应用的模块划分，很多时候我们还需要结合模块粒度进行由上至下的多次划分，划分的规则可能是上述的规则，也可能跟应用的业务场景相关。\n\n举个例子，像在线文档这样交互复杂的在线协作应用，可能将模块拆分成核心模块、功能模块、公共组件模块之后，还需要将各个模块进行分层或是二次模块划分处理。比如核心模块可分成渲染层、数据层、网络层，功能模块可分成函数计算模块、复制粘贴模块，等等。公共组件模块可拆分成头像模块、工具栏模块，等等。\n\n模块划分与设计原则\n\n在通用编程设计领域，架构设计也有很多的设计理念和原则，在这里，我介绍两种。\n\n 1. 领域驱动设计（Domain-Driven Design，简称 DDD）：从业务领域的角度来对系统进行领域划分和建模。\n\n 2. 职责驱动设计（Responsibility-Driven Design，简称 RDD）：从系统内部的角度来进行职责划分、模块拆分以及协作方式。\n\n其中，领域驱动设计（DDD）用于业务领域的划分，在业务复杂的系统架构设计中比较实用。比如电商领域的商品、买家/卖家、订单、优惠券、风控等各个领域的划分。\n\n但在前端领域中，不同的业务领域通常会通过不同的页面、组件等方式出现，比如商品页面、订单页面、优惠券页面等。因此领域驱动设计（DDD）很少在前端开发中使用，或者可以说在前端领域的应用与前端组件化思想比较相似。\n\n至于职责驱动设计（RDD），它更倾向从角色和职责的角度来定义和划分模块，与前端的公共组件、工具库、MCV/MVVM 设计、功能模块划分等类似。职责驱动设计（RDD）在功能复杂的系统架构设计中可带来不少的帮助，比如上面提到的在线文档中的各个功能模块的设计中，可以通过对系统进行职责划分以及定义模块之间的边界和协作方式，从而清晰地模块的功能。\n\n这两种设计模式并不是互斥的，我们可以配合一起使用，比如：\n\n 1. 我们可以将与业务逻辑关系密切的功能按照业务领域进行划分和建模，比如电商网站中的购物车组件、商品组件等；\n\n 2. 对于与前端实现（视图渲染逻辑、与服务端交互逻辑、与用户交互逻辑）相关的功能，我们可以在具体的系统搭建过程中对这些功能进行职责分配和模块划分。\n\n当我们对模块进行划分之后，还需要考虑模块的设计、模块间的依赖关系和通信等问题。其中，最常见的便是如何解决模块间的依赖耦合的问题。\n\n如何进行模块间依赖的解耦\n\n相信你都听过低耦合、高内聚这样的说法，它们常常被用来描述系统设计中的模块依赖关系，其中：\n\n * 低耦合基于抽象，使我们的系统更具模块化，不相关的事物不应相互依赖；\n\n * 高内聚则意味着对象专注于单一职责。\n\n低耦合和高内聚是每个设计良好的系统目标，关于具体的设计模式其实也有很多的书籍和课程专门讲述，这里我主要介绍在复杂前端领域中比较常用的依赖解耦方式。\n\n首先，可以使用依赖倒置进行依赖解耦。依赖倒置原则有两个，包括：\n\n 1. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；\n\n 2. 抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口。\n\n举个例子，数据层模块（DataManager）依赖了网络层模块（NetworkManager）中的发送数据接口（sendData()），还依赖了渲染层模块（RenderManager）的更新界面接口（updateView）。\n\n我们可以通过 Typescript 定义接口，则我们可以表达为：\n\ninterface INetworkManagerDependency {\n  sendData: (data: string) => void;\n}\ninterface IRenderManagerDependency {\n  updateView: () => Promise<void>;\n}\nclass DataManager {\n  constructor(\n    networkManagerDependency: INetworkManagerDependency,\n    renderManagerDependency: IRenderManagerDependency\n  ) {\n    // 相关依赖可以保存起来，在需要的时候使用\n  }\n}\n\n\n这样，我们只按照约定依赖抽象的接口来实现功能调用，就不会依赖具体的模块和细节。\n\n如果项目中有完善的依赖注入框架，就可以使用项目中的依赖注入体系，像 Angular 框架便自带依赖注入体系。依赖注入在大型项目中比较常见，对于各个模块间的依赖关系管理很实用，比如 VsCode 中就有使用到依赖注入。\n\n除了使用依赖注入框架，在前端中更常见的依赖解耦方式还包括使用事件进行通信。\n\n事件驱动其实常常在各种系统设计中会用到，可以解耦目标对象和它的依赖对象。目标只需要通知它的依赖对象，具体怎么处理，由依赖对象自己决定。\n\n使用事件驱动的方式，可以快速又简单地实现模块间的解耦，但它常常又带来了更多问题，比如：\n\n * 全局事件满天飞，不知道某个事件来自哪里，被多少地方监听了；\n\n * 无法进行事件订阅的销毁管理，容易存在内存泄漏的问题；\n\n * 事件维护困难，增加和调整参数影响面广，容易触发 Bug。\n\n当然，这些问题也有解决方法，我会在第 18 讲介绍状态管理的时候进行更加详细地介绍。\n\n除了上面介绍的方式，在进行代码编程过程中，有许多设计模式和理念可以参考，其中有不少的内容对于解耦模块间的依赖很有帮助，比如接口隔离原则、最少的知识原则、迪米特原则等。\n\n到这里，我介绍了前端应用中模块的划分、设计和解耦，这些架构和系统的设计在大型和复杂项目中更为常见。而在前端日常开发过程中，更多会涉及业务逻辑和界面开发的内容，因此我们常常说要进行组件化设计。\n\n\n如何进行应用的组件化设计\n\n首先，我们来定义一下什么是组件。\n\n组件是怎样划分的\n\n简单来说，组件可以扩展 HTML 元素、封装可重用的代码，比如：\n\n\x3c!--封装后的一个组件可能长这样--\x3e\n<my-component></my-component>\n\n\n看起来这个组件什么都没有，这是因为我们将逻辑都封装在组件里面了。组件有自身的呈现形式、状态数据和功能逻辑，一只猫也可以是一个组件，如图：\n\n\n\n这只猫虽然是个 Gif 图片，但它可以拖动，也可以鼠标悬浮弹出一个提示框，还可以双击或长按让它消失。这些逻辑我们都可以封装在组件里，通过这样的方式对外屏蔽了实现细节，外部使用的时候只需要引入组件，然后在页面里插入<Kitty></Kitty>这样一个组件就可以了。\n\n一般来说，组件的划分可以通过两个角度来进行。\n\n 1. 通过代码复用划分。我们在写代码的时候，会观察到一些代码在结构和功能上其实是可复用的，这时我们可以把它们封装，以减少重复的代码。\n\n 2. 通过视觉和交互划分。通常来说，组件的划分与视觉、交互等密切相关，我们可通过功能、独立性来判断是否适合作为一个组件。\n\n当我们确定要将哪些功能划分成组件之后，就需要定义组件的职责，然后进行组件封装。\n\n组件是怎样进行封装的\n\n其实组件封装过程和模块的职责定义有些相似，我们首先需要定义这个组件的职责。\n\n一个称职的组件，它提供了这些能力：\n\n * 组件内维护自身的数据和状态；\n\n * 组件内维护自身的事件（方法）；\n\n * 对外提供配置接口，来控制展示以及具体功能；\n\n * 通过对外提供查询接口，可获取组件状态和数据。\n\n下面以视频网站为例来简单说明下：\n\n\n\n1. 组件内维护自身的数据和状态，以图中的小卡片为例子：\n\n\n\n这个小卡片，它维护着自己的数据：封面图、描述、头像、作者，还有一个初始的状态，就是目前我们看到的样子。这些内容保存在组件自己的作用域中，每个卡片组件都拥有自己的数据和状态。\n\n2. 组件内维护自身的事件。\n\n我们在把鼠标放在卡片上，随着鼠标的位置，顶部会有个小小的进度条，同时封面图会随着进度条的变化而改变，如图：\n\n\n\n可见，小卡片组件封装有自己的mousemove事件，以及对应的处理逻辑方法。\n\n3. 对外提供配置项，来控制展示以及具体功能。我们看另外一个小卡片：\n\n\n\n这个卡片和前面的卡片有些不一样，左下角展示的是视频时长，而不是头像和名字，我们可以通过传入配置项的方式来控制。\n\n4. 通过对外提供查询接口，可获取组件状态。\n\n大多数时候，组件独立维护着自身的数据和状态。但在一些特殊场景下，父组件或者应用需要知道组件当前的状态，比如在页面中要浮动展示最近聚焦的卡片视频内容，这时候外层需要知道卡片中的具体进度并在浮窗中播放。在这种情况下，我们需要对外提供接口，以供查询。\n\n组件封装也可以包含一定的层级关系，比如卡片组件里也可以包括视频组件，提供点击播放的功能。在第 1 讲的时候我们就说过，现在很多前端应用最终会以组件树的方式呈现，这是因为 DOM 元素本身就是树状结构。\n\n\n应用中的组件树\n\n几乎任意类型的应用界面都可以抽象为一个组件树，例如 Github 上 Vue 主页，我们能看到页面能划分成一块块的内容块，其中有些也可以看作组件。\n\n\n\n一般来说，这样的一个管理页面，我们可以抽象成这样的组件树：\n\n\n\n以代码的方式来表达这样的组件树，会是这个样子：\n\n<div id="app">\n  <app-header>\n    <header-search></header-search>\n    <header-nav></header-nav>\n    <header-aside></header-aside>\n  </app-header>\n  <app-view>\n    <group-info></group-info>\n    <app-tab></app-tab>\n    <app-tab-container>\n      <project-card></project-card>\n      <card-list></card-list>\n    </app-tab-container>\n  </app-view>\n</div>\n\n\n在这段代码中，我们不再使用一个个的<div>来拼装成页面，在前端框架中我们会使用自定义组件名字，比如<my-component>，使用自定义组件可快速高效地复用代码，也可以降低维护成本。\n\n为了让组件与外界环境隔离（样式不会相互影响），像 Vue 这样的框架会通过在 DOM 节点上使用唯一的 ID 标记 DOM 元素，通过节点属性等方式匹配对应的元素并添加样式。\n\n2011 年推出 Web Components，允许仅使用 HTML、CSS 和 JavaScript 创建可重用的组件，其中包括了自定义元素、Shadow DOM、HTML templates，这三项技术的结合。通过 Web Components，我们可以不依赖前端框架，只使用 HTML/CSS/JavaScript 也能创建在任何现代浏览器中运行的可重用组件。\n\n\n小结\n\n到此，相信你认识了前端应用中模块化和组件化的设计过程。实际上，组件也可以看作是带有视图功能的特殊模块，它在前端开发过程中更为常见。\n\n不管是组件封装还是模块划分，过度的抽象都会导致代码难维护，代码可读性也差。当我们的应用很小，只有简单的功能的时候，我们甚至不需要对这些状态、数据等进行特殊管理，可能几个简单的变量就可以搞定了。\n\n但随着应用组件数量变多，我们开始有了组件的作用域。当组件需要通信，我们可以通过简单的事件机制、或共享对象的方式来进行交互。\n\n当我们的项目越做越大，要在上百个状态、上万条数据里要按照想要的方式去展示我们的应用，这时候需要一个合适的状态管理工具，我会在第 18 讲进行介绍。\n\n这些知识都会比较抽象，需要反复思考和研究才可以掌握。如果在工作中只关注功能的实现和堆叠，很少关注如何通过合理的设计去减少不必要的代码、避免重复性的工作，那么这样的工作只会变得越来越枯燥和烦琐。\n\n你觉得 Github 网站里，可以划分为多少个模块、怎样进行分层设计呢？欢迎在留言区进行交流。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *锐：\n\n> 如果业务需求变得越来越复杂，组件层级嵌套越来越深，这种应该怎么破解\n\n#     讲师回复：\n\n>     业务需求复杂和组件层级未必有一定的关系，组件之间如果层级过深，需要考虑是否组件的划分和设计不合理，可以考虑调整封装的策略\n\n# **杰：\n\n> 小姐姐好厉害',normalizedContent:'对于写业务代码，很多前端开发都觉得枯燥无趣，且认为容易达到技术瓶颈。其实并不是这样的，几乎所有被我们称之为“技术需求”“技术工具”的开发，它都来自业务的需要，angular、react、vue 这类框架也是。\n\n在前端领域，业务开发就真的只是调整样式、拼接模板、绑定事件、接口请求、更新页面这些内容吗？其实我们可以通过更好的代码设计，来提升写业务代码过程中的编程体验。\n\n今天我就介绍一下如何对应用进行模块化和组件化的设计。\n\n其实，在我们开始写重复的代码或是进行较多的复制粘贴时，我们大概就需要考虑对应用进行适当的抽象了，下面我们一起来看一下。\n\n\n如何进行应用的模块化设计\n\n当拿到一个设计好的应用之后，为避免出现文件内容过多、功能之间耦合严重等问题，提升项目代码的可用性和可维护性，我们需要对它进行模块拆分。\n\n应用的模块与层级划分\n\n每个人对于模块的理解都有所区别，因此模块的拆分有很多的方式。\n\n 1. 对于简单的管理端应用，可以采用类似 mvc 这样的结构进行模块拆分，比如拆分成视图模块、数据模块、逻辑控制模块等。\n\n 2. 对于页面内容较丰富的应用，可以结合业务进行更加细致的模块和组件拆分，比如拆分成核心模块、功能模块、公共组件模块等。\n\n 3. 对于交互和逻辑复杂的应用，可以根据系统架构将应用进行模块和层级的划分，比如拆分成渲染层、数据层、网络层等。\n\n举个例子，常见的客户端和服务端的通信过程可以根据功能模块进行分层，如图：\n\n\n\n对于大型应用的模块划分，很多时候我们还需要结合模块粒度进行由上至下的多次划分，划分的规则可能是上述的规则，也可能跟应用的业务场景相关。\n\n举个例子，像在线文档这样交互复杂的在线协作应用，可能将模块拆分成核心模块、功能模块、公共组件模块之后，还需要将各个模块进行分层或是二次模块划分处理。比如核心模块可分成渲染层、数据层、网络层，功能模块可分成函数计算模块、复制粘贴模块，等等。公共组件模块可拆分成头像模块、工具栏模块，等等。\n\n模块划分与设计原则\n\n在通用编程设计领域，架构设计也有很多的设计理念和原则，在这里，我介绍两种。\n\n 1. 领域驱动设计（domain-driven design，简称 ddd）：从业务领域的角度来对系统进行领域划分和建模。\n\n 2. 职责驱动设计（responsibility-driven design，简称 rdd）：从系统内部的角度来进行职责划分、模块拆分以及协作方式。\n\n其中，领域驱动设计（ddd）用于业务领域的划分，在业务复杂的系统架构设计中比较实用。比如电商领域的商品、买家/卖家、订单、优惠券、风控等各个领域的划分。\n\n但在前端领域中，不同的业务领域通常会通过不同的页面、组件等方式出现，比如商品页面、订单页面、优惠券页面等。因此领域驱动设计（ddd）很少在前端开发中使用，或者可以说在前端领域的应用与前端组件化思想比较相似。\n\n至于职责驱动设计（rdd），它更倾向从角色和职责的角度来定义和划分模块，与前端的公共组件、工具库、mcv/mvvm 设计、功能模块划分等类似。职责驱动设计（rdd）在功能复杂的系统架构设计中可带来不少的帮助，比如上面提到的在线文档中的各个功能模块的设计中，可以通过对系统进行职责划分以及定义模块之间的边界和协作方式，从而清晰地模块的功能。\n\n这两种设计模式并不是互斥的，我们可以配合一起使用，比如：\n\n 1. 我们可以将与业务逻辑关系密切的功能按照业务领域进行划分和建模，比如电商网站中的购物车组件、商品组件等；\n\n 2. 对于与前端实现（视图渲染逻辑、与服务端交互逻辑、与用户交互逻辑）相关的功能，我们可以在具体的系统搭建过程中对这些功能进行职责分配和模块划分。\n\n当我们对模块进行划分之后，还需要考虑模块的设计、模块间的依赖关系和通信等问题。其中，最常见的便是如何解决模块间的依赖耦合的问题。\n\n如何进行模块间依赖的解耦\n\n相信你都听过低耦合、高内聚这样的说法，它们常常被用来描述系统设计中的模块依赖关系，其中：\n\n * 低耦合基于抽象，使我们的系统更具模块化，不相关的事物不应相互依赖；\n\n * 高内聚则意味着对象专注于单一职责。\n\n低耦合和高内聚是每个设计良好的系统目标，关于具体的设计模式其实也有很多的书籍和课程专门讲述，这里我主要介绍在复杂前端领域中比较常用的依赖解耦方式。\n\n首先，可以使用依赖倒置进行依赖解耦。依赖倒置原则有两个，包括：\n\n 1. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；\n\n 2. 抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口。\n\n举个例子，数据层模块（datamanager）依赖了网络层模块（networkmanager）中的发送数据接口（senddata()），还依赖了渲染层模块（rendermanager）的更新界面接口（updateview）。\n\n我们可以通过 typescript 定义接口，则我们可以表达为：\n\ninterface inetworkmanagerdependency {\n  senddata: (data: string) => void;\n}\ninterface irendermanagerdependency {\n  updateview: () => promise<void>;\n}\nclass datamanager {\n  constructor(\n    networkmanagerdependency: inetworkmanagerdependency,\n    rendermanagerdependency: irendermanagerdependency\n  ) {\n    // 相关依赖可以保存起来，在需要的时候使用\n  }\n}\n\n\n这样，我们只按照约定依赖抽象的接口来实现功能调用，就不会依赖具体的模块和细节。\n\n如果项目中有完善的依赖注入框架，就可以使用项目中的依赖注入体系，像 angular 框架便自带依赖注入体系。依赖注入在大型项目中比较常见，对于各个模块间的依赖关系管理很实用，比如 vscode 中就有使用到依赖注入。\n\n除了使用依赖注入框架，在前端中更常见的依赖解耦方式还包括使用事件进行通信。\n\n事件驱动其实常常在各种系统设计中会用到，可以解耦目标对象和它的依赖对象。目标只需要通知它的依赖对象，具体怎么处理，由依赖对象自己决定。\n\n使用事件驱动的方式，可以快速又简单地实现模块间的解耦，但它常常又带来了更多问题，比如：\n\n * 全局事件满天飞，不知道某个事件来自哪里，被多少地方监听了；\n\n * 无法进行事件订阅的销毁管理，容易存在内存泄漏的问题；\n\n * 事件维护困难，增加和调整参数影响面广，容易触发 bug。\n\n当然，这些问题也有解决方法，我会在第 18 讲介绍状态管理的时候进行更加详细地介绍。\n\n除了上面介绍的方式，在进行代码编程过程中，有许多设计模式和理念可以参考，其中有不少的内容对于解耦模块间的依赖很有帮助，比如接口隔离原则、最少的知识原则、迪米特原则等。\n\n到这里，我介绍了前端应用中模块的划分、设计和解耦，这些架构和系统的设计在大型和复杂项目中更为常见。而在前端日常开发过程中，更多会涉及业务逻辑和界面开发的内容，因此我们常常说要进行组件化设计。\n\n\n如何进行应用的组件化设计\n\n首先，我们来定义一下什么是组件。\n\n组件是怎样划分的\n\n简单来说，组件可以扩展 html 元素、封装可重用的代码，比如：\n\n\x3c!--封装后的一个组件可能长这样--\x3e\n<my-component></my-component>\n\n\n看起来这个组件什么都没有，这是因为我们将逻辑都封装在组件里面了。组件有自身的呈现形式、状态数据和功能逻辑，一只猫也可以是一个组件，如图：\n\n\n\n这只猫虽然是个 gif 图片，但它可以拖动，也可以鼠标悬浮弹出一个提示框，还可以双击或长按让它消失。这些逻辑我们都可以封装在组件里，通过这样的方式对外屏蔽了实现细节，外部使用的时候只需要引入组件，然后在页面里插入<kitty></kitty>这样一个组件就可以了。\n\n一般来说，组件的划分可以通过两个角度来进行。\n\n 1. 通过代码复用划分。我们在写代码的时候，会观察到一些代码在结构和功能上其实是可复用的，这时我们可以把它们封装，以减少重复的代码。\n\n 2. 通过视觉和交互划分。通常来说，组件的划分与视觉、交互等密切相关，我们可通过功能、独立性来判断是否适合作为一个组件。\n\n当我们确定要将哪些功能划分成组件之后，就需要定义组件的职责，然后进行组件封装。\n\n组件是怎样进行封装的\n\n其实组件封装过程和模块的职责定义有些相似，我们首先需要定义这个组件的职责。\n\n一个称职的组件，它提供了这些能力：\n\n * 组件内维护自身的数据和状态；\n\n * 组件内维护自身的事件（方法）；\n\n * 对外提供配置接口，来控制展示以及具体功能；\n\n * 通过对外提供查询接口，可获取组件状态和数据。\n\n下面以视频网站为例来简单说明下：\n\n\n\n1. 组件内维护自身的数据和状态，以图中的小卡片为例子：\n\n\n\n这个小卡片，它维护着自己的数据：封面图、描述、头像、作者，还有一个初始的状态，就是目前我们看到的样子。这些内容保存在组件自己的作用域中，每个卡片组件都拥有自己的数据和状态。\n\n2. 组件内维护自身的事件。\n\n我们在把鼠标放在卡片上，随着鼠标的位置，顶部会有个小小的进度条，同时封面图会随着进度条的变化而改变，如图：\n\n\n\n可见，小卡片组件封装有自己的mousemove事件，以及对应的处理逻辑方法。\n\n3. 对外提供配置项，来控制展示以及具体功能。我们看另外一个小卡片：\n\n\n\n这个卡片和前面的卡片有些不一样，左下角展示的是视频时长，而不是头像和名字，我们可以通过传入配置项的方式来控制。\n\n4. 通过对外提供查询接口，可获取组件状态。\n\n大多数时候，组件独立维护着自身的数据和状态。但在一些特殊场景下，父组件或者应用需要知道组件当前的状态，比如在页面中要浮动展示最近聚焦的卡片视频内容，这时候外层需要知道卡片中的具体进度并在浮窗中播放。在这种情况下，我们需要对外提供接口，以供查询。\n\n组件封装也可以包含一定的层级关系，比如卡片组件里也可以包括视频组件，提供点击播放的功能。在第 1 讲的时候我们就说过，现在很多前端应用最终会以组件树的方式呈现，这是因为 dom 元素本身就是树状结构。\n\n\n应用中的组件树\n\n几乎任意类型的应用界面都可以抽象为一个组件树，例如 github 上 vue 主页，我们能看到页面能划分成一块块的内容块，其中有些也可以看作组件。\n\n\n\n一般来说，这样的一个管理页面，我们可以抽象成这样的组件树：\n\n\n\n以代码的方式来表达这样的组件树，会是这个样子：\n\n<div id="app">\n  <app-header>\n    <header-search></header-search>\n    <header-nav></header-nav>\n    <header-aside></header-aside>\n  </app-header>\n  <app-view>\n    <group-info></group-info>\n    <app-tab></app-tab>\n    <app-tab-container>\n      <project-card></project-card>\n      <card-list></card-list>\n    </app-tab-container>\n  </app-view>\n</div>\n\n\n在这段代码中，我们不再使用一个个的<div>来拼装成页面，在前端框架中我们会使用自定义组件名字，比如<my-component>，使用自定义组件可快速高效地复用代码，也可以降低维护成本。\n\n为了让组件与外界环境隔离（样式不会相互影响），像 vue 这样的框架会通过在 dom 节点上使用唯一的 id 标记 dom 元素，通过节点属性等方式匹配对应的元素并添加样式。\n\n2011 年推出 web components，允许仅使用 html、css 和 javascript 创建可重用的组件，其中包括了自定义元素、shadow dom、html templates，这三项技术的结合。通过 web components，我们可以不依赖前端框架，只使用 html/css/javascript 也能创建在任何现代浏览器中运行的可重用组件。\n\n\n小结\n\n到此，相信你认识了前端应用中模块化和组件化的设计过程。实际上，组件也可以看作是带有视图功能的特殊模块，它在前端开发过程中更为常见。\n\n不管是组件封装还是模块划分，过度的抽象都会导致代码难维护，代码可读性也差。当我们的应用很小，只有简单的功能的时候，我们甚至不需要对这些状态、数据等进行特殊管理，可能几个简单的变量就可以搞定了。\n\n但随着应用组件数量变多，我们开始有了组件的作用域。当组件需要通信，我们可以通过简单的事件机制、或共享对象的方式来进行交互。\n\n当我们的项目越做越大，要在上百个状态、上万条数据里要按照想要的方式去展示我们的应用，这时候需要一个合适的状态管理工具，我会在第 18 讲进行介绍。\n\n这些知识都会比较抽象，需要反复思考和研究才可以掌握。如果在工作中只关注功能的实现和堆叠，很少关注如何通过合理的设计去减少不必要的代码、避免重复性的工作，那么这样的工作只会变得越来越枯燥和烦琐。\n\n你觉得 github 网站里，可以划分为多少个模块、怎样进行分层设计呢？欢迎在留言区进行交流。\n\n----------------------------------------\n\n\n# 精选评论\n\n# *锐：\n\n> 如果业务需求变得越来越复杂，组件层级嵌套越来越深，这种应该怎么破解\n\n#     讲师回复：\n\n>     业务需求复杂和组件层级未必有一定的关系，组件之间如果层级过深，需要考虑是否组件的划分和设计不合理，可以考虑调整封装的策略\n\n# **杰：\n\n> 小姐姐好厉害',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"AngularReactVue 三大前端框架的设计特色",frontmatter:{title:"AngularReactVue 三大前端框架的设计特色",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/7d3a8a/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/17.AngularReactVue%20%E4%B8%89%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%89%B9%E8%89%B2.html",relativePath:"01.前端/01.前端开发笔记/17.AngularReactVue 三大前端框架的设计特色.md",key:"v-10c0c4bc",path:"/pages/7d3a8a/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5998}],headersStr:"精选评论",content:"在前面第 10 讲中，我介绍了前端框架中的核心能力——模板引擎。其实，除了模板引擎以外，前端框架还提供了很多其他的能力，比如性能优化相关、状态管理相关等。现如今，虽然各式各样的框架层出不穷，但目前稳定排行在前的基本上是这三大热门框架 Angular/React/Vue（排名不分先后）。\n\n对于不同的前端框架来说，各自的设计原理和解决方案都有所不同，开发者可根据自身需要选择合适的前端框架。\n\n今天，我们就来看一下 Angular/React/Vue 三个框架之间的区别、各自的特点和适用场景等\n\n\nAngular/React/Vue 框架对比\n\nAngular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用，提供了前端项目开发较完整的解决方案。\n\n与此相对，React/Vue 则专注于构建用户界面，在一定程度上来说是一个 JavaScript 库，不能称之为框架。\n\n由于 React/Vue 都提供了配套的页面应用解决方案和工具库，因此我们常常将它们作为前端框架与 Angular放在一起比较。\n\n实际上，三个框架的关系可以简单用这样的公式表达。\n\nAngular = React/Vue + 路由库（react-router/vue-router） + 状态管理（Redux/Flux/Mobx/Vuex） + 脚手架/构建（create-react-app/Vue CLI/Webpack） + ...\n\n\n我们先来看看 Angular。\n\n\nAngular\n\nAngular 最初的设计是针对大型应用进行的，上手成本较高，因为开发者需要掌握一些对前端开发来说较陌生的概念，其中包括依赖注入、模块化、脏检查、AOT 等设计。\n\n依赖注入\n\n依赖注入并不是由 Angular 提出的，它是基于依赖倒置的设计原则设计出来的一套机制。\n\n在项目中，依赖注入体现为：项目提供了这样一个注入机制，其中有人负责提供服务、有人负责消耗服务，通过注入机制搭建了提供服务与消费服务之间的接口。对于消费者来说，无须关心服务是否已经被创建并初始化，依赖注入机制会保证服务的可用性。\n\n在这样的机制下，开发者只需要关注如何使用服务，至于这个服务内部的实现是怎样的、它是什么时候被初始化的、它又依赖了怎样的其他服务，都交给了依赖注入机制来处理，不需要操心。\n\nAngular 提供的便是这样一套依赖注入系统，可以及时创建和交付所依赖的服务。Angular 通过依赖注入来帮你更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。这便是 Angular 中的依赖注入设计。\n\n前面提到，Angular 的设计是针对大型应用的，使用依赖注入可以轻松地将各个模块进行解耦，模块与模块之间不会有过多的依赖，可以轻松解决大型应用中模块难以管理的难题。所以在 Angular 中，依赖注入配合模块化组织能达到更好的效果。\n\n模块化组织\n\nAngular 模块把组件、指令和管道打包成内聚的功能块，每个模块聚焦一个特性区域、业务领域、工作流或通用工具。\n\n所以我们可以用Angular 模块来自行聚焦某一个领域的功能模块，也可以使用 Angular 封装好的一些功能模块，像表单模块 FormModule、路由模块 RouterModule、Http 模块，等等。\n\n通过依赖注入的方式，我们可以直接在需要的地方引入这些模块并使用。模块的组织结构为树状结构，不同层级的模块功能组成了完整的应用。通过树状的方式来，依赖注入系统可高效地对服务进行创建和销毁，管理各个模块之间的依赖关系。\n\n其中，脏检查机制也由于模块化组织的设计，被诟病的性能问题得以解决。\n\n状态更新：脏检查机制\n\n什么是脏检查呢？在 Angular 中，触发视图更新的时机来自常见的事件如用户交互（点击、输入等）、定时器、生命周期等，大概的过程如下：\n\n 1. 在上述时机被触发后，Angular会计算数据的新值和旧值是否有差异；\n\n 2. 若有差异，Angular 会更新页面，并触发下一次的脏检查；\n\n 3. 直到新旧值之间不再有差异，或是脏检查的次数达到设定阈值，才会停下来。\n\n由于并不是直接监听数据的变动，同时每一次更新页面之后，很可能还会引起新的值改变，这导致脏检查的效率很低，还可能会导致死循环。虽然 AngularJS 有阈值控制，但也无法避免脏检查机制所导致的低效甚至性能问题。\n\n脏检查机制在设计上存在的性能问题一直被大家诟病，在 Angular2+ 中引入了模块化组织来解决这个问题。由于应用的组织类是树结构的，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查。相比 AngularJS 中的带有环的结构，这样的单向数据流效率更高，而且容易预测，性能上也有不少的提升。除了模块化组织之外，Angular2+ 同时还引入了 NgZone，提升了脏检查的性能。\n\n在 Angular 中除了对脏检查机制进行了性能优化，还提供了其他的优化手段，AOT 编译便是其中一种。\n\n用 AOT 进行编译\n\n我们先来介绍下 AOT 编译和 JIT 编译。\n\n * JIT 编译：在浏览器中运行时编译，视图需要花很长时间才能渲染出来，导致运行期间的性能损耗。\n\n * AOT 编译（预编译）：在构建时编译，使得页面渲染更快，可提高应用性能。\n\nAngular 提供了预编译（AOT）能力，无须等待应用首次编译，以及通过预编译的方式移除不需要的库代码、减少体积，还可以提早检测模板错误。\n\n到此，我介绍了 Angular 中的依赖注入、模块化组织、脏检查机制、AOT 编译，这些是 Angular框架设计中比较核心的概念和解决方案。\n\n除此之外，Angular提供了完备的结构和规范，新加入的成员能很快地通过复制粘贴完成功能的开发。好的架构设计，能让高级程序员和初入门的程序员写出相似的代码，Angular 通过严格的规范约束，提升了项目的维护体验。\n\n由于 Angular 目标是提供大而全的解决方案，因此相比 Angular，React和 Vue则更专注于用户界面的构建和优化，我们继续来看一下 React。\n\n\nReact\n\nReact 和 Vue 都是专注于构建用户界面的 JavaSctipt 库，它们不强制引入很多工程类的功能，也没有过多的强侵入性的概念、语法糖和设计，因此它们相对 Angular 最大的优势是轻量。\n\n而对比 Vue，React 最大的优点是灵活，对原生 JavaScript 的侵入性弱（没有过多的模板语法），不需要掌握太多的API 也可以很好地使用。\n\nReact的哲学是：React 是用JavaScript 构建快速响应的大型 Web应用程序的首选方式。\n\n接下来，我们来看看React 中的一些核心设计和特色，首选便是虚拟 DOM的设计。\n\n虚拟 DOM\n\n虚拟 DOM 方案的出现，主要为了解决前端页面频繁渲染过程中的性能问题。该方案最初由 React 提出，如今随着机器性能的提升、框架之间的相互借鉴等，在其他框架（比如 Vue）中也都有使用。\n\n虚拟 DOM的设计，大概可分成 3 个过程，下面我们分别来看看。\n\n1. 用JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树。\n\n不知道你是否仔细研究过 DOM 节点对象，一个真正的DOM 元素非常庞大，拥有很多的属性值。一个 DOM 节点包括特别多的属性、元素和事件对象，但实际上我们会用到的可能只有其中很小一部分，比如节点内容、元素位置、样式、节点的添加删除等方法。\n\n所以，我们通过用 JavaScript 对象来表示 DOM 元素的方式，该对象仅包括常用的这些属性方法和节点关系，这样就可以大大降低对象内存、虚拟 DOM 差异对比的计算量等。\n\n2. 当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。\n\n当我们用 JavaScript 对象来模拟 DOM 节点之后，可以构造出虚拟 DOM 树。\n\n当发生状态变更的时候，可以重新构造一棵新的 JavaScript 对象 DOM 树。通过将新的模拟 DOM 树和旧的模拟 DOM 树进行比较，得到两棵树的差异，并记录下来。在比较之后，我们可以获得这样的差异：\n\n * 需要替换掉原来的节点；\n\n * 移动、删除、新增子节点；\n\n * 修改了节点的属性；\n\n * 对于文本节点的文本内容改变。\n\n\n\n如图所示，我们对比了两棵基于<div>元素的DOM 树，得到的差异有：\n\n * p 元素插入了一个 span 元素子节点；\n\n * 原先的文本节点挪到了 span 元素子节点下面；\n\n经过差异对比之后，我们能获得一组差异记录，接下来我们需要使用它。\n\n3. 把差异应用到真正的 DOM 树上\n\n要实现最终的页面渲染，需要进行一些 JavaScript 操作，将差异应用到真正的DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。\n\n使用这样的方式来更新页面，可以将页面的DOM 变更范围减到最小，同时通过将多个状态变更合并计算，可以降低页面的更新频率。因此，使用虚拟 DOM，可以有效降低浏览器计算和性能。\n\n虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈：\n\n * 在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树；\n\n * 在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费；\n\n * 递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降。\n\n对此，React 框架也有进行相应的优化：使用任务调度来控制状态更新的计算和渲染。\n\n状态更新：任务调度\n\nReact 中使用协调器（Reconciler）与渲染器（Renderer）来优化页面的渲染性能。\n\n在 React 里，可以使用ReactDOM.render/this.setState/this.forceUpdate/useState等方法来触发状态更新，这些方法共用一套状态更新机制，该更新机制主要由两个步骤组成。\n\n 1. 找出变化的组件，每当有更新发生时，协调器会做如下工作：\n\n * 调用组件render方法将 JSX 转化为虚拟 DOM；\n\n * 进行虚拟 DOM Diff 并找出变化的虚拟 DOM；\n\n * 通知渲染器。\n\n 2. 渲染器接到协调器通知，将变化的组件渲染到页面上。\n\n在 React15 及以前，协调器创建虚拟 DOM 使用的是递归的方式，该过程是无法中断的。这会导致 UI 渲染被阻塞，造成卡顿。\n\n为此，React16 中新增了调度器（Scheduler），调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。\n\n通过这样的方式，React 可在浏览器空闲的时候进行调度并执行任务，篇幅关系这里不再展开。\n\n虚拟DOM和任务调度的状态更新机制，是 React 中性能优化的两个重要解决方案。\n\n除了性能优化以外，React 的出现同时带来了特别棒的理念和设计，包括 jsx、函数式编程、Hooks等。其中，函数式编程的无副作用等优势向来被很多程序员所推崇，Hooks 的出现更是将 React 的函数式编程理念推向了更高峰。\n\n相比于 Angular，React 的入门门槛要低很多，但提到简单易学，就不得不说到 Vue了。\n\n\nVue\n\nVue 最大的特点是上手简单，框架的设计和文档对新手极其友好。但这并不代表它只是个简单的框架，当你需要实现一些更加深入的自定义功能时（比如自定义组件、自定义指令、JSX 等），你会发现它也提供了友好的支持能力。\n\n很多人会认为 Vue 只是把 Angular 和 React 的优势结合，但 Vue 也有自身的设计和思考特色。这里，我们同样介绍一下 Vue 的设计特点。\n\n虚拟 DOM\n\n前面我们在介绍 React的虚拟 DOM时，提到传统虚拟 DOM的性能瓶颈，Vue 3.0 同样为此做了些优化。\n\n在 Vue 3.0 中，虚拟 DOM通过动静结合的模式来进行突破：\n\n * 通过模版静态分析生成更优化的虚拟 DOM 渲染函数，将模版切分为块（if/for/slot)；\n\n * 更新时只需要直接遍历动态节点，虚拟 DOM的更新性能与模版大小解耦，变为与动态节点的数量相关。\n\n可以简单理解为，虚拟 DOM 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。\n\n状态更新： getter/setter、Proxy\n\n在 Vue 3.0 以前，Vue中状态更新实现主要依赖了getter/setter，在数据更新的时候就执行了模板更新、watch、computed等一些工作。\n\n相比于之前的getter/setter监控数据变更，Vue 3.0 将会是基于Proxy的变动侦测，通过代理的方式来监控变动，整体性能会得到优化。当我们给某个对象添加了代理之后，就可以改变一些原有的行为，或是通过钩子的方式添加一些处理，用来触发界面更新、其他数据更新等也是可以的。\n\n对比 Angular，Vue 更加轻量、入门容易。对比 React，Vue 则更专注于模板相关，提供了便利和易读的模板语法，开发者熟练掌握这些语法之后，可快速高效地搭建起前端页面。同时，Vue也在不断地进行自我演化，这些我们也能从 Vue 3.0 的响应式设计、模块化架构、更一致的API 设计等设计中观察到。\n\n\n小结\n\n前端框架很大程度地提升了前端的开发效率，同时提供了各种场景下的解决方案，使得前端开发可以专注于快速拓展功能和业务实现。\n\n今天我主要介绍了如今比较热门的三个前端框架：Angular/React/Vue。其中，Angular 属于适合大型前端项目的“大而全”的框架，而 React/Vue 则是轻量灵活的库，它们各有各的设计特点。\n\n对于框架的升级，React 选择了渐进兼容的技术方案，而 Angular/Vue 都曾经历过“断崖式”的版本升级。\n\n最后，希望你可以思考下：Angular/Vue 在版本升级过程中，为了更彻底地抛弃历史债务而选择了不兼容，这样的做法你们是怎么看待的呢？在我们的业务开发过程中，是否也会存在这样的情况呢？\n\n----------------------------------------\n\n\n# 精选评论\n\n# **用户7884：\n\n> 在学校的时候一直用Vue开发项目，年初实习的时候需要学习react。个人觉得Vue相对来说确实要轻量得多，但是react感觉更规范。比如redux和vuex，vue在业务代码中还是可以直接访问到store甚至进行修改的，只是官方不推荐这么做。但是react不行，更新state还是用新的state去覆盖掉旧的state。\n\n#     讲师回复：\n\n>     嗯，代码规范其实都有两面性，要求严格的地方灵活性和便利性可能会下降，要求松散的地方如果遇上多人开发的情况，由于编码习惯的不一样，代码可能就会很混乱",normalizedContent:"在前面第 10 讲中，我介绍了前端框架中的核心能力——模板引擎。其实，除了模板引擎以外，前端框架还提供了很多其他的能力，比如性能优化相关、状态管理相关等。现如今，虽然各式各样的框架层出不穷，但目前稳定排行在前的基本上是这三大热门框架 angular/react/vue（排名不分先后）。\n\n对于不同的前端框架来说，各自的设计原理和解决方案都有所不同，开发者可根据自身需要选择合适的前端框架。\n\n今天，我们就来看一下 angular/react/vue 三个框架之间的区别、各自的特点和适用场景等\n\n\nangular/react/vue 框架对比\n\nangular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用，提供了前端项目开发较完整的解决方案。\n\n与此相对，react/vue 则专注于构建用户界面，在一定程度上来说是一个 javascript 库，不能称之为框架。\n\n由于 react/vue 都提供了配套的页面应用解决方案和工具库，因此我们常常将它们作为前端框架与 angular放在一起比较。\n\n实际上，三个框架的关系可以简单用这样的公式表达。\n\nangular = react/vue + 路由库（react-router/vue-router） + 状态管理（redux/flux/mobx/vuex） + 脚手架/构建（create-react-app/vue cli/webpack） + ...\n\n\n我们先来看看 angular。\n\n\nangular\n\nangular 最初的设计是针对大型应用进行的，上手成本较高，因为开发者需要掌握一些对前端开发来说较陌生的概念，其中包括依赖注入、模块化、脏检查、aot 等设计。\n\n依赖注入\n\n依赖注入并不是由 angular 提出的，它是基于依赖倒置的设计原则设计出来的一套机制。\n\n在项目中，依赖注入体现为：项目提供了这样一个注入机制，其中有人负责提供服务、有人负责消耗服务，通过注入机制搭建了提供服务与消费服务之间的接口。对于消费者来说，无须关心服务是否已经被创建并初始化，依赖注入机制会保证服务的可用性。\n\n在这样的机制下，开发者只需要关注如何使用服务，至于这个服务内部的实现是怎样的、它是什么时候被初始化的、它又依赖了怎样的其他服务，都交给了依赖注入机制来处理，不需要操心。\n\nangular 提供的便是这样一套依赖注入系统，可以及时创建和交付所依赖的服务。angular 通过依赖注入来帮你更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。这便是 angular 中的依赖注入设计。\n\n前面提到，angular 的设计是针对大型应用的，使用依赖注入可以轻松地将各个模块进行解耦，模块与模块之间不会有过多的依赖，可以轻松解决大型应用中模块难以管理的难题。所以在 angular 中，依赖注入配合模块化组织能达到更好的效果。\n\n模块化组织\n\nangular 模块把组件、指令和管道打包成内聚的功能块，每个模块聚焦一个特性区域、业务领域、工作流或通用工具。\n\n所以我们可以用angular 模块来自行聚焦某一个领域的功能模块，也可以使用 angular 封装好的一些功能模块，像表单模块 formmodule、路由模块 routermodule、http 模块，等等。\n\n通过依赖注入的方式，我们可以直接在需要的地方引入这些模块并使用。模块的组织结构为树状结构，不同层级的模块功能组成了完整的应用。通过树状的方式来，依赖注入系统可高效地对服务进行创建和销毁，管理各个模块之间的依赖关系。\n\n其中，脏检查机制也由于模块化组织的设计，被诟病的性能问题得以解决。\n\n状态更新：脏检查机制\n\n什么是脏检查呢？在 angular 中，触发视图更新的时机来自常见的事件如用户交互（点击、输入等）、定时器、生命周期等，大概的过程如下：\n\n 1. 在上述时机被触发后，angular会计算数据的新值和旧值是否有差异；\n\n 2. 若有差异，angular 会更新页面，并触发下一次的脏检查；\n\n 3. 直到新旧值之间不再有差异，或是脏检查的次数达到设定阈值，才会停下来。\n\n由于并不是直接监听数据的变动，同时每一次更新页面之后，很可能还会引起新的值改变，这导致脏检查的效率很低，还可能会导致死循环。虽然 angularjs 有阈值控制，但也无法避免脏检查机制所导致的低效甚至性能问题。\n\n脏检查机制在设计上存在的性能问题一直被大家诟病，在 angular2+ 中引入了模块化组织来解决这个问题。由于应用的组织类是树结构的，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查。相比 angularjs 中的带有环的结构，这样的单向数据流效率更高，而且容易预测，性能上也有不少的提升。除了模块化组织之外，angular2+ 同时还引入了 ngzone，提升了脏检查的性能。\n\n在 angular 中除了对脏检查机制进行了性能优化，还提供了其他的优化手段，aot 编译便是其中一种。\n\n用 aot 进行编译\n\n我们先来介绍下 aot 编译和 jit 编译。\n\n * jit 编译：在浏览器中运行时编译，视图需要花很长时间才能渲染出来，导致运行期间的性能损耗。\n\n * aot 编译（预编译）：在构建时编译，使得页面渲染更快，可提高应用性能。\n\nangular 提供了预编译（aot）能力，无须等待应用首次编译，以及通过预编译的方式移除不需要的库代码、减少体积，还可以提早检测模板错误。\n\n到此，我介绍了 angular 中的依赖注入、模块化组织、脏检查机制、aot 编译，这些是 angular框架设计中比较核心的概念和解决方案。\n\n除此之外，angular提供了完备的结构和规范，新加入的成员能很快地通过复制粘贴完成功能的开发。好的架构设计，能让高级程序员和初入门的程序员写出相似的代码，angular 通过严格的规范约束，提升了项目的维护体验。\n\n由于 angular 目标是提供大而全的解决方案，因此相比 angular，react和 vue则更专注于用户界面的构建和优化，我们继续来看一下 react。\n\n\nreact\n\nreact 和 vue 都是专注于构建用户界面的 javasctipt 库，它们不强制引入很多工程类的功能，也没有过多的强侵入性的概念、语法糖和设计，因此它们相对 angular 最大的优势是轻量。\n\n而对比 vue，react 最大的优点是灵活，对原生 javascript 的侵入性弱（没有过多的模板语法），不需要掌握太多的api 也可以很好地使用。\n\nreact的哲学是：react 是用javascript 构建快速响应的大型 web应用程序的首选方式。\n\n接下来，我们来看看react 中的一些核心设计和特色，首选便是虚拟 dom的设计。\n\n虚拟 dom\n\n虚拟 dom 方案的出现，主要为了解决前端页面频繁渲染过程中的性能问题。该方案最初由 react 提出，如今随着机器性能的提升、框架之间的相互借鉴等，在其他框架（比如 vue）中也都有使用。\n\n虚拟 dom的设计，大概可分成 3 个过程，下面我们分别来看看。\n\n1. 用javascript 对象模拟 dom 树，得到一棵虚拟 dom 树。\n\n不知道你是否仔细研究过 dom 节点对象，一个真正的dom 元素非常庞大，拥有很多的属性值。一个 dom 节点包括特别多的属性、元素和事件对象，但实际上我们会用到的可能只有其中很小一部分，比如节点内容、元素位置、样式、节点的添加删除等方法。\n\n所以，我们通过用 javascript 对象来表示 dom 元素的方式，该对象仅包括常用的这些属性方法和节点关系，这样就可以大大降低对象内存、虚拟 dom 差异对比的计算量等。\n\n2. 当页面数据变更时，生成新的虚拟 dom 树，比较新旧两棵虚拟 dom 树的差异。\n\n当我们用 javascript 对象来模拟 dom 节点之后，可以构造出虚拟 dom 树。\n\n当发生状态变更的时候，可以重新构造一棵新的 javascript 对象 dom 树。通过将新的模拟 dom 树和旧的模拟 dom 树进行比较，得到两棵树的差异，并记录下来。在比较之后，我们可以获得这样的差异：\n\n * 需要替换掉原来的节点；\n\n * 移动、删除、新增子节点；\n\n * 修改了节点的属性；\n\n * 对于文本节点的文本内容改变。\n\n\n\n如图所示，我们对比了两棵基于<div>元素的dom 树，得到的差异有：\n\n * p 元素插入了一个 span 元素子节点；\n\n * 原先的文本节点挪到了 span 元素子节点下面；\n\n经过差异对比之后，我们能获得一组差异记录，接下来我们需要使用它。\n\n3. 把差异应用到真正的 dom 树上\n\n要实现最终的页面渲染，需要进行一些 javascript 操作，将差异应用到真正的dom 树上，例如节点的替换、移动、删除，文本内容的改变等。\n\n使用这样的方式来更新页面，可以将页面的dom 变更范围减到最小，同时通过将多个状态变更合并计算，可以降低页面的更新频率。因此，使用虚拟 dom，可以有效降低浏览器计算和性能。\n\n虽然虚拟 dom 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 dom 依然有以下性能瓶颈：\n\n * 在单个组件内部依然需要遍历该组件的整个虚拟 dom 树；\n\n * 在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费；\n\n * 递归遍历和更新逻辑容易导致 ui 渲染被阻塞，用户体验下降。\n\n对此，react 框架也有进行相应的优化：使用任务调度来控制状态更新的计算和渲染。\n\n状态更新：任务调度\n\nreact 中使用协调器（reconciler）与渲染器（renderer）来优化页面的渲染性能。\n\n在 react 里，可以使用reactdom.render/this.setstate/this.forceupdate/usestate等方法来触发状态更新，这些方法共用一套状态更新机制，该更新机制主要由两个步骤组成。\n\n 1. 找出变化的组件，每当有更新发生时，协调器会做如下工作：\n\n * 调用组件render方法将 jsx 转化为虚拟 dom；\n\n * 进行虚拟 dom diff 并找出变化的虚拟 dom；\n\n * 通知渲染器。\n\n 2. 渲染器接到协调器通知，将变化的组件渲染到页面上。\n\n在 react15 及以前，协调器创建虚拟 dom 使用的是递归的方式，该过程是无法中断的。这会导致 ui 渲染被阻塞，造成卡顿。\n\n为此，react16 中新增了调度器（scheduler），调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。\n\n通过这样的方式，react 可在浏览器空闲的时候进行调度并执行任务，篇幅关系这里不再展开。\n\n虚拟dom和任务调度的状态更新机制，是 react 中性能优化的两个重要解决方案。\n\n除了性能优化以外，react 的出现同时带来了特别棒的理念和设计，包括 jsx、函数式编程、hooks等。其中，函数式编程的无副作用等优势向来被很多程序员所推崇，hooks 的出现更是将 react 的函数式编程理念推向了更高峰。\n\n相比于 angular，react 的入门门槛要低很多，但提到简单易学，就不得不说到 vue了。\n\n\nvue\n\nvue 最大的特点是上手简单，框架的设计和文档对新手极其友好。但这并不代表它只是个简单的框架，当你需要实现一些更加深入的自定义功能时（比如自定义组件、自定义指令、jsx 等），你会发现它也提供了友好的支持能力。\n\n很多人会认为 vue 只是把 angular 和 react 的优势结合，但 vue 也有自身的设计和思考特色。这里，我们同样介绍一下 vue 的设计特点。\n\n虚拟 dom\n\n前面我们在介绍 react的虚拟 dom时，提到传统虚拟 dom的性能瓶颈，vue 3.0 同样为此做了些优化。\n\n在 vue 3.0 中，虚拟 dom通过动静结合的模式来进行突破：\n\n * 通过模版静态分析生成更优化的虚拟 dom 渲染函数，将模版切分为块（if/for/slot)；\n\n * 更新时只需要直接遍历动态节点，虚拟 dom的更新性能与模版大小解耦，变为与动态节点的数量相关。\n\n可以简单理解为，虚拟 dom 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。\n\n状态更新： getter/setter、proxy\n\n在 vue 3.0 以前，vue中状态更新实现主要依赖了getter/setter，在数据更新的时候就执行了模板更新、watch、computed等一些工作。\n\n相比于之前的getter/setter监控数据变更，vue 3.0 将会是基于proxy的变动侦测，通过代理的方式来监控变动，整体性能会得到优化。当我们给某个对象添加了代理之后，就可以改变一些原有的行为，或是通过钩子的方式添加一些处理，用来触发界面更新、其他数据更新等也是可以的。\n\n对比 angular，vue 更加轻量、入门容易。对比 react，vue 则更专注于模板相关，提供了便利和易读的模板语法，开发者熟练掌握这些语法之后，可快速高效地搭建起前端页面。同时，vue也在不断地进行自我演化，这些我们也能从 vue 3.0 的响应式设计、模块化架构、更一致的api 设计等设计中观察到。\n\n\n小结\n\n前端框架很大程度地提升了前端的开发效率，同时提供了各种场景下的解决方案，使得前端开发可以专注于快速拓展功能和业务实现。\n\n今天我主要介绍了如今比较热门的三个前端框架：angular/react/vue。其中，angular 属于适合大型前端项目的“大而全”的框架，而 react/vue 则是轻量灵活的库，它们各有各的设计特点。\n\n对于框架的升级，react 选择了渐进兼容的技术方案，而 angular/vue 都曾经历过“断崖式”的版本升级。\n\n最后，希望你可以思考下：angular/vue 在版本升级过程中，为了更彻底地抛弃历史债务而选择了不兼容，这样的做法你们是怎么看待的呢？在我们的业务开发过程中，是否也会存在这样的情况呢？\n\n----------------------------------------\n\n\n# 精选评论\n\n# **用户7884：\n\n> 在学校的时候一直用vue开发项目，年初实习的时候需要学习react。个人觉得vue相对来说确实要轻量得多，但是react感觉更规范。比如redux和vuex，vue在业务代码中还是可以直接访问到store甚至进行修改的，只是官方不推荐这么做。但是react不行，更新state还是用新的state去覆盖掉旧的state。\n\n#     讲师回复：\n\n>     嗯，代码规范其实都有两面性，要求严格的地方灵活性和便利性可能会下降，要求松散的地方如果遇上多人开发的情况，由于编码习惯的不一样，代码可能就会很混乱",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何设计合适的状态管理方案",frontmatter:{title:"如何设计合适的状态管理方案",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/ddbbb3/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/18.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%90%88%E9%80%82%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88.html",relativePath:"01.前端/01.前端开发笔记/18.如何设计合适的状态管理方案.md",key:"v-523358fd",path:"/pages/ddbbb3/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4939}],headersStr:"精选评论",content:'在前端应用的开发过程中，对于规模较小、各个模块间依赖较少的项目，一般不会引入复杂的状态管理工具。\n\n但实际上，业务的发展和变化很快，随着我们项目在不断地变大、各个页面中需要共享和通信的内容越来越多，与此同时项目也加入了新成员、不同开发的习惯不一致，项目到后期可能会出现事件的传递、全局数据满天飞的情况。\n\n这样会有什么隐患呢？当我们想要改某个状态数据的时候，无法直观确认这些改动会不会影响到其他地方。更让人头疼的是，在测试的时候并没有发现存在问题（毕竟有在项目规模较大的情况下，回归测试的成本也会越来越重），然后触发了线上事故。\n\n这是否又意味着所有项目都应该在最初的时候引入状态管理方案呢？除非项目在最初就已经定位为大型或复杂的应用，否则我们则需要根据预期来选型、根据需要引进不同的工具库来进行管理。同时，如果我们的项目在不断的发展和迭代过程中，则可能需要进行状态管理方案的变更。\n\n关于技术选型和项目设计的内容，我会在后续介绍。因为在掌握如何进行方案选型之前，我们还需要了解现有的各种方案。所以，今天我们主要来认识下常见的前端状态管理方案。\n\n要介绍数据在前端应用中是怎么流动的，首先我们要了解数据是如何管理的。\n\n\n数据管理\n\n一般来说，各个组件的数据都会在组件自身的实例当中进行维护。但如果一些数据涉及跨组件共享、全局共享的情况，则需要对数据进行统一的保存和维护，大多数情况下我们都会使用共享对象的方式。\n\n共享对象\n\n共享对象的原理很简单，当我们需要多个地方使用相同的数据，我们就把它们放置在一个地方，大家都去那里获取和更新。\n\n\n\n比如，我们可以简单用一个叫globalData.js的文件来管理全局用的数据。\n\n// globalData.js\n// globalData 用来存全局数据\nlet globalData = {};\n// 获取全局数据\n// 传 key 获取对应的值\n// 不传 key 获取全部值\nexport function getGlobalData(key) {\n  return key ? globalData[key] : globalData;\n}\n// 设置全局数据\nexport function setGlobalData(key, value) {\n  // 需要传键值对\n  if (key === undefined || value === undefined) {\n    return;\n  }\n  globalData = { ...globalData, [key]: value };\n  return globalData;\n}\n\n\n除了全局数据以外，局部数据的管理同样可以使用共享对象的方式进行，我们将需要共享的数据维护在一个对象中，需要的时候则主动进行获取。\n那如果应用中存在多个共享对象，我们又该怎样管理这些对象呢？\n\n根据模块进行划分\n\n在大型应用中，维护的全局数据也会更加复杂，通过合适的方式进行拆分，可以更方便地进行管理，比如根据数据的类型、使用场景、涉及的功能，从而拆分模块的方式来进行管理。\n\n除此之外，我们还可以使用树状结构的方式来管理这些全局对象。\n\n使用树状结构管理数据\n\n在介绍第 1 讲的时候，我就有介绍前端页面中，DOM 节点是基于树状结构管理的。同时，前端应用即便通过模块化和组件化一层层地进行了封装，最终依然会呈现为树状。\n\n因此，我们可以根据组件的树状作用域，结合共享对象的管理，来注入树状的数据结构。比如在 Angular 中，就是使用依赖注入的方式，配合树状的组件管理，来实现数据的共享或是隔离。\n\n现在，我们知道应用中需要共享的数据可以通过怎样的方式进行管理，那么当数据发生变化的时候，又该怎样通知到依赖方吗？\n\n\n数据变更\n\n前面的第 15 讲中，我介绍了如何将应用和界面抽象成数据管理，其实被抽象的数据也就是我们常说的状态。\n\n前端项目中的数据并不只是简单地存在于应用中，相互之间会进行交互和影响。数据间的相互作用，便是我们常说的数据通信或是状态管理，包括但不限于以下的一些方式：\n\n * 事件监听与触发；\n\n * 单向数据流；\n\n * 响应式数据流。\n\n我们来分别看一下。\n\n事件监听与触发\n\n事件监听与触发的设计，一般来说会基于发布-订阅模式。想必你也比较熟悉，我们对浏览器点击、输入框的输入操作事件的绑定，就是典型的事件机制。\n\n我们也可以通过事件管理的方式，来进行数据的交互，比如 Websocket 机制。\n\n事件监听和触发的原理其实很简单。监听者在进行事件监听后，会被添加到该事件的监听者队列中。事件被触发后，则可以根据该事件的监听者队列，来通知相应的监听者。\n\n在第 1 讲中，我们介绍了事件委托机制，在很多前端框架中，事件委托会挂载在页面的组件根实例上。除了挂载在组件根实例这样的方式来绑定作为事件中心，我们也可以自行创建一个事件中心来进行管理。\n\n事件通知机制很方便，可以随意控制触发的时机，也可以任意的地方监听或是触发。但前面也说过，事件机制的弊端也是很明显，就是每一个事件的触发对应一个或者多个监听，关系是一对多。\n\n设计不合理的地方，甚至可能出现一个事件会被多处触发的问题，常常是事件散落在各个地方、数据流也难以跟踪。需要定位的时候，只能通过全局搜索的方式来跟踪数据的去向，导致维护难度大大上升。\n\n以简单的博客系统来为例：\n\n\n\n这里只有事件 1 和事件 2 的触发和监听，存在跨组件甚至跨页面的事件通知。\n\n如果在一个规模较大的应用中，可能会导致满屏的事件，同时事件之间并没有什么规律可循。这样我们每次改动事件相关的代码，例如多传一个参数、改变某个参数，都可能会导致未知的错误，需要全局搜索出相关的事件，并一一进行回归测试才可以。\n\n除此之外，绑定的事件如果不能及时销毁甚至会导致内存泄漏等问题。那么，是不是在大型复杂的前端应用中，就不适合使用事件机制呢？并不是。\n\n在大型前端项目 VS Code 中就使用了事件机制，并配合依赖注入的框架设计了一套事件的管理模式，包括：\n\n * 提供标准化的Event和Emitter能力；\n\n * 通过注册Emitter，并对外提供类似生命周期的方法onXxxxx的方式，来进行事件的订阅和监听；\n\n * 通过提供通用类Disposable，统一管理相关资源的注册和销毁；\n\n * 通过使用同样的方式this._register()注册事件和订阅事件，将事件相关资源的处理统一挂载到dispose()方法中。\n\n由于 VS Code 中使用了依赖注入，对于模块的实例创建、销毁等都会统一交给框架来进行，从而很方便地解决了事件机制的弊端。\n\n很多时候，我们不只是选择某个技术方案这么简单，对于方案如何在项目中落地、是否需要进行适当的调整，都是需要进行思考的。\n\n下面我们继续看一下，在前端领域中更加普遍的状态管理方式：单向数据流。\n\n单向数据流\n\n如今很多前端框架都会搭配使用状态管理工具，来处理应用中的数据变更。\n\n其中，Vuex/Redux/Flux 这些热门的状态管理工具库设计思想都基于单向数据流，它们采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n以 Redux 为例，为了保证数据是单向流动的：\n\n\n\n * 使用单一的数据源：所有的状态数据都存储在store中；\n\n * 状态数据只读：只能通过action来触发数据变更；\n\n * 修改无副作用：修改现有数据的副本，并通过传递副本来更新数据。\n\n在全局数据的使用变频繁之后，我们在定位问题的时候还会遇到不知道这个数据为何改变的情况，因为所有引用到这个全局数据的地方都可能对它进行改变。\n\n这种情况下，给数据的流动一个方向，则可以方便地跟踪数据的来源和去处。\n\n同样以博客系统为例：\n\n\n\n可以看到，使用了单向数据流的状态管理方案之后，数据的变更来源、更新方向都相比事件触发要清晰。因此，也被更多开发者所推崇。\n\n除了单向数据流的方案以外，前端项目中比较热门的还有响应式的数据管理方式。\n\n响应式数据流\n\n响应式数据流的设计基于响应式编程方式，响应式编程同样基于观察者模式，它是一种面向数据流和变化传播的声明式编程方式。在前端领域，常见的异步编程场景包括事件处理、用户输入、HTTP 响应等。\n\n对于这样的异步数据流，可以使用响应式编程的方式来进行设计，通过订阅某个数据流，可以对数据进行一系列流式处理，例如过滤、计算、转换、合流等，配合函数式编程可以实现很多优秀的场景。\n\n以 Rxjs 为例，对用户的一些交互，也可以通过订阅的方式来获取需要的信息：\n\nconst observable = Rx.Observable.fromEvent(input, "input") // 监听 input 元素的 input 事件\n  .map((e) => e.target.value) // 一旦发生，把事件对象 e 映射成 input 元素的值\n  .filter((value) => value.length >= 1) // 接着过滤掉值长度小于 1 的\n  .distinctUntilChanged() // 如果该值和过去最新的值相等，则忽略\n  .subscribe(\n    // subscribe 拿到数据\n    (x) => console.log(x),\n    (err) => console.error(err)\n  );\n// 订阅\nobservable.subscribe((x) => console.log(x));\n\n\nAngular 框架本身推荐使用的状态管理工具便是 Rxjs，在 Angular 中结合依赖注入的方式，来进行数据流的订阅和触发，也可以很方便地对数据源和流向进行管理。\n\n除了 Rxjs，基于响应式数据流设计的状态管理库包括还有 Mobx。其中，Rxjs 提供了基于可观察对象（Observable）的响应式服务，Mobx 提供了基于状态管理的响应式服务。基于响应式数据流的设计，我们可以通过各种合流的方式、订阅分流的方式，来将应用中的数据流动从头到尾串在一起。这样，我们可以很清晰地知道当前节点上的数据来自哪里，是用户的操作还是来自网络请求。\n\n对于很多复杂程度较低的前端应用来说，响应式数据流的入门成本比较高。但在一些复杂应用的场景，合理地使用响应式编程，可以有效地降低各个模块间的依赖，更加容易地进行整体数据流动管理和维护。\n\n除了天然异步的前端、客户端等 GUI 开发以外，响应式编程在大数据处理中也同样拥有高并发、分布式、依赖解耦等优势，在这种同步阻塞转异步的并发场景下会有较大的性能提升，淘宝业务架构就是使用响应式的架构。\n\n\n小结\n\n我们的项目里，常常会面临应用中某些状态和数据相互影响、相互依赖的问题。\n\n今天我介绍了一些常见的状态管理的解决方案，包括事件监听、单向数据流、响应式数据流等。那么，它们之间有明显的优劣吗？\n\n其实最终还是取决于项目本身的架构、业务场景，对于简单的项目来说，使用事件监听就可以方便地解决父子组件通信的问题；当项目规模增加之后，则可能面临全局事件乱飞的问题，此时使用单向数据流或是响应式数据流的方式都可以解决该问题。\n\n实际上，复杂的前端项目中常常会同时存在多种状态管理方式，同时也会结合业务本身进行适当的调整。除了选择合适的状态管理方案以外，我们还可以通过设计合理的状态来简化一些复杂的问题场景，比如来解决前端常见的防抖和节流问题，同样可以设计状态机的方式来解决。\n\n我们在思考如何解决问题的同时，还可以找到问题的根源，并尝试分析和解决。只有这样，我们才可以脱离被层出不穷的问题缠身的状况，更加专注地进行项目优化。\n\n除了本文介绍的，你还了解到哪些状态管理的方式呢？欢迎在留言区进行讨论～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **哈：\n\n> 问几个问题：Vuex：1. 为什么mutation中只能是同步？2. 为什么必须通过commit mutation的方式更改stateRedux：1. 为什么reducer必须是纯函数？2. 为什么reducer必须返回新的state，而不可以修改原有state？',normalizedContent:'在前端应用的开发过程中，对于规模较小、各个模块间依赖较少的项目，一般不会引入复杂的状态管理工具。\n\n但实际上，业务的发展和变化很快，随着我们项目在不断地变大、各个页面中需要共享和通信的内容越来越多，与此同时项目也加入了新成员、不同开发的习惯不一致，项目到后期可能会出现事件的传递、全局数据满天飞的情况。\n\n这样会有什么隐患呢？当我们想要改某个状态数据的时候，无法直观确认这些改动会不会影响到其他地方。更让人头疼的是，在测试的时候并没有发现存在问题（毕竟有在项目规模较大的情况下，回归测试的成本也会越来越重），然后触发了线上事故。\n\n这是否又意味着所有项目都应该在最初的时候引入状态管理方案呢？除非项目在最初就已经定位为大型或复杂的应用，否则我们则需要根据预期来选型、根据需要引进不同的工具库来进行管理。同时，如果我们的项目在不断的发展和迭代过程中，则可能需要进行状态管理方案的变更。\n\n关于技术选型和项目设计的内容，我会在后续介绍。因为在掌握如何进行方案选型之前，我们还需要了解现有的各种方案。所以，今天我们主要来认识下常见的前端状态管理方案。\n\n要介绍数据在前端应用中是怎么流动的，首先我们要了解数据是如何管理的。\n\n\n数据管理\n\n一般来说，各个组件的数据都会在组件自身的实例当中进行维护。但如果一些数据涉及跨组件共享、全局共享的情况，则需要对数据进行统一的保存和维护，大多数情况下我们都会使用共享对象的方式。\n\n共享对象\n\n共享对象的原理很简单，当我们需要多个地方使用相同的数据，我们就把它们放置在一个地方，大家都去那里获取和更新。\n\n\n\n比如，我们可以简单用一个叫globaldata.js的文件来管理全局用的数据。\n\n// globaldata.js\n// globaldata 用来存全局数据\nlet globaldata = {};\n// 获取全局数据\n// 传 key 获取对应的值\n// 不传 key 获取全部值\nexport function getglobaldata(key) {\n  return key ? globaldata[key] : globaldata;\n}\n// 设置全局数据\nexport function setglobaldata(key, value) {\n  // 需要传键值对\n  if (key === undefined || value === undefined) {\n    return;\n  }\n  globaldata = { ...globaldata, [key]: value };\n  return globaldata;\n}\n\n\n除了全局数据以外，局部数据的管理同样可以使用共享对象的方式进行，我们将需要共享的数据维护在一个对象中，需要的时候则主动进行获取。\n那如果应用中存在多个共享对象，我们又该怎样管理这些对象呢？\n\n根据模块进行划分\n\n在大型应用中，维护的全局数据也会更加复杂，通过合适的方式进行拆分，可以更方便地进行管理，比如根据数据的类型、使用场景、涉及的功能，从而拆分模块的方式来进行管理。\n\n除此之外，我们还可以使用树状结构的方式来管理这些全局对象。\n\n使用树状结构管理数据\n\n在介绍第 1 讲的时候，我就有介绍前端页面中，dom 节点是基于树状结构管理的。同时，前端应用即便通过模块化和组件化一层层地进行了封装，最终依然会呈现为树状。\n\n因此，我们可以根据组件的树状作用域，结合共享对象的管理，来注入树状的数据结构。比如在 angular 中，就是使用依赖注入的方式，配合树状的组件管理，来实现数据的共享或是隔离。\n\n现在，我们知道应用中需要共享的数据可以通过怎样的方式进行管理，那么当数据发生变化的时候，又该怎样通知到依赖方吗？\n\n\n数据变更\n\n前面的第 15 讲中，我介绍了如何将应用和界面抽象成数据管理，其实被抽象的数据也就是我们常说的状态。\n\n前端项目中的数据并不只是简单地存在于应用中，相互之间会进行交互和影响。数据间的相互作用，便是我们常说的数据通信或是状态管理，包括但不限于以下的一些方式：\n\n * 事件监听与触发；\n\n * 单向数据流；\n\n * 响应式数据流。\n\n我们来分别看一下。\n\n事件监听与触发\n\n事件监听与触发的设计，一般来说会基于发布-订阅模式。想必你也比较熟悉，我们对浏览器点击、输入框的输入操作事件的绑定，就是典型的事件机制。\n\n我们也可以通过事件管理的方式，来进行数据的交互，比如 websocket 机制。\n\n事件监听和触发的原理其实很简单。监听者在进行事件监听后，会被添加到该事件的监听者队列中。事件被触发后，则可以根据该事件的监听者队列，来通知相应的监听者。\n\n在第 1 讲中，我们介绍了事件委托机制，在很多前端框架中，事件委托会挂载在页面的组件根实例上。除了挂载在组件根实例这样的方式来绑定作为事件中心，我们也可以自行创建一个事件中心来进行管理。\n\n事件通知机制很方便，可以随意控制触发的时机，也可以任意的地方监听或是触发。但前面也说过，事件机制的弊端也是很明显，就是每一个事件的触发对应一个或者多个监听，关系是一对多。\n\n设计不合理的地方，甚至可能出现一个事件会被多处触发的问题，常常是事件散落在各个地方、数据流也难以跟踪。需要定位的时候，只能通过全局搜索的方式来跟踪数据的去向，导致维护难度大大上升。\n\n以简单的博客系统来为例：\n\n\n\n这里只有事件 1 和事件 2 的触发和监听，存在跨组件甚至跨页面的事件通知。\n\n如果在一个规模较大的应用中，可能会导致满屏的事件，同时事件之间并没有什么规律可循。这样我们每次改动事件相关的代码，例如多传一个参数、改变某个参数，都可能会导致未知的错误，需要全局搜索出相关的事件，并一一进行回归测试才可以。\n\n除此之外，绑定的事件如果不能及时销毁甚至会导致内存泄漏等问题。那么，是不是在大型复杂的前端应用中，就不适合使用事件机制呢？并不是。\n\n在大型前端项目 vs code 中就使用了事件机制，并配合依赖注入的框架设计了一套事件的管理模式，包括：\n\n * 提供标准化的event和emitter能力；\n\n * 通过注册emitter，并对外提供类似生命周期的方法onxxxxx的方式，来进行事件的订阅和监听；\n\n * 通过提供通用类disposable，统一管理相关资源的注册和销毁；\n\n * 通过使用同样的方式this._register()注册事件和订阅事件，将事件相关资源的处理统一挂载到dispose()方法中。\n\n由于 vs code 中使用了依赖注入，对于模块的实例创建、销毁等都会统一交给框架来进行，从而很方便地解决了事件机制的弊端。\n\n很多时候，我们不只是选择某个技术方案这么简单，对于方案如何在项目中落地、是否需要进行适当的调整，都是需要进行思考的。\n\n下面我们继续看一下，在前端领域中更加普遍的状态管理方式：单向数据流。\n\n单向数据流\n\n如今很多前端框架都会搭配使用状态管理工具，来处理应用中的数据变更。\n\n其中，vuex/redux/flux 这些热门的状态管理工具库设计思想都基于单向数据流，它们采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n以 redux 为例，为了保证数据是单向流动的：\n\n\n\n * 使用单一的数据源：所有的状态数据都存储在store中；\n\n * 状态数据只读：只能通过action来触发数据变更；\n\n * 修改无副作用：修改现有数据的副本，并通过传递副本来更新数据。\n\n在全局数据的使用变频繁之后，我们在定位问题的时候还会遇到不知道这个数据为何改变的情况，因为所有引用到这个全局数据的地方都可能对它进行改变。\n\n这种情况下，给数据的流动一个方向，则可以方便地跟踪数据的来源和去处。\n\n同样以博客系统为例：\n\n\n\n可以看到，使用了单向数据流的状态管理方案之后，数据的变更来源、更新方向都相比事件触发要清晰。因此，也被更多开发者所推崇。\n\n除了单向数据流的方案以外，前端项目中比较热门的还有响应式的数据管理方式。\n\n响应式数据流\n\n响应式数据流的设计基于响应式编程方式，响应式编程同样基于观察者模式，它是一种面向数据流和变化传播的声明式编程方式。在前端领域，常见的异步编程场景包括事件处理、用户输入、http 响应等。\n\n对于这样的异步数据流，可以使用响应式编程的方式来进行设计，通过订阅某个数据流，可以对数据进行一系列流式处理，例如过滤、计算、转换、合流等，配合函数式编程可以实现很多优秀的场景。\n\n以 rxjs 为例，对用户的一些交互，也可以通过订阅的方式来获取需要的信息：\n\nconst observable = rx.observable.fromevent(input, "input") // 监听 input 元素的 input 事件\n  .map((e) => e.target.value) // 一旦发生，把事件对象 e 映射成 input 元素的值\n  .filter((value) => value.length >= 1) // 接着过滤掉值长度小于 1 的\n  .distinctuntilchanged() // 如果该值和过去最新的值相等，则忽略\n  .subscribe(\n    // subscribe 拿到数据\n    (x) => console.log(x),\n    (err) => console.error(err)\n  );\n// 订阅\nobservable.subscribe((x) => console.log(x));\n\n\nangular 框架本身推荐使用的状态管理工具便是 rxjs，在 angular 中结合依赖注入的方式，来进行数据流的订阅和触发，也可以很方便地对数据源和流向进行管理。\n\n除了 rxjs，基于响应式数据流设计的状态管理库包括还有 mobx。其中，rxjs 提供了基于可观察对象（observable）的响应式服务，mobx 提供了基于状态管理的响应式服务。基于响应式数据流的设计，我们可以通过各种合流的方式、订阅分流的方式，来将应用中的数据流动从头到尾串在一起。这样，我们可以很清晰地知道当前节点上的数据来自哪里，是用户的操作还是来自网络请求。\n\n对于很多复杂程度较低的前端应用来说，响应式数据流的入门成本比较高。但在一些复杂应用的场景，合理地使用响应式编程，可以有效地降低各个模块间的依赖，更加容易地进行整体数据流动管理和维护。\n\n除了天然异步的前端、客户端等 gui 开发以外，响应式编程在大数据处理中也同样拥有高并发、分布式、依赖解耦等优势，在这种同步阻塞转异步的并发场景下会有较大的性能提升，淘宝业务架构就是使用响应式的架构。\n\n\n小结\n\n我们的项目里，常常会面临应用中某些状态和数据相互影响、相互依赖的问题。\n\n今天我介绍了一些常见的状态管理的解决方案，包括事件监听、单向数据流、响应式数据流等。那么，它们之间有明显的优劣吗？\n\n其实最终还是取决于项目本身的架构、业务场景，对于简单的项目来说，使用事件监听就可以方便地解决父子组件通信的问题；当项目规模增加之后，则可能面临全局事件乱飞的问题，此时使用单向数据流或是响应式数据流的方式都可以解决该问题。\n\n实际上，复杂的前端项目中常常会同时存在多种状态管理方式，同时也会结合业务本身进行适当的调整。除了选择合适的状态管理方案以外，我们还可以通过设计合理的状态来简化一些复杂的问题场景，比如来解决前端常见的防抖和节流问题，同样可以设计状态机的方式来解决。\n\n我们在思考如何解决问题的同时，还可以找到问题的根源，并尝试分析和解决。只有这样，我们才可以脱离被层出不穷的问题缠身的状况，更加专注地进行项目优化。\n\n除了本文介绍的，你还了解到哪些状态管理的方式呢？欢迎在留言区进行讨论～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **哈：\n\n> 问几个问题：vuex：1. 为什么mutation中只能是同步？2. 为什么必须通过commit mutation的方式更改stateredux：1. 为什么reducer必须是纯函数？2. 为什么reducer必须返回新的state，而不可以修改原有state？',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何搭建前端监控体系为业务排忧解难",frontmatter:{title:"如何搭建前端监控体系为业务排忧解难",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/9c6643/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/19.%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%E4%B8%BA%E4%B8%9A%E5%8A%A1%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE.html",relativePath:"01.前端/01.前端开发笔记/19.如何搭建前端监控体系为业务排忧解难.md",key:"v-6ee75b6c",path:"/pages/9c6643/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:5765}],headersStr:"精选评论",content:"对于一个应用来说，除了前期的开发和设计，在项目上线后的维护也很重要，其中就包括监控体系的搭建。一般来说，我们之所以需要搭建前端监控体系，主要是为了解决两个问题。\n\n 1. 如何及时发现问题？\n\n 2. 如何快速定位并解决问题？\n\n既然叫前端监控体系，那么我们到底需要监控些什么内容？对于线上的系统是否运行正常，我们可以通过以下信息进行观察，包括：\n\n * 页面的整体访问情况，包括常见的 PV、UV、用户操作行为；\n\n * 页面的性能情况，包括页面加载耗时、接口耗时等各项数据统计。\n\n除此之外，我们的系统也需要具备发布灰度过程中的监控，以及用户问题的反馈和定位等能力。这些问题可以从两个角度来解决：数据采集（埋点与收集）、数据上报与监控。\n\n要对系统运行的指标进行有效的监控，我们需要对监控数据进行采集，下面我们先来看看数据的采集部分。\n\n\n数据埋点与收集\n\n在进行数据采集之前，先来看看前端监控中需要关注的数据类型。\n\n在前端应用中，系统的质量通常从三方面来评估：页面访问速度、页面稳定性/异常、外部服务调用情况。\n\n结合前面提到的页面的整体访问情况、页面的性能情况、用户问题定位等，我们可以将需要进行关注的数据分成五类。\n\n 1. 系统的生命周期数据，可用于观察页面性能情况、整体访问情况等。\n\n 2. HTTP 测速数据，可用于观察外部服务调用情况 、页面性能优化等。\n\n 3. 系统异常数据，可用于观察系统稳定性、系统异常问题。\n\n 4. 用户行为数据，可用于观察页面稳定性、整体访问情况等。\n\n 5. 用户日志，用于进行用户反馈的问题排查。\n\n我们来分别看一下，首先是应用的生命周期数据。\n\n1. 生命周期数据\n\n前端应用的生命周期指页面加载的关键时间点，通常包括页面打开、更新、关闭等耗时数据。我们可以通过PerformanceTiming属性中获取到一些生命周期相关的数据，比如：\n\n * 用于页面跳转：navigationStart、unloadEventStart/unloadEventEnd等。\n\n * 用于页面加载：domLoading、domInteractive、domContentLoadedEventStart/domContentLoadedEventEnd、loadEventStart/loadEventEnd等。\n\n除此之外，我们还可以通过document的DOMContentLoaded、readystatechange等事件，来获取页面加载的关键点。\n\n但随着前端框架的使用，页面的渲染过程、页面间的切换等逻辑都交给了框架进行控制，因此像DOMContentLoaded、readystatechange这些事件已经失去了原本的作用，很多时候我们会在框架本身提供的生命周期函数中进行数据的收集，比如在 Vue 中就有beforeCreate/created、beforeMount/mounted、beforeUpdate/updated、beforeDestroy/destroyed这些生命周期的钩子。\n\n除了框架本身提供的生命周期以外，我们还可以使用MutationObserver接口，该接口提供了监听页面 DOM 树变化的能力，结合performance获取到具体的时间。\n\n// 注册监听函数\nconst observer = new MutationObserver((mutations) => {\n  console.log(`时间：${performance.now()}，DOM树发生了变化！有以下变化类型:`);\n  for (let i = 0; i < mutations.length; i++) {\n    console.log(mutations[0].type);\n  }\n});\n// 开始监听 document 的节点变化\nobserver.observe(document, {\n  childList: true,\n  subtree: true,\n});\n\n\n除了页面加载相关的生命周期数据，HTTP 请求相关的数据也常常会被关注，这些数据常常被用作前端性能优化的指标。\n\n2. HTTP 测速数据\n\nHTTP 请求相关的数据，同样可以通过PerformanceTiming属性获取，包括 HTTP 跳转开始/结束、域名查询开始/结束等各种时间戳。\n\n通过这些数据，我们可以观察后端服务是否稳定、是否还有优化空间。\n\n由于同样是测速相关的数据，和生命周期也比较相似，这里就不展开说了，我们来看一下系统异常数据。\n\n3. 系统异常数据\n\n一般来说，脚本执行异常大多数情况下会直接导致功能不可用，因此首先需要关注系统异常的数据。\n\n常见的前端异常包括：\n\n 1. 逻辑错误，可理解为开发实现功能的时候，逻辑梳理不符合预期；\n\n 2. 代码健壮性，可理解为代码边界情况考虑不周，异常逻辑执行出错；\n\n 3. 网络错误，可理解为用户网络情况异常、后台服务异常等错误；\n\n 4. 系统错误，可理解为代码运行环境兼容性问题导致出错；\n\n 5. 页面内容异常，可理解为缺少内容、绑定事件异常、样式异常等。\n\n对于 1-4 的异常情况，可以使用window.onerror、document.addEventlistener(error)、XMLHttpRequest status等方法来进行拦截，同时可获取错误相关的信息和数据。比如，通过监听window.onerror事件，我们可以获取项目中的错误和分析堆栈，将错误信息自动上报到后台服务中。\n\n对于第 5 项的页面内容异常，大多数情况并不会影响系统中大多数功能的运行，同时也缺少可直观观察的数据信息。因此一般情况下，可以通过回归测试、UI 界面测试等方式在上线前进行避免。\n\n当然，也有比较取巧的方式，比如当某块内容缺失时，这块内容便无法进行点击，从而点击后的页面跳转等行为都会受到影响，因此可观察页面中用户操作的数据、页面访问的数据是否有异常，来辅助判断页面内容是否有异常。\n\n为此，我们会需要用到用户行为的数据。\n\n4. 用户行为数据\n\n除了常见的前端页面加载、请求耗时数据，我们还可以关注用户的一些行为数据，包括页面浏览量或点击量、用户在每一个页面的停留时间、用户通过什么入口来访问该页面、用户在页面中的一些操作行为。用户行为数据可以结合 DOM 元素的事件监听、页面的加载情况等方式来获取。\n\n这些行为数据的统计可以用来监控页面的功能是否正常，正如前面所说的，如果页面中某个点击的功能逻辑异常，必然会导致一些页面的访问量或是该功能的点击量发生变化。同时，我们还可以通过分析用户行为，针对性地调整页面功能、更好地发挥页面的作用。\n\n除此之外，通过这些用户行为数据，我们还可以统计出用户在时间轴上的操作顺序，以及每个步骤的操作时间、操作内容等，通过可视化系统直观地展示用户的链路情况，包括系统的入口来源、打开或关闭的页面、每个功能点的点击和操作时间、功能异常的情况等。\n\n用户链路相关信息还可以用来定位问题，比如配合用户日志进行分析。\n\n5. 用户日志\n\n当系统出现异常的时候，我们都会使用日志进行定位。\n\n一般来说，日志会在定位用户问题的时候使用，但我们常常需要提前在代码中打印日志。否则，当我们需要定位问题的时候，才发现自己并没有输出相关的日志，有些问题由于复现困难，再补上日志发布后也未必能复现，这样就会比较被动。\n\n这种情况可以通过添加装饰器、对类方法进行劫持等方式来进行日志的自动打印，举个例子：\n\n\n\n在每个功能模块运行时，通过使用约定的格式来打印输入参数、执行信息、输出参数，则可以通过解析日志的方式，梳理本次操作的完整调用关系、功能模块执行信息。\n\n\n\n系统运行时输出的日志，可以通过两种方式存放。\n\n 1. 上报到服务器。由于日志内容很多，如果全量上报到服务器会导致存储成本过大，同时频繁的上报也会增加接口的维护成本。除此之外，由于网络原因等还可能导致部分或全部的日志丢失等问题。\n\n 2. 本地存储。该方案需要引导用户手动操作提交本地日志，或者通过服务端下发配置自动上传，才可以获取到日志内容，从而可以进行具体的问题定位。如果无法联系到用户，或是缓存被清理的情况下，则可能由于异常无法重现而无法修复。\n\n两种方式都有各自的优缺点，因此在资源允许的情况下，也可以两个方案配合一起使用。\n\n关于前端监控中需要关注哪些数据，到这里大概介绍得差不多了。下面我们来看一下，要如何对这些数据进行采集。\n\n数据埋点与收集\n\n数据采集可以分成两个工作：数据的埋点、数据的收集。\n\n数据埋点在业界中已经是比较成熟的解决方案，其中前端常见的埋点方案有三种：代码埋点、可视化埋点、无痕埋点。\n\n我们先来通过一个表格直观地感受下它们的区别。\n\n\n\n不同的埋点方案都有各自的优点和缺点，基本上随着埋点灵活性的增加，接入和维护的成本也会越大。因此，通常情况下我们会根据使用场景来将这些方案配合使用。\n\n比如，无痕埋点一般是通过使用固定的 SDK 来进行数据的采集，但由于无痕埋点的自定义能力很弱，我们可以配合代码埋点的方式来提升埋点的灵活程度。\n\n不管使用哪种埋点方式，我们都需要对数据进行标准化处理。由于最终的数据需要落盘到服务端并进行计算和监控，因此我们需要将采集的数据，按照与服务端约定好的协议格式来进行转换。\n\n同时，为了避免用户突然关闭应用、浏览器异常等情况导致数据的丢失，还可以配合本地缓存的方式，将数据进行缓存，在应用恢复的时候进行数据的上报。\n\n那么下面，我们来看一下采集好的数据要怎么进行处理。\n\n\n数据上报\n\n前面介绍了数据的采集，为了快速发现并定位问题，我们需要将这些埋点的数据、运行的日志上报发送到服务端，服务端再进行转换、存储、计算和监控。\n\n那么，要在什么时候进行上报呢？\n\n为了避免数据的上报过于频繁、增加服务端的压力，我们可以在本地进行数据的整合，比如通过队列或数组的方式进行维护，然后选择以下方式/时机进行上报。\n\n * 定期/定量上报。\n\n对于前端来说，过于频繁的请求可能会影响到用户其他正常请求的体验，因此通常我们需要将收集到的数据存储在本地。当收集到一定数量之后再打包一次性上报，或者按照一定的频率（时间间隔）打包上传，打包上传将多次数据合并为一次，可以减轻服务器的压力。\n\n * 关键生命周期上报。\n\n由于用户可能在使用过程中遇到异常，或者在使用过程中退出，因此我们还需要在异常触发的时候、用户退出程序前进行上传，以避免问题没能及时被发现和定位。\n\n\n\n如图，当页面打开、更新、关闭等生命周期、用户在页面中的操作行为、系统异常等触发时，系统底层通过关键点监听这些事件，获取相关数据并进行标准化处理后，上报到服务端。\n\n * 用户主动提交。\n\n一些异常和使用体验问题，可以引导用户进行主动上传。当用户触发上传的操作后，可以将本地的数据和日志一并进行提交。\n\n由于系统生命周期相关数据、系统错误数据、用户行为数据等都会被用作于系统稳定性的实时监控，因此这些数据需要及时地进行上报，用户主动提交的行为可能更适合日志的上报。\n\n到这里，我们已经完成了数据的上报，那么接下来，我们来看看上报的数据要怎么进行监控。\n\n数据监控\n\n数据上报完成后，一般来说需要搭建可视化的管理端，来对这些数据进行直观的监控。\n\n在日常监控中，我们还会通过对监控数据、配置告警阈值等方式，结合邮件、机器人等方式推送到相关的人员，来及时发现并解决问题。\n\n通过上报的页面整体情况和用户行为数据，我们可以实时对各个操作信息进行分析，得到用户的操作链路、每个页面和功能操作步骤间的耗时和转化率，并进行有效监控。当页面出现异常的时候，可以及时地发现并进行告警，从而快速地解决问题。\n\n除了日常的监控以外，前端监控在发布和灰度过程中也发挥着极其重要的作用。\n\n对于链路复杂的前端应用，通过开发自测的方式保证功能是否正确是很低效的，人工测试也常常无法覆盖到所有的功能、各个链路的分支，同时自动化测试也常常因为性价比等问题无法做得很完善。\n\n因此，在新版本上线时，除了对改动相关的功能进行自测、并使用自动化测试进行回归测试之外，我们可以在上报数据的时候带上当前系统的版本号，发布过程中可以根据版本号来区分各个版本的曲线情况。\n\n在灰度过程中，我们可以关注以下信息。\n\n * 错误告警是否有新增错误，可通过错误内容找到报错位置修复。\n\n * 全版本监控观察：整体的功能点覆盖曲线是否正常，是否有异常涨跌。\n\n * 分版本监控观察：新版本是否所有功都能正常访问、灰度占比是否正常、新旧版本的转化率是否一致。\n\n通过上报数据功能曲线是否正常、异常是否在预期范围、曲线突变跟灰度时间点是否吻合等信息，我们可以确认系统新版本是否有异常，以及哪里可能有异常，如图所示。\n\n\n\n当出现数据异常的时候，可配合相应的告警渠道来及时通知相应的负责人，及时修复功能异常。如果想要做得更多，我们甚至可以结合其他系统来进行协作，比如关联 BUG 管理系统、自动生成 BUG 单，将 BUG 单绑定到对应的版本分支上，通过提交对应的修复分支、进行测试验证后，自动地扭转 BUG 单状态，等等。\n\n小结\n\n今天我主要介绍了前端监控体系的搭建，包括哪些数据需要关注、如何进行数据采集和上报、如何有效地对数据进行监控等。\n\n我们在做好功能开发之外，也会收到各种各样的神奇反馈，常常包括一些页面打不开、奇妙报错、歪扭 UI 的神秘兼容性问题。为了提升问题发现和解决的效率，搭建一套完善的前端上报和监控体系是必要的。\n\n同时，我们还可以通过将一些相似的问题进行归类，思考这类问题出现的原因有哪些，尝试从源头阻止它们的出现，才是最有效的解决方案。\n\n你的项目中是否有使用前端监控呢？你觉得好的前端监控系统具备怎样的特点呢？欢迎在留言区进行讨论。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **宇：\n\n> 项目中用过sentry，只是轻量使用\n\n# **骅：\n\n> 老师可以讲讲什么是灰度吗？查了几篇文章都没明白。\n\n#     讲师回复：\n\n>     其实这里我描述过于简略了，文中提到的“灰度”基本上都是指“灰度发布”，就是让一部分用户继续使用旧版本，一部分用户开始使用新版本，通过控制新旧版本的比例，并观察新版本功能是否正常，来逐步扩大新版本的占比，直到全量。 一般来说，灰度发布也可以用于 A/B test，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B\n\n# **历：\n\n> 请问下现在主流的监控有哪些？哨兵？\n\n#     讲师回复：\n\n>     监控这块其实很多时候都和具体项目的基础建设有关，很多时候都是由业务根据自身情况进行自主搭建的。 主要是因为监控的搭建比较简单，但维护是个大头，因此更多时候大家会把监控的维护放在可控范围内。",normalizedContent:"对于一个应用来说，除了前期的开发和设计，在项目上线后的维护也很重要，其中就包括监控体系的搭建。一般来说，我们之所以需要搭建前端监控体系，主要是为了解决两个问题。\n\n 1. 如何及时发现问题？\n\n 2. 如何快速定位并解决问题？\n\n既然叫前端监控体系，那么我们到底需要监控些什么内容？对于线上的系统是否运行正常，我们可以通过以下信息进行观察，包括：\n\n * 页面的整体访问情况，包括常见的 pv、uv、用户操作行为；\n\n * 页面的性能情况，包括页面加载耗时、接口耗时等各项数据统计。\n\n除此之外，我们的系统也需要具备发布灰度过程中的监控，以及用户问题的反馈和定位等能力。这些问题可以从两个角度来解决：数据采集（埋点与收集）、数据上报与监控。\n\n要对系统运行的指标进行有效的监控，我们需要对监控数据进行采集，下面我们先来看看数据的采集部分。\n\n\n数据埋点与收集\n\n在进行数据采集之前，先来看看前端监控中需要关注的数据类型。\n\n在前端应用中，系统的质量通常从三方面来评估：页面访问速度、页面稳定性/异常、外部服务调用情况。\n\n结合前面提到的页面的整体访问情况、页面的性能情况、用户问题定位等，我们可以将需要进行关注的数据分成五类。\n\n 1. 系统的生命周期数据，可用于观察页面性能情况、整体访问情况等。\n\n 2. http 测速数据，可用于观察外部服务调用情况 、页面性能优化等。\n\n 3. 系统异常数据，可用于观察系统稳定性、系统异常问题。\n\n 4. 用户行为数据，可用于观察页面稳定性、整体访问情况等。\n\n 5. 用户日志，用于进行用户反馈的问题排查。\n\n我们来分别看一下，首先是应用的生命周期数据。\n\n1. 生命周期数据\n\n前端应用的生命周期指页面加载的关键时间点，通常包括页面打开、更新、关闭等耗时数据。我们可以通过performancetiming属性中获取到一些生命周期相关的数据，比如：\n\n * 用于页面跳转：navigationstart、unloadeventstart/unloadeventend等。\n\n * 用于页面加载：domloading、dominteractive、domcontentloadedeventstart/domcontentloadedeventend、loadeventstart/loadeventend等。\n\n除此之外，我们还可以通过document的domcontentloaded、readystatechange等事件，来获取页面加载的关键点。\n\n但随着前端框架的使用，页面的渲染过程、页面间的切换等逻辑都交给了框架进行控制，因此像domcontentloaded、readystatechange这些事件已经失去了原本的作用，很多时候我们会在框架本身提供的生命周期函数中进行数据的收集，比如在 vue 中就有beforecreate/created、beforemount/mounted、beforeupdate/updated、beforedestroy/destroyed这些生命周期的钩子。\n\n除了框架本身提供的生命周期以外，我们还可以使用mutationobserver接口，该接口提供了监听页面 dom 树变化的能力，结合performance获取到具体的时间。\n\n// 注册监听函数\nconst observer = new mutationobserver((mutations) => {\n  console.log(`时间：${performance.now()}，dom树发生了变化！有以下变化类型:`);\n  for (let i = 0; i < mutations.length; i++) {\n    console.log(mutations[0].type);\n  }\n});\n// 开始监听 document 的节点变化\nobserver.observe(document, {\n  childlist: true,\n  subtree: true,\n});\n\n\n除了页面加载相关的生命周期数据，http 请求相关的数据也常常会被关注，这些数据常常被用作前端性能优化的指标。\n\n2. http 测速数据\n\nhttp 请求相关的数据，同样可以通过performancetiming属性获取，包括 http 跳转开始/结束、域名查询开始/结束等各种时间戳。\n\n通过这些数据，我们可以观察后端服务是否稳定、是否还有优化空间。\n\n由于同样是测速相关的数据，和生命周期也比较相似，这里就不展开说了，我们来看一下系统异常数据。\n\n3. 系统异常数据\n\n一般来说，脚本执行异常大多数情况下会直接导致功能不可用，因此首先需要关注系统异常的数据。\n\n常见的前端异常包括：\n\n 1. 逻辑错误，可理解为开发实现功能的时候，逻辑梳理不符合预期；\n\n 2. 代码健壮性，可理解为代码边界情况考虑不周，异常逻辑执行出错；\n\n 3. 网络错误，可理解为用户网络情况异常、后台服务异常等错误；\n\n 4. 系统错误，可理解为代码运行环境兼容性问题导致出错；\n\n 5. 页面内容异常，可理解为缺少内容、绑定事件异常、样式异常等。\n\n对于 1-4 的异常情况，可以使用window.onerror、document.addeventlistener(error)、xmlhttprequest status等方法来进行拦截，同时可获取错误相关的信息和数据。比如，通过监听window.onerror事件，我们可以获取项目中的错误和分析堆栈，将错误信息自动上报到后台服务中。\n\n对于第 5 项的页面内容异常，大多数情况并不会影响系统中大多数功能的运行，同时也缺少可直观观察的数据信息。因此一般情况下，可以通过回归测试、ui 界面测试等方式在上线前进行避免。\n\n当然，也有比较取巧的方式，比如当某块内容缺失时，这块内容便无法进行点击，从而点击后的页面跳转等行为都会受到影响，因此可观察页面中用户操作的数据、页面访问的数据是否有异常，来辅助判断页面内容是否有异常。\n\n为此，我们会需要用到用户行为的数据。\n\n4. 用户行为数据\n\n除了常见的前端页面加载、请求耗时数据，我们还可以关注用户的一些行为数据，包括页面浏览量或点击量、用户在每一个页面的停留时间、用户通过什么入口来访问该页面、用户在页面中的一些操作行为。用户行为数据可以结合 dom 元素的事件监听、页面的加载情况等方式来获取。\n\n这些行为数据的统计可以用来监控页面的功能是否正常，正如前面所说的，如果页面中某个点击的功能逻辑异常，必然会导致一些页面的访问量或是该功能的点击量发生变化。同时，我们还可以通过分析用户行为，针对性地调整页面功能、更好地发挥页面的作用。\n\n除此之外，通过这些用户行为数据，我们还可以统计出用户在时间轴上的操作顺序，以及每个步骤的操作时间、操作内容等，通过可视化系统直观地展示用户的链路情况，包括系统的入口来源、打开或关闭的页面、每个功能点的点击和操作时间、功能异常的情况等。\n\n用户链路相关信息还可以用来定位问题，比如配合用户日志进行分析。\n\n5. 用户日志\n\n当系统出现异常的时候，我们都会使用日志进行定位。\n\n一般来说，日志会在定位用户问题的时候使用，但我们常常需要提前在代码中打印日志。否则，当我们需要定位问题的时候，才发现自己并没有输出相关的日志，有些问题由于复现困难，再补上日志发布后也未必能复现，这样就会比较被动。\n\n这种情况可以通过添加装饰器、对类方法进行劫持等方式来进行日志的自动打印，举个例子：\n\n\n\n在每个功能模块运行时，通过使用约定的格式来打印输入参数、执行信息、输出参数，则可以通过解析日志的方式，梳理本次操作的完整调用关系、功能模块执行信息。\n\n\n\n系统运行时输出的日志，可以通过两种方式存放。\n\n 1. 上报到服务器。由于日志内容很多，如果全量上报到服务器会导致存储成本过大，同时频繁的上报也会增加接口的维护成本。除此之外，由于网络原因等还可能导致部分或全部的日志丢失等问题。\n\n 2. 本地存储。该方案需要引导用户手动操作提交本地日志，或者通过服务端下发配置自动上传，才可以获取到日志内容，从而可以进行具体的问题定位。如果无法联系到用户，或是缓存被清理的情况下，则可能由于异常无法重现而无法修复。\n\n两种方式都有各自的优缺点，因此在资源允许的情况下，也可以两个方案配合一起使用。\n\n关于前端监控中需要关注哪些数据，到这里大概介绍得差不多了。下面我们来看一下，要如何对这些数据进行采集。\n\n数据埋点与收集\n\n数据采集可以分成两个工作：数据的埋点、数据的收集。\n\n数据埋点在业界中已经是比较成熟的解决方案，其中前端常见的埋点方案有三种：代码埋点、可视化埋点、无痕埋点。\n\n我们先来通过一个表格直观地感受下它们的区别。\n\n\n\n不同的埋点方案都有各自的优点和缺点，基本上随着埋点灵活性的增加，接入和维护的成本也会越大。因此，通常情况下我们会根据使用场景来将这些方案配合使用。\n\n比如，无痕埋点一般是通过使用固定的 sdk 来进行数据的采集，但由于无痕埋点的自定义能力很弱，我们可以配合代码埋点的方式来提升埋点的灵活程度。\n\n不管使用哪种埋点方式，我们都需要对数据进行标准化处理。由于最终的数据需要落盘到服务端并进行计算和监控，因此我们需要将采集的数据，按照与服务端约定好的协议格式来进行转换。\n\n同时，为了避免用户突然关闭应用、浏览器异常等情况导致数据的丢失，还可以配合本地缓存的方式，将数据进行缓存，在应用恢复的时候进行数据的上报。\n\n那么下面，我们来看一下采集好的数据要怎么进行处理。\n\n\n数据上报\n\n前面介绍了数据的采集，为了快速发现并定位问题，我们需要将这些埋点的数据、运行的日志上报发送到服务端，服务端再进行转换、存储、计算和监控。\n\n那么，要在什么时候进行上报呢？\n\n为了避免数据的上报过于频繁、增加服务端的压力，我们可以在本地进行数据的整合，比如通过队列或数组的方式进行维护，然后选择以下方式/时机进行上报。\n\n * 定期/定量上报。\n\n对于前端来说，过于频繁的请求可能会影响到用户其他正常请求的体验，因此通常我们需要将收集到的数据存储在本地。当收集到一定数量之后再打包一次性上报，或者按照一定的频率（时间间隔）打包上传，打包上传将多次数据合并为一次，可以减轻服务器的压力。\n\n * 关键生命周期上报。\n\n由于用户可能在使用过程中遇到异常，或者在使用过程中退出，因此我们还需要在异常触发的时候、用户退出程序前进行上传，以避免问题没能及时被发现和定位。\n\n\n\n如图，当页面打开、更新、关闭等生命周期、用户在页面中的操作行为、系统异常等触发时，系统底层通过关键点监听这些事件，获取相关数据并进行标准化处理后，上报到服务端。\n\n * 用户主动提交。\n\n一些异常和使用体验问题，可以引导用户进行主动上传。当用户触发上传的操作后，可以将本地的数据和日志一并进行提交。\n\n由于系统生命周期相关数据、系统错误数据、用户行为数据等都会被用作于系统稳定性的实时监控，因此这些数据需要及时地进行上报，用户主动提交的行为可能更适合日志的上报。\n\n到这里，我们已经完成了数据的上报，那么接下来，我们来看看上报的数据要怎么进行监控。\n\n数据监控\n\n数据上报完成后，一般来说需要搭建可视化的管理端，来对这些数据进行直观的监控。\n\n在日常监控中，我们还会通过对监控数据、配置告警阈值等方式，结合邮件、机器人等方式推送到相关的人员，来及时发现并解决问题。\n\n通过上报的页面整体情况和用户行为数据，我们可以实时对各个操作信息进行分析，得到用户的操作链路、每个页面和功能操作步骤间的耗时和转化率，并进行有效监控。当页面出现异常的时候，可以及时地发现并进行告警，从而快速地解决问题。\n\n除了日常的监控以外，前端监控在发布和灰度过程中也发挥着极其重要的作用。\n\n对于链路复杂的前端应用，通过开发自测的方式保证功能是否正确是很低效的，人工测试也常常无法覆盖到所有的功能、各个链路的分支，同时自动化测试也常常因为性价比等问题无法做得很完善。\n\n因此，在新版本上线时，除了对改动相关的功能进行自测、并使用自动化测试进行回归测试之外，我们可以在上报数据的时候带上当前系统的版本号，发布过程中可以根据版本号来区分各个版本的曲线情况。\n\n在灰度过程中，我们可以关注以下信息。\n\n * 错误告警是否有新增错误，可通过错误内容找到报错位置修复。\n\n * 全版本监控观察：整体的功能点覆盖曲线是否正常，是否有异常涨跌。\n\n * 分版本监控观察：新版本是否所有功都能正常访问、灰度占比是否正常、新旧版本的转化率是否一致。\n\n通过上报数据功能曲线是否正常、异常是否在预期范围、曲线突变跟灰度时间点是否吻合等信息，我们可以确认系统新版本是否有异常，以及哪里可能有异常，如图所示。\n\n\n\n当出现数据异常的时候，可配合相应的告警渠道来及时通知相应的负责人，及时修复功能异常。如果想要做得更多，我们甚至可以结合其他系统来进行协作，比如关联 bug 管理系统、自动生成 bug 单，将 bug 单绑定到对应的版本分支上，通过提交对应的修复分支、进行测试验证后，自动地扭转 bug 单状态，等等。\n\n小结\n\n今天我主要介绍了前端监控体系的搭建，包括哪些数据需要关注、如何进行数据采集和上报、如何有效地对数据进行监控等。\n\n我们在做好功能开发之外，也会收到各种各样的神奇反馈，常常包括一些页面打不开、奇妙报错、歪扭 ui 的神秘兼容性问题。为了提升问题发现和解决的效率，搭建一套完善的前端上报和监控体系是必要的。\n\n同时，我们还可以通过将一些相似的问题进行归类，思考这类问题出现的原因有哪些，尝试从源头阻止它们的出现，才是最有效的解决方案。\n\n你的项目中是否有使用前端监控呢？你觉得好的前端监控系统具备怎样的特点呢？欢迎在留言区进行讨论。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **宇：\n\n> 项目中用过sentry，只是轻量使用\n\n# **骅：\n\n> 老师可以讲讲什么是灰度吗？查了几篇文章都没明白。\n\n#     讲师回复：\n\n>     其实这里我描述过于简略了，文中提到的“灰度”基本上都是指“灰度发布”，就是让一部分用户继续使用旧版本，一部分用户开始使用新版本，通过控制新旧版本的比例，并观察新版本功能是否正常，来逐步扩大新版本的占比，直到全量。 一般来说，灰度发布也可以用于 a/b test，即让一部分用户继续用产品特性a，一部分用户开始用产品特性b\n\n# **历：\n\n> 请问下现在主流的监控有哪些？哨兵？\n\n#     讲师回复：\n\n>     监控这块其实很多时候都和具体项目的基础建设有关，很多时候都是由业务根据自身情况进行自主搭建的。 主要是因为监控的搭建比较简单，但维护是个大头，因此更多时候大家会把监控的维护放在可控范围内。",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何进行性能分析的自动化实现",frontmatter:{title:"如何进行性能分析的自动化实现",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/aeb6b9/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20.%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0.html",relativePath:"01.前端/01.前端开发笔记/20.如何进行性能分析的自动化实现.md",key:"v-c43a3196",path:"/pages/aeb6b9/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:6400}],headersStr:"精选评论",content:"如今网络速度越来越快、机器性能也越来越好，用户对于页面加载要求也随之增高，页面白屏过久、操作卡顿等问题对用户来说是无法忍受的，因此性能分析成了前端开发工作中的家常便饭。\n\n常见的性能分析解决方案会在下一讲介绍，今天我先带你了解前端性能分析常用的工具，以及如何使用这些工具实现性能分析的自动化。\n\n通常来说，前端的性能分析可以从时间和空间两个角度来进行。\n\n * 时间：常见耗时，如页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等。\n\n * 空间：资源占用，包括 CPU 占用、内存占用、本地缓存占用等。\n\n要分析和查看这些时间和空间的数据，需要用到性能分析工具。现在大多数前端项目的性能问题都是通过 Chrome DevTools 进行定位和分析的，因此下面我先来介绍一下 Chrome DevTools 工具。\n\n\nChrome DevTools\n\n相信大家都在开发过程中使用过 Chrome DevTools，它提供了特别丰富的开发者调试功能，这里我主要介绍两个面板：\n\n 1. Lighthouse 面板，该面板用于自动化分析网站加载时存在的性能问题，并提出推荐的优化方案；\n\n 2. Performance 面板，该面板用于记录和分析网站在运行时的性能数据。\n\n这两个面板的功能有什么区别呢？我们又该在什么时候使用哪一个呢？\n\n我先带大家来分别认识下。\n\nLighthouse\n\n使用 Lighthouse 可以快速了解自己网站在加载过程中存在的一些性能问题，并进行优化解决，它的前身是 Chrome DevTools 面板中的 Audits。\n\nLighthouse 面板的优势在于自动化、成本低，它会收集网站加载时的一些性能数据（Javascript/CSS 加载情况、HTTP 请求耗时、页面加载和渲染耗时等），并根据最佳实践来给每一项进行打分，同时针对低分项给出对应的优化方案。\n\n我们先来看一下 Lighthouse 提供了怎样的一些功能。它的主要功能包括三个：\n\n * 在一系列的测试下运行网页，比如不同尺寸的设备和不同的网络速度；\n\n * 检查页面对辅助功能指南的一致性，例如颜色对比度和 ARIA 最佳实践；\n\n * 生成网页运行报告，比如网页性能、常见的统计耗时、网页的优化方向。\n\n使用 Lighthouse 提供的功能，在不到几分钟的时间内，Lighthouse 就可以给出这样一份报告。\n\n\n\n可以看到，这份报告从 5 个方面来对页面进行分析，包括性能、辅助功能、最佳实践、搜索引擎优化和 PWA。通过这份报告，我们可以快速掌握网站加载的整体情况，并根据报告提供的优化方向进行优化。\n\n想要知道 Lighthouse 是如何做到的，我们需要了解下 Lighthouse 内部的架构和工作原理。\n\nLighthouse 的组成部分主要包括四个：驱动（Driver）、收集器（Gatherers）、审查器（Audits）和报告（Report），如图所示。\n\n\n\n可以看到，Lighthouse 的具体工作过程为：\n\n 1. 当网站页面开始加载之后，Lighthouse 会使用驱动（Driver）通过 Chrome DevTools Protocol 获取页面的性能数据；\n\n 2. 驱动（Driver）获取到的数据会被收集器（Gatherers）进行收集，并输出被称为 Artifact 的结果；\n\n 3. Artifact 会作为审查器（Audits）的输入，审查器会对其运行测试，然后分配通过/失败/得分的结果；\n\n 4. 审查的结果给到报告（Report），对各个部分进行加权和统计得到面向用户的报告（如最佳实践），并将该报告渲染给用户。\n\n其中，Chrome DevTools Protocol 是我们在 Chrome 中实现性能测试自动化中非常重要的协议，后面会在性能分析自动化部分进行介绍，这里先不进行过多的拓展。\n\n如果你希望短时间内对你的网站进行较全面的评估，可以使用 Lighthouse 来跑一下分数，确定大致的优化方向。但 Lighthouse 不能用于运行时的性能分析，也无法给到最佳实践以外更多的数据和建议。\n\n而 Performance 面板则可以弥补 LightHouse 的不足。\n\nPerformance 面板\n\nPerformance 面板同样有个前身，叫 Timeline 面板，它常常在页面运行时使用，比如用户点击操作之后的逻辑执行、页面滚动时的页面渲染情况，等等。\n\n我们先来看看 Performance 提供了什么功能。\n\nPerformance 面板功能特别多，一般来说我们需要先对页面运行过程进行录制。录制过程最好打开隐身模式，这样可确保 Chrome 不被拓展插件影响，从而以干净的状态运行。\n\n录制完成后，DevTools 会进行数据处理，然后在 Performance 面板上显示结果，如图所示。\n\n\n\n一般来说，我们需要分析和使用到 Performance 面板上的这些结果。\n\n * FPS 图表：当在 FPS 上方看到红色条形时，表示帧速率下降得太低，以至可能损害用户体验。\n\n * CPU 图表：CPU 图表的颜色对应于性能板的底部的 Summary 选项卡。\n\n * 火焰图：火焰图直观地表示出了内部的 CPU 分析，横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方；启用 JS 分析器后，火焰图会显示调用的每个 JavaScript 函数，可用于分析具体函数。\n\n * Buttom-up：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的调用路径。\n\n具体要怎么定位某些性能瓶颈，可以参考官方文档系列文章，这里就不进行更详细的拓展了。\n\n我们还可以使用 Performance Monitor，来对页面运行过程中的一些性能指标进行监控，比如 CPU 占用率、JS 内存使用大小、内存中挂载的 DOM 节点个数、事件监听数，等等。\n\n通过 Performance 面板，我们可以得到详细的运行时性能数据，包括函数的调用情况（调用耗时、调用堆栈）、各类事件（渲染事件、加载事件、脚本事件等）的顺序与耗时、CPU 占用情况，等等。\n\n我们可根据这些数据定位到具体哪段脚本的执行导致的性能问题，从而得到解决方案。\n\n使用 Performance 面板进行性能分析，具体的分析过程会比较烦琐，同时上手成本也不低，除了基本的页面加载耗时、网络耗时。如果你希望具体定位到哪一块代码的执行有问题，则需要结合前面介绍的 FPS、CPU、火焰图等一点点来进行更详细的分析。\n\n同时，性能分析并不是一蹴而就的工作，往往在我们对前端应用完成性能优化之后，随着新功能的迭代、项目规模的扩大，很可能在网页运行一段时间之后又会变慢、出现卡顿。\n\n那么，为了降低性能分析工作的成本，同时避免新功能的开发、代码重构等导致的性能下降未能及时发现的问题，我们可以考虑将性能分析自动化。\n\n\n性能分析自动化\n\n如果想要自动化地进行性能分析，意味着我们需要拿到浏览器的运行性能数据。\n\n一般来说，我们可以通过集成测试、自动化测试等技术手段让项目的代码运行在浏览器中，并根据脚本来运行相应的功能。在此基础上，我们还需要获取网页加载和运行的性能数据。\n\n结合前面提到的性能分析工具，我们可以考虑分别将 Lighthouse 和 Performance 功能进行自动化。\n\n先来看 Lighthouse 自动化。\n\nLighthouse 自动化\n\nLighthouse 自动化很简单，因为它提供了脚本的方式使用。因此，我们可以通过自动化任务跑脚本的方式，使用 Lighthouse 跑分析报告，通过对比以往的数据来进行功能变更、性能优化等场景的性能回归。\n\n使用 Lighthouse 的优势在于开发成本低，只需要按照官方提供的配置来调整、获取自己需要的一些数据，就可以快速接入较全面的 Lighthouse 拥有的性能分析能力。\n\n前面也说过，Lighthouse 是使用驱动（Driver）通过 Chrome DevTools Protocol 获取页面加载过程中的性能数据。其实通过 Chrome DevTools Protocol，我们还可以获取在 Performance 中的一些性能数据。\n\n那么 Chrome DevTools Protocol 到底是什么呢？我们一起来看一下。\n\nChrome DevTools Protocol\n\nChrome DevTools Protocol允许第三方对基于 Chrome 的网站进行检测、调试、分析等操作。\n\n也就是说，我们可以自行开发工具，通过 Chrome DevTools Protocol 来获取 Chrome 中网站运行的性能数据。\n\n那么，这个 Chrome DevTools Protocol 到底是什么呢？我们可以从 Chrome DevTools 和浏览器内核的通信过程说起。\n\n实际上，我们使用的 Chrome DevTools，也就是 Chrome 中的浏览器调试工具界面，其实是一个 Web 应用。\n\n当我们打开 Chrome DevTools 的时候，浏览器内核 Chromium 本身会作为一个服务端，它会通过 WebSocket 与 Chrome DevTools 进行通信，过程如下：\n\n 1. DevTools 将作为客户端，与作为服务端的 Chromium 建立连接；\n\n 2. DevTools 通过 HTTP 获取 HTML、JavaScript 和 CSS 资源，并进行加载；\n\n 3. 资源加载后，DevTools 会建立与浏览器的 WebSocket 连接；\n\n 4. Chrome DevTools Protocol 基于 WebSocket，它利用 WebSocket 建立连接 DevTools 和浏览器内核的快速数据通道。\n\n也就是说，DevTools 和浏览器内核的数据通信，是通过 Chrome DevTools Protocol 来完成。同样的，当我们通过 DevTools 从 Windows、Mac 或 Linux 计算机远程调试 Android 设备上的实时内容时，使用的也是该协议。\n\n那么，Chrome DevTools Protocol 这个协议它到底提供了什么内容呢？\n\nChrome DevTools Protocol 具有与浏览器的许多不同部分（例如页面、Service Worker 和扩展程序）进行交互的 API。该协议把不同的操作划分为了不同的域（domain），每个域负责不同的功能模块，比如DOM、Debugger、Network、Console和Performance等，可以理解为 DevTools 中的不同功能模块。\n\n这里我主要介绍几个和性能相关的域。\n\n * Performance域：可获取运行时性能指标，包括页面 DOM 节点数量、Javascript 栈数量、页面布局耗时等。\n\n * Tracing域：可获取页面加载的 DevTools 性能跟踪，可以使用Tracing.start和Tracing.stop创建可在 Chrome DevTools 或时间轴查看器中打开的跟踪文件。\n\n * Runtime域：通过远程评估和镜像对象暴露 JavaScript 的运行时，可以获取 JavaScript 栈的使用情况。\n\n * Network域：可以分析网络相关的性能。\n\n * 其他涉及 DOM 节点、JS 执行等相关数据的域。\n\n通过使用 Chrome DevTools Protocol，我们可以获取 DevTools 提供的很多数据，包括网络数据、性能数据、运行时数据，比如获取 JS 的 Runtime 数据，像window.performance、window.chrome.loadTimes()等。\n\n对于如何使用该协议，其实已有针对这个协议封装出不同语言的库，包括 Node.js、Python、Java 等，可以在awesome-chrome-devtools这个项目中找到。\n\n除了直接使用 Chrome DevTools Protocol 之外，我们还可以使用Puppeteer的CDPSession，它们封装了 Chrome DevTools Protocol 能力，提供了更加便捷的使用方式，比如：\n\n * 通过session.sendmethod调用 Chrome DevTools Protocol 协议方法；\n\n * 通过session.on方法订阅 Chrome DevTools Protocol 协议事件。\n\n既然我们可以拿到这些性能数据，那么也可以根据业务的需要对这些数据进行自动化的分析，结合前端工程化在项目上线前进行自动化任务的执行、检测、生成对比报告等，实现自动化性能监控。\n\n自动化性能监控\n\n现在我们已经知道，通过 Chrome DevTools Protocol，可以实现在一个模拟的浏览器环境中，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。\n\n上面提到的性能测试过程，属于前端性能监控中的合成监控（Synthetic Monitoring，SYN）方式。合成监控的使用场景不多，一般可能出现在开发和测试的过程中，例如结合流水线跑性能报告、定位性能问题时本地跑的一些简单任务分析等。\n\n该方式的优点显而易见：\n\n * 可采集更丰富的数据指标，例如结合 Chrome DevTools Protocol 获取到的数据；\n\n * 较成熟的解决方案和工具，实现成本低；\n\n * 不影响真实用户的性能体验。\n\n至于如何搭建这样一套自动化分析系统，其实 Lighthouse 便是最好的参考例子。前面我们有介绍它的架构和工作原理，同时它也是开源的一个自动化工具，有现成的代码可以作为参考。\n\n由于代码的运行环境是模拟环境，因此很多线上的运行问题难以发现。为了解决这个问题，我们还可以进行真实用户监控（Real User Monitoring，RUM）。\n\n真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标。常见的一些性能监控包括加载耗时、DOM 渲染耗时、接口耗时统计等，我们已经在第 19 讲介绍前端监控体系的时候有所介绍。\n\n真实用户监控往往需要结合业务本身的前后端架构设计来建设，其优点也比较容易理解：\n\n * 完全还原真实场景，减去模拟成本；\n\n * 数据样本足够抹平个体的差异；\n\n * 采集数据可用于更多场景的分析和优化。\n\n对比合成监控，真实用户监控在有些场景下无法拿到更多的性能分析数据，例如哪些代码执行中导致了 CPU 占用高、内存占用高。但真实用户监控也有自身的优势，在各种环境下的一些运行耗时问题（例如 TCP、DNS 连接耗时过高），使用合成监控是难以发现的。\n\n\n小结\n\n今天我主要介绍了前端性能分析中常用的工具，以及它的底层工作原理，同时还介绍了要如何将前端性能分析进行自动化。\n\n正如前端性能分析存在门槛高、耗时长、频繁发生等问题，我们可以转换思路将其进行自动化处理。同样的，我们会被烦琐的工作内容困扰的时候，也可以尝试如果跳出工作内容本身来进行思考，或许会有更优解。\n\n你在工作中是否也存在可以使用自动化工具解决的问题呢？欢迎在留言区留下你的思考。\n\n----------------------------------------\n\n\n# 精选评论",normalizedContent:"如今网络速度越来越快、机器性能也越来越好，用户对于页面加载要求也随之增高，页面白屏过久、操作卡顿等问题对用户来说是无法忍受的，因此性能分析成了前端开发工作中的家常便饭。\n\n常见的性能分析解决方案会在下一讲介绍，今天我先带你了解前端性能分析常用的工具，以及如何使用这些工具实现性能分析的自动化。\n\n通常来说，前端的性能分析可以从时间和空间两个角度来进行。\n\n * 时间：常见耗时，如页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等。\n\n * 空间：资源占用，包括 cpu 占用、内存占用、本地缓存占用等。\n\n要分析和查看这些时间和空间的数据，需要用到性能分析工具。现在大多数前端项目的性能问题都是通过 chrome devtools 进行定位和分析的，因此下面我先来介绍一下 chrome devtools 工具。\n\n\nchrome devtools\n\n相信大家都在开发过程中使用过 chrome devtools，它提供了特别丰富的开发者调试功能，这里我主要介绍两个面板：\n\n 1. lighthouse 面板，该面板用于自动化分析网站加载时存在的性能问题，并提出推荐的优化方案；\n\n 2. performance 面板，该面板用于记录和分析网站在运行时的性能数据。\n\n这两个面板的功能有什么区别呢？我们又该在什么时候使用哪一个呢？\n\n我先带大家来分别认识下。\n\nlighthouse\n\n使用 lighthouse 可以快速了解自己网站在加载过程中存在的一些性能问题，并进行优化解决，它的前身是 chrome devtools 面板中的 audits。\n\nlighthouse 面板的优势在于自动化、成本低，它会收集网站加载时的一些性能数据（javascript/css 加载情况、http 请求耗时、页面加载和渲染耗时等），并根据最佳实践来给每一项进行打分，同时针对低分项给出对应的优化方案。\n\n我们先来看一下 lighthouse 提供了怎样的一些功能。它的主要功能包括三个：\n\n * 在一系列的测试下运行网页，比如不同尺寸的设备和不同的网络速度；\n\n * 检查页面对辅助功能指南的一致性，例如颜色对比度和 aria 最佳实践；\n\n * 生成网页运行报告，比如网页性能、常见的统计耗时、网页的优化方向。\n\n使用 lighthouse 提供的功能，在不到几分钟的时间内，lighthouse 就可以给出这样一份报告。\n\n\n\n可以看到，这份报告从 5 个方面来对页面进行分析，包括性能、辅助功能、最佳实践、搜索引擎优化和 pwa。通过这份报告，我们可以快速掌握网站加载的整体情况，并根据报告提供的优化方向进行优化。\n\n想要知道 lighthouse 是如何做到的，我们需要了解下 lighthouse 内部的架构和工作原理。\n\nlighthouse 的组成部分主要包括四个：驱动（driver）、收集器（gatherers）、审查器（audits）和报告（report），如图所示。\n\n\n\n可以看到，lighthouse 的具体工作过程为：\n\n 1. 当网站页面开始加载之后，lighthouse 会使用驱动（driver）通过 chrome devtools protocol 获取页面的性能数据；\n\n 2. 驱动（driver）获取到的数据会被收集器（gatherers）进行收集，并输出被称为 artifact 的结果；\n\n 3. artifact 会作为审查器（audits）的输入，审查器会对其运行测试，然后分配通过/失败/得分的结果；\n\n 4. 审查的结果给到报告（report），对各个部分进行加权和统计得到面向用户的报告（如最佳实践），并将该报告渲染给用户。\n\n其中，chrome devtools protocol 是我们在 chrome 中实现性能测试自动化中非常重要的协议，后面会在性能分析自动化部分进行介绍，这里先不进行过多的拓展。\n\n如果你希望短时间内对你的网站进行较全面的评估，可以使用 lighthouse 来跑一下分数，确定大致的优化方向。但 lighthouse 不能用于运行时的性能分析，也无法给到最佳实践以外更多的数据和建议。\n\n而 performance 面板则可以弥补 lighthouse 的不足。\n\nperformance 面板\n\nperformance 面板同样有个前身，叫 timeline 面板，它常常在页面运行时使用，比如用户点击操作之后的逻辑执行、页面滚动时的页面渲染情况，等等。\n\n我们先来看看 performance 提供了什么功能。\n\nperformance 面板功能特别多，一般来说我们需要先对页面运行过程进行录制。录制过程最好打开隐身模式，这样可确保 chrome 不被拓展插件影响，从而以干净的状态运行。\n\n录制完成后，devtools 会进行数据处理，然后在 performance 面板上显示结果，如图所示。\n\n\n\n一般来说，我们需要分析和使用到 performance 面板上的这些结果。\n\n * fps 图表：当在 fps 上方看到红色条形时，表示帧速率下降得太低，以至可能损害用户体验。\n\n * cpu 图表：cpu 图表的颜色对应于性能板的底部的 summary 选项卡。\n\n * 火焰图：火焰图直观地表示出了内部的 cpu 分析，横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方；启用 js 分析器后，火焰图会显示调用的每个 javascript 函数，可用于分析具体函数。\n\n * buttom-up：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的调用路径。\n\n具体要怎么定位某些性能瓶颈，可以参考官方文档系列文章，这里就不进行更详细的拓展了。\n\n我们还可以使用 performance monitor，来对页面运行过程中的一些性能指标进行监控，比如 cpu 占用率、js 内存使用大小、内存中挂载的 dom 节点个数、事件监听数，等等。\n\n通过 performance 面板，我们可以得到详细的运行时性能数据，包括函数的调用情况（调用耗时、调用堆栈）、各类事件（渲染事件、加载事件、脚本事件等）的顺序与耗时、cpu 占用情况，等等。\n\n我们可根据这些数据定位到具体哪段脚本的执行导致的性能问题，从而得到解决方案。\n\n使用 performance 面板进行性能分析，具体的分析过程会比较烦琐，同时上手成本也不低，除了基本的页面加载耗时、网络耗时。如果你希望具体定位到哪一块代码的执行有问题，则需要结合前面介绍的 fps、cpu、火焰图等一点点来进行更详细的分析。\n\n同时，性能分析并不是一蹴而就的工作，往往在我们对前端应用完成性能优化之后，随着新功能的迭代、项目规模的扩大，很可能在网页运行一段时间之后又会变慢、出现卡顿。\n\n那么，为了降低性能分析工作的成本，同时避免新功能的开发、代码重构等导致的性能下降未能及时发现的问题，我们可以考虑将性能分析自动化。\n\n\n性能分析自动化\n\n如果想要自动化地进行性能分析，意味着我们需要拿到浏览器的运行性能数据。\n\n一般来说，我们可以通过集成测试、自动化测试等技术手段让项目的代码运行在浏览器中，并根据脚本来运行相应的功能。在此基础上，我们还需要获取网页加载和运行的性能数据。\n\n结合前面提到的性能分析工具，我们可以考虑分别将 lighthouse 和 performance 功能进行自动化。\n\n先来看 lighthouse 自动化。\n\nlighthouse 自动化\n\nlighthouse 自动化很简单，因为它提供了脚本的方式使用。因此，我们可以通过自动化任务跑脚本的方式，使用 lighthouse 跑分析报告，通过对比以往的数据来进行功能变更、性能优化等场景的性能回归。\n\n使用 lighthouse 的优势在于开发成本低，只需要按照官方提供的配置来调整、获取自己需要的一些数据，就可以快速接入较全面的 lighthouse 拥有的性能分析能力。\n\n前面也说过，lighthouse 是使用驱动（driver）通过 chrome devtools protocol 获取页面加载过程中的性能数据。其实通过 chrome devtools protocol，我们还可以获取在 performance 中的一些性能数据。\n\n那么 chrome devtools protocol 到底是什么呢？我们一起来看一下。\n\nchrome devtools protocol\n\nchrome devtools protocol允许第三方对基于 chrome 的网站进行检测、调试、分析等操作。\n\n也就是说，我们可以自行开发工具，通过 chrome devtools protocol 来获取 chrome 中网站运行的性能数据。\n\n那么，这个 chrome devtools protocol 到底是什么呢？我们可以从 chrome devtools 和浏览器内核的通信过程说起。\n\n实际上，我们使用的 chrome devtools，也就是 chrome 中的浏览器调试工具界面，其实是一个 web 应用。\n\n当我们打开 chrome devtools 的时候，浏览器内核 chromium 本身会作为一个服务端，它会通过 websocket 与 chrome devtools 进行通信，过程如下：\n\n 1. devtools 将作为客户端，与作为服务端的 chromium 建立连接；\n\n 2. devtools 通过 http 获取 html、javascript 和 css 资源，并进行加载；\n\n 3. 资源加载后，devtools 会建立与浏览器的 websocket 连接；\n\n 4. chrome devtools protocol 基于 websocket，它利用 websocket 建立连接 devtools 和浏览器内核的快速数据通道。\n\n也就是说，devtools 和浏览器内核的数据通信，是通过 chrome devtools protocol 来完成。同样的，当我们通过 devtools 从 windows、mac 或 linux 计算机远程调试 android 设备上的实时内容时，使用的也是该协议。\n\n那么，chrome devtools protocol 这个协议它到底提供了什么内容呢？\n\nchrome devtools protocol 具有与浏览器的许多不同部分（例如页面、service worker 和扩展程序）进行交互的 api。该协议把不同的操作划分为了不同的域（domain），每个域负责不同的功能模块，比如dom、debugger、network、console和performance等，可以理解为 devtools 中的不同功能模块。\n\n这里我主要介绍几个和性能相关的域。\n\n * performance域：可获取运行时性能指标，包括页面 dom 节点数量、javascript 栈数量、页面布局耗时等。\n\n * tracing域：可获取页面加载的 devtools 性能跟踪，可以使用tracing.start和tracing.stop创建可在 chrome devtools 或时间轴查看器中打开的跟踪文件。\n\n * runtime域：通过远程评估和镜像对象暴露 javascript 的运行时，可以获取 javascript 栈的使用情况。\n\n * network域：可以分析网络相关的性能。\n\n * 其他涉及 dom 节点、js 执行等相关数据的域。\n\n通过使用 chrome devtools protocol，我们可以获取 devtools 提供的很多数据，包括网络数据、性能数据、运行时数据，比如获取 js 的 runtime 数据，像window.performance、window.chrome.loadtimes()等。\n\n对于如何使用该协议，其实已有针对这个协议封装出不同语言的库，包括 node.js、python、java 等，可以在awesome-chrome-devtools这个项目中找到。\n\n除了直接使用 chrome devtools protocol 之外，我们还可以使用puppeteer的cdpsession，它们封装了 chrome devtools protocol 能力，提供了更加便捷的使用方式，比如：\n\n * 通过session.sendmethod调用 chrome devtools protocol 协议方法；\n\n * 通过session.on方法订阅 chrome devtools protocol 协议事件。\n\n既然我们可以拿到这些性能数据，那么也可以根据业务的需要对这些数据进行自动化的分析，结合前端工程化在项目上线前进行自动化任务的执行、检测、生成对比报告等，实现自动化性能监控。\n\n自动化性能监控\n\n现在我们已经知道，通过 chrome devtools protocol，可以实现在一个模拟的浏览器环境中，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。\n\n上面提到的性能测试过程，属于前端性能监控中的合成监控（synthetic monitoring，syn）方式。合成监控的使用场景不多，一般可能出现在开发和测试的过程中，例如结合流水线跑性能报告、定位性能问题时本地跑的一些简单任务分析等。\n\n该方式的优点显而易见：\n\n * 可采集更丰富的数据指标，例如结合 chrome devtools protocol 获取到的数据；\n\n * 较成熟的解决方案和工具，实现成本低；\n\n * 不影响真实用户的性能体验。\n\n至于如何搭建这样一套自动化分析系统，其实 lighthouse 便是最好的参考例子。前面我们有介绍它的架构和工作原理，同时它也是开源的一个自动化工具，有现成的代码可以作为参考。\n\n由于代码的运行环境是模拟环境，因此很多线上的运行问题难以发现。为了解决这个问题，我们还可以进行真实用户监控（real user monitoring，rum）。\n\n真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标。常见的一些性能监控包括加载耗时、dom 渲染耗时、接口耗时统计等，我们已经在第 19 讲介绍前端监控体系的时候有所介绍。\n\n真实用户监控往往需要结合业务本身的前后端架构设计来建设，其优点也比较容易理解：\n\n * 完全还原真实场景，减去模拟成本；\n\n * 数据样本足够抹平个体的差异；\n\n * 采集数据可用于更多场景的分析和优化。\n\n对比合成监控，真实用户监控在有些场景下无法拿到更多的性能分析数据，例如哪些代码执行中导致了 cpu 占用高、内存占用高。但真实用户监控也有自身的优势，在各种环境下的一些运行耗时问题（例如 tcp、dns 连接耗时过高），使用合成监控是难以发现的。\n\n\n小结\n\n今天我主要介绍了前端性能分析中常用的工具，以及它的底层工作原理，同时还介绍了要如何将前端性能分析进行自动化。\n\n正如前端性能分析存在门槛高、耗时长、频繁发生等问题，我们可以转换思路将其进行自动化处理。同样的，我们会被烦琐的工作内容困扰的时候，也可以尝试如果跳出工作内容本身来进行思考，或许会有更优解。\n\n你在工作中是否也存在可以使用自动化工具解决的问题呢？欢迎在留言区留下你的思考。\n\n----------------------------------------\n\n\n# 精选评论",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"前端性能优化与解决方案",frontmatter:{title:"前端性能优化与解决方案",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/55cc33/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/21.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"01.前端/01.前端开发笔记/21.前端性能优化与解决方案.md",key:"v-6c749aa2",path:"/pages/55cc33/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4706}],headersStr:"精选评论",content:"为什么要进行性能优化呢？因为对于一个产品来说，用户的体验是最重要的。当页面加载时间过长、交互操作不流畅时，会给用户带来很糟糕的体验，最坏的情况下会导致用户的流失，到最后还会出现“代码写得好看又怎样，产品还不是一样难用”的情况。\n\n正因为如此，在各种技术优化的解决方案中，性能优化出现的频率最高、优先级也常常是更高的。\n\n所以，今天我会带大家了解前端常见的性能优化手段。首先我们来看看常见的性能优化方案。\n\n\n常见的性能优化方案\n\n对于前端应用来说，页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等指标会影响用户的等待时长，而 CPU 占用、内存占用、本地缓存占用等可能会导致页面卡顿甚至卡死。因此，性能优化可以分别从常见耗时和资源占用两方面来解决。\n\n时间角度优化：减少耗时\n\n在课程的第一部分，我介绍了在浏览器页面加载过程中，可以分为以下阶段：\n\n 1. 网络请求，服务端返回 HTML 内容；\n\n 2. 浏览器一边解析 HTML，一边进行页面渲染；\n\n 3. 解析到外部资源，会发起 HTTP 请求获取，加载 Javascript 代码时会暂停页面渲染；\n\n 4. 根据业务代码加载过程，会分别进入页面开始渲染、渲染完成、用户可交互等阶段；\n\n 5. 页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。\n    \n    根据这个过程，我们可以从 4 个方面进行耗时优化：网络请求优化、首屏加载优化、渲染过程优化、计算/逻辑运行提速。\n\n我们分别来看看。\n\n1. 网络请求优化。\n\n网络请求优化的目标在于减少网络资源的请求和加载耗时，可以参考以下优化方案：\n\n * 减少 DNS 查询时间，比如使用浏览器 DNS 缓存、计算机 DNS 缓存、服务器 DNS 缓存\n\n * 合理地使用 CDN，有效地减少网络请求耗时；\n\n * 对请求资源进行缓存，包括但不限于使用浏览器缓存、HTTP 缓存、后台缓存，比如使用 Service Worker、PWA 等技术；\n\n * 移除代码中无用的部分，比如使用 Tree-shaking、代码分割、移除用不上的依赖项等；\n\n * 对请求资源进行合理的拆分（CSS、Javascript 脚本、图片/音频/视频等），减少请求资源的体积；\n\n * 对资源进行压缩，减少传输数据大小；\n\n * 使用 HTTP/2、HTTP/3，提升资源请求速度；\n\n * 对请求进行优化，比如对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。\n\n\n\n在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。\n\n2. 首屏加载优化。\n\n顾名思义，首屏加载优化核心点在于：**将页面内容尽快展示给用户，减少页面白屏时间。**因此，首屏加载优化的方案主要包括两方面：首屏加载耗时优化以及使用页面过渡效果。\n\n其中，性能和渲染耗时优化属于技术优化手段，可以通过以下方式进行：\n\n * 对页面进行分片/分屏加载，将页面可见/可交互时间提前；\n\n * 优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源；\n\n * 使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块；\n\n * 使用服务端直出渲染，减少页面二次请求和渲染的耗时；\n\n * 使用秒看技术，通过预览的方式（比如图片）提前将页面内容提供给用户；\n\n * 配合客户端进行资源预请求和预加载，比如使用预热 Web 容器；\n\n * 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。\n\n\n\n相比性能和渲染耗时优化，使用页面过渡效果可能更倾向于产品策略。很多时候产品策略的调整，给用户带来的体验优化效果不低于技术手段优化，因此我们也需要重视。常见的方案包括使用骨架屏进行预渲染，以及使用过渡动画让用户感知到页面正在顺利加载，从而避免用户对于白屏页面或是静止页面产生烦躁和困惑。\n\n除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。\n\n3. 渲染过程优化。\n\n渲染过程的优化，主要在于减少用户的操作等待时间，避免出现卡顿的情况，比如：\n\n * 使用资源预加载，在空闲时间，提前将用户可能需要用到的资源进行获取并加载；\n\n * 减少 DOM 数量、减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时；\n\n * 通过合理使用浏览器 GPU 合成，提升浏览器渲染效率；\n\n * 使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 渲染）；\n\n * 通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。\n\n\n\n除此之外，渲染过程同样可以使用页面过渡动画的方式（比如加载中），给予用户及时的反馈，来提升用户的体验。\n\n对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算/逻辑运行的提速。\n\n4. 计算/逻辑运行提速。\n\n计算/逻辑运行速度优化的方式主要包括：\n\n * 通过将 Javscript 大任务进行拆解 + 并行计算的方式，有效地降低整体计算耗时，比如使用 Web Worker；\n\n * 通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly；\n\n * 通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术；\n\n * 通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算；\n\n * 通过将计算结果缓存的方式，减少运算次数。\n\n\n在前端性能优化实践中，网络请求优化和首屏加载优化方案使用频率最高，因为不管项目规模如何、各个模块和逻辑是否复杂，这两个方向的耗时优化方案都是比较通用的。\n\n相比之下，对于页面内容较多、交互逻辑/运算逻辑复杂的项目，才需要针对性地进行渲染过程优化和计算/逻辑运行提速。\n\n我们继续看看资源占用和卡顿的问题。\n\n空间角度优化：降低资源占用\n\n提到性能优化，大多数我们都在针对页面加载耗时进行优化，对资源占用的优化会更少，因为资源占用常常会直接受到用户设备性能和适应场景的影响，大多数情况下优化效果会比耗时优化局限。\n\n资源占用常见的优化方式包括：\n\n 1. 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理；\n\n 2. 通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用；\n\n 3. 避免存在内存泄漏，比如尽量避免全局变量的使用、及时解除引用等；\n\n 4. 避免复杂/异常的递归调用，导致调用栈的溢出。\n\n\n\n对于页面耗时和资源占用的性能优化分析，可以使用 Chrome 开发者工具进行针对性的分析和优化，这些内容在上一讲已经介绍过了，这里就不再详细讲解。\n\n那么，是不是知道了常见的性能优化方案，就可以直接在项目中使用呢？\n\n\n如何在项目中进行性能优化\n\n性能优化通常需要投入不少的人力和成本来完成，因此更多时候我们可以将其当作是一个项目的方式来进行管理。从项目管理的角度来讲，我们的性能优化工作会拆解为以下部分内容：\n\n 1. 确定优化的目标和预期；\n\n 2. 确定技术方案；\n\n 3. 对工作内容进行排期，并按计划执行；\n\n 4. 优化完成后，结合目标和预期，对优化效果进行复盘。\n\n对于步骤 3、步骤 4，在最后的 27 讲中有详细介绍具体需要怎么做，所以这里我主要围绕优化目标和预期的确定，以及技术方案和工作内容的确认来进行介绍。\n\n确定优化的目标和预期\n\n性能优化的第一步，就是要确定优化的目标和预期。在给出具体的数据之前，我们首先需要对一些性能数据进行定义。比如：\n\n * 网络资源请求时间。\n\n * Time To Start Render(TTSR)：浏览器开始渲染的时间。\n\n * Dom Ready：页面解析完成的时间。\n\n * Time To Interact(TTI))：页面可交互时间。\n\n * Total Blocking Time (TBT)：总阻塞时间，代表页面处于不可交互状态的耗时。\n\n * First Input Delay(FID)：从用户首次交互，到浏览器响应的时间。\n\n\n\n要选择合适有效的指标进行定义，比如由于前端框架的出现，Page Load 耗时（window.onload事件触发的时间）已经难以作为页面可见时间的关键点，因此可以使用框架提供的生命周期，或者是使用 Largest Contentful Paint (LCP，关键内容加载的时间点)更为合适。\n\n对需要关注的性能数据进行定义完成后，可以对它们进行目标和预期的确定，一般来说有两种方式：\n\n 1. 对比原先数据优化一定比例，比如 TTI 耗时减少 30%；\n\n 2. 通过对竞品进行分析确定目标，比如比竞品耗时减少 20%。\n\n在确定了目标和预期之后，我们便可以根据预期来确定优化的方向、技术方案。\n\n确定技术方案\n\n根据确定的目标和预期，我们就可以选择合适的优化方案。为什么不能将上面全部的技术方案都做一遍呢？主要原因有两个：\n\n * 一是性价比，可能部分技术优化需要投入大量的人力，但是优化效果可能不明显，比如切换到 HTTP/2 和 HTTP/3；\n\n * 二是不适用，比如有些业务并不具备差异化服务。\n\n举个例子，小明的预期目标是客户端内打开应用 TTI 耗时减少 30%，因此他可以选择的优化方案包括：\n\n 1. 对首页数据进行分片/分屏加载；\n\n 2. 首屏仅加载需要的资源，通过异步加载方式加载剩余资源；\n\n 3. 使用服务端直出渲染（SSR）；\n\n 4. 使用 Tree-shaking 移除代码中无用的部分；\n\n 5. 配合客户端进行资源预请求和预加载，比如使用预热 Web 容器；\n\n 6. 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。\n\n其中，5、6 需要客户端小伙伴进行支持，那么小明则可以根据对方可以投入人力进行配合，来确定这两个优化点是否在本次方案中。\n\n为了达成目标，对合适的技术优化点进行罗列之后，需要对每个优化点进行简单的调研，确定它们的优化效果。比如针对首页数据进行分屏加载，可以通过简单的模拟测试，对比完整数据的 TTI 耗时，与首屏数据的 TTI 耗时，预估该技术点的优化效果如何。\n\n最后，根据每个优化点的优化效果以及相应的工作量评估，以预期为目标，选择性价比最优的技术方案。\n\n在技术方案确定后，则需要对工作内容进行排期，并按计划执行。优化完成后，还需要结合目标和预期，对优化效果进行复盘，同时还可以提出未来优化的规划（这部分的内容可以参考 27 讲）。\n\n\n小结\n\n今天我介绍了前端开发中常见的性能优化方案，核心优化思想为时间上减少耗时、空间上降低资源占用。其中耗时优化在前端性能优化中更常见，优化方案包括网络请求优化、首屏加载优化、渲染过程优化、计算/逻辑运行提速四个方面。\n\n了解了常见的性能优化方案，我们还需要根据项目自身的情况进行优化实践。在实践过程中，分别需要确定优化的目标和预期、确定技术方案、对工作内容进行排期和执行、优化结束后进行复盘。\n\n最后给你留个作业：对一次性的春节红包活动页面，可以做哪些技术优化来提升用户体验呢？\n\nTip：需要考虑到高并发情况下的柔性降级哦。\n\n把你的想法写在留言区~\n\n----------------------------------------\n\n\n# 精选评论\n\n# **7512：\n\n> 服务端渲染CDN预热，提前将静态资源文件部署到CDN（用阿里CDN的时候见过这个功能）高并发是指抢红包吗？如果是应对用户使劲刷新页面，可以使用强制缓存策略。如果是抢红包接口，可以负载均衡，可以在入口处拦截部分流量柔性降级不懂，是不是出错了要提示活动太火爆了，给个错误页面？前端初学者，请大佬斧正\n\n#     讲师回复：\n\n>     提到了很不错的几个点：合理使用CDN、柔性降级。另外还可以考虑页面的渲染耗时、页面交互体验等，以及是特大并发的情况下，为了避免后台雪崩，前端也可以根据情况做限频处理\n\n# **宇：\n\n> 首先直接先在cdn缓存里预热。一次性的页面技术栈不要太重，尽量不要有太多依赖，不要浪费太多时间在运行时。活动基本上只会在客户端，客户端需要缓存。如果第一次请求就遇到服务器压力太大或者用户自己线路故障，客户端可以采取超时降级策略，转而请求另外一个只保留最小可用功能的页面。还有一个最稳妥但是成本大一些的办法，过节前可以让客户端发一次版，活动页走客户端渲染，能分流一波用户。\n\n#     讲师回复：\n\n>     思路不错，不过一般高并发的瓶颈会主要出现在 CGI 请求接口上，可以针对性地做前端限频、用更加友好的用户提示等等",normalizedContent:"为什么要进行性能优化呢？因为对于一个产品来说，用户的体验是最重要的。当页面加载时间过长、交互操作不流畅时，会给用户带来很糟糕的体验，最坏的情况下会导致用户的流失，到最后还会出现“代码写得好看又怎样，产品还不是一样难用”的情况。\n\n正因为如此，在各种技术优化的解决方案中，性能优化出现的频率最高、优先级也常常是更高的。\n\n所以，今天我会带大家了解前端常见的性能优化手段。首先我们来看看常见的性能优化方案。\n\n\n常见的性能优化方案\n\n对于前端应用来说，页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等指标会影响用户的等待时长，而 cpu 占用、内存占用、本地缓存占用等可能会导致页面卡顿甚至卡死。因此，性能优化可以分别从常见耗时和资源占用两方面来解决。\n\n时间角度优化：减少耗时\n\n在课程的第一部分，我介绍了在浏览器页面加载过程中，可以分为以下阶段：\n\n 1. 网络请求，服务端返回 html 内容；\n\n 2. 浏览器一边解析 html，一边进行页面渲染；\n\n 3. 解析到外部资源，会发起 http 请求获取，加载 javascript 代码时会暂停页面渲染；\n\n 4. 根据业务代码加载过程，会分别进入页面开始渲染、渲染完成、用户可交互等阶段；\n\n 5. 页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。\n    \n    根据这个过程，我们可以从 4 个方面进行耗时优化：网络请求优化、首屏加载优化、渲染过程优化、计算/逻辑运行提速。\n\n我们分别来看看。\n\n1. 网络请求优化。\n\n网络请求优化的目标在于减少网络资源的请求和加载耗时，可以参考以下优化方案：\n\n * 减少 dns 查询时间，比如使用浏览器 dns 缓存、计算机 dns 缓存、服务器 dns 缓存\n\n * 合理地使用 cdn，有效地减少网络请求耗时；\n\n * 对请求资源进行缓存，包括但不限于使用浏览器缓存、http 缓存、后台缓存，比如使用 service worker、pwa 等技术；\n\n * 移除代码中无用的部分，比如使用 tree-shaking、代码分割、移除用不上的依赖项等；\n\n * 对请求资源进行合理的拆分（css、javascript 脚本、图片/音频/视频等），减少请求资源的体积；\n\n * 对资源进行压缩，减少传输数据大小；\n\n * 使用 http/2、http/3，提升资源请求速度；\n\n * 对请求进行优化，比如对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。\n\n\n\n在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。\n\n2. 首屏加载优化。\n\n顾名思义，首屏加载优化核心点在于：**将页面内容尽快展示给用户，减少页面白屏时间。**因此，首屏加载优化的方案主要包括两方面：首屏加载耗时优化以及使用页面过渡效果。\n\n其中，性能和渲染耗时优化属于技术优化手段，可以通过以下方式进行：\n\n * 对页面进行分片/分屏加载，将页面可见/可交互时间提前；\n\n * 优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源；\n\n * 使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块；\n\n * 使用服务端直出渲染，减少页面二次请求和渲染的耗时；\n\n * 使用秒看技术，通过预览的方式（比如图片）提前将页面内容提供给用户；\n\n * 配合客户端进行资源预请求和预加载，比如使用预热 web 容器；\n\n * 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。\n\n\n\n相比性能和渲染耗时优化，使用页面过渡效果可能更倾向于产品策略。很多时候产品策略的调整，给用户带来的体验优化效果不低于技术手段优化，因此我们也需要重视。常见的方案包括使用骨架屏进行预渲染，以及使用过渡动画让用户感知到页面正在顺利加载，从而避免用户对于白屏页面或是静止页面产生烦躁和困惑。\n\n除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。\n\n3. 渲染过程优化。\n\n渲染过程的优化，主要在于减少用户的操作等待时间，避免出现卡顿的情况，比如：\n\n * 使用资源预加载，在空闲时间，提前将用户可能需要用到的资源进行获取并加载；\n\n * 减少 dom 数量、减少/合并 dom 操作，减少浏览器渲染过程中的计算耗时；\n\n * 通过合理使用浏览器 gpu 合成，提升浏览器渲染效率；\n\n * 使用离屏渲染，在页面不可见的地方提前进行渲染（比如 canvas 渲染）；\n\n * 通过将页面渲染帧率保持在 60fps 左右，提升页面交互和渲染的流畅度。\n\n\n\n除此之外，渲染过程同样可以使用页面过渡动画的方式（比如加载中），给予用户及时的反馈，来提升用户的体验。\n\n对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算/逻辑运行的提速。\n\n4. 计算/逻辑运行提速。\n\n计算/逻辑运行速度优化的方式主要包括：\n\n * 通过将 javscript 大任务进行拆解 + 并行计算的方式，有效地降低整体计算耗时，比如使用 web worker；\n\n * 通过使用运行效率更高的方式，减少计算耗时，比如使用 webassembly；\n\n * 通过将计算过程提前，减少计算等待时长，比如使用 aot 技术；\n\n * 通过使用更优的算法或是存储结构，提升计算效率，比如 vscode 使用红黑树优化文本缓冲区的计算；\n\n * 通过将计算结果缓存的方式，减少运算次数。\n\n\n在前端性能优化实践中，网络请求优化和首屏加载优化方案使用频率最高，因为不管项目规模如何、各个模块和逻辑是否复杂，这两个方向的耗时优化方案都是比较通用的。\n\n相比之下，对于页面内容较多、交互逻辑/运算逻辑复杂的项目，才需要针对性地进行渲染过程优化和计算/逻辑运行提速。\n\n我们继续看看资源占用和卡顿的问题。\n\n空间角度优化：降低资源占用\n\n提到性能优化，大多数我们都在针对页面加载耗时进行优化，对资源占用的优化会更少，因为资源占用常常会直接受到用户设备性能和适应场景的影响，大多数情况下优化效果会比耗时优化局限。\n\n资源占用常见的优化方式包括：\n\n 1. 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、indexdb），及时进行缓存清理；\n\n 2. 通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用；\n\n 3. 避免存在内存泄漏，比如尽量避免全局变量的使用、及时解除引用等；\n\n 4. 避免复杂/异常的递归调用，导致调用栈的溢出。\n\n\n\n对于页面耗时和资源占用的性能优化分析，可以使用 chrome 开发者工具进行针对性的分析和优化，这些内容在上一讲已经介绍过了，这里就不再详细讲解。\n\n那么，是不是知道了常见的性能优化方案，就可以直接在项目中使用呢？\n\n\n如何在项目中进行性能优化\n\n性能优化通常需要投入不少的人力和成本来完成，因此更多时候我们可以将其当作是一个项目的方式来进行管理。从项目管理的角度来讲，我们的性能优化工作会拆解为以下部分内容：\n\n 1. 确定优化的目标和预期；\n\n 2. 确定技术方案；\n\n 3. 对工作内容进行排期，并按计划执行；\n\n 4. 优化完成后，结合目标和预期，对优化效果进行复盘。\n\n对于步骤 3、步骤 4，在最后的 27 讲中有详细介绍具体需要怎么做，所以这里我主要围绕优化目标和预期的确定，以及技术方案和工作内容的确认来进行介绍。\n\n确定优化的目标和预期\n\n性能优化的第一步，就是要确定优化的目标和预期。在给出具体的数据之前，我们首先需要对一些性能数据进行定义。比如：\n\n * 网络资源请求时间。\n\n * time to start render(ttsr)：浏览器开始渲染的时间。\n\n * dom ready：页面解析完成的时间。\n\n * time to interact(tti))：页面可交互时间。\n\n * total blocking time (tbt)：总阻塞时间，代表页面处于不可交互状态的耗时。\n\n * first input delay(fid)：从用户首次交互，到浏览器响应的时间。\n\n\n\n要选择合适有效的指标进行定义，比如由于前端框架的出现，page load 耗时（window.onload事件触发的时间）已经难以作为页面可见时间的关键点，因此可以使用框架提供的生命周期，或者是使用 largest contentful paint (lcp，关键内容加载的时间点)更为合适。\n\n对需要关注的性能数据进行定义完成后，可以对它们进行目标和预期的确定，一般来说有两种方式：\n\n 1. 对比原先数据优化一定比例，比如 tti 耗时减少 30%；\n\n 2. 通过对竞品进行分析确定目标，比如比竞品耗时减少 20%。\n\n在确定了目标和预期之后，我们便可以根据预期来确定优化的方向、技术方案。\n\n确定技术方案\n\n根据确定的目标和预期，我们就可以选择合适的优化方案。为什么不能将上面全部的技术方案都做一遍呢？主要原因有两个：\n\n * 一是性价比，可能部分技术优化需要投入大量的人力，但是优化效果可能不明显，比如切换到 http/2 和 http/3；\n\n * 二是不适用，比如有些业务并不具备差异化服务。\n\n举个例子，小明的预期目标是客户端内打开应用 tti 耗时减少 30%，因此他可以选择的优化方案包括：\n\n 1. 对首页数据进行分片/分屏加载；\n\n 2. 首屏仅加载需要的资源，通过异步加载方式加载剩余资源；\n\n 3. 使用服务端直出渲染（ssr）；\n\n 4. 使用 tree-shaking 移除代码中无用的部分；\n\n 5. 配合客户端进行资源预请求和预加载，比如使用预热 web 容器；\n\n 6. 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。\n\n其中，5、6 需要客户端小伙伴进行支持，那么小明则可以根据对方可以投入人力进行配合，来确定这两个优化点是否在本次方案中。\n\n为了达成目标，对合适的技术优化点进行罗列之后，需要对每个优化点进行简单的调研，确定它们的优化效果。比如针对首页数据进行分屏加载，可以通过简单的模拟测试，对比完整数据的 tti 耗时，与首屏数据的 tti 耗时，预估该技术点的优化效果如何。\n\n最后，根据每个优化点的优化效果以及相应的工作量评估，以预期为目标，选择性价比最优的技术方案。\n\n在技术方案确定后，则需要对工作内容进行排期，并按计划执行。优化完成后，还需要结合目标和预期，对优化效果进行复盘，同时还可以提出未来优化的规划（这部分的内容可以参考 27 讲）。\n\n\n小结\n\n今天我介绍了前端开发中常见的性能优化方案，核心优化思想为时间上减少耗时、空间上降低资源占用。其中耗时优化在前端性能优化中更常见，优化方案包括网络请求优化、首屏加载优化、渲染过程优化、计算/逻辑运行提速四个方面。\n\n了解了常见的性能优化方案，我们还需要根据项目自身的情况进行优化实践。在实践过程中，分别需要确定优化的目标和预期、确定技术方案、对工作内容进行排期和执行、优化结束后进行复盘。\n\n最后给你留个作业：对一次性的春节红包活动页面，可以做哪些技术优化来提升用户体验呢？\n\ntip：需要考虑到高并发情况下的柔性降级哦。\n\n把你的想法写在留言区~\n\n----------------------------------------\n\n\n# 精选评论\n\n# **7512：\n\n> 服务端渲染cdn预热，提前将静态资源文件部署到cdn（用阿里cdn的时候见过这个功能）高并发是指抢红包吗？如果是应对用户使劲刷新页面，可以使用强制缓存策略。如果是抢红包接口，可以负载均衡，可以在入口处拦截部分流量柔性降级不懂，是不是出错了要提示活动太火爆了，给个错误页面？前端初学者，请大佬斧正\n\n#     讲师回复：\n\n>     提到了很不错的几个点：合理使用cdn、柔性降级。另外还可以考虑页面的渲染耗时、页面交互体验等，以及是特大并发的情况下，为了避免后台雪崩，前端也可以根据情况做限频处理\n\n# **宇：\n\n> 首先直接先在cdn缓存里预热。一次性的页面技术栈不要太重，尽量不要有太多依赖，不要浪费太多时间在运行时。活动基本上只会在客户端，客户端需要缓存。如果第一次请求就遇到服务器压力太大或者用户自己线路故障，客户端可以采取超时降级策略，转而请求另外一个只保留最小可用功能的页面。还有一个最稳妥但是成本大一些的办法，过节前可以让客户端发一次版，活动页走客户端渲染，能分流一波用户。\n\n#     讲师回复：\n\n>     思路不错，不过一般高并发的瓶颈会主要出现在 cgi 请求接口上，可以针对性地做前端限频、用更加友好的用户提示等等",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何进行技术方案调研与设计",frontmatter:{title:"如何进行技术方案调研与设计",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/ee7a1a/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/22.%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94%E4%B8%8E%E8%AE%BE%E8%AE%A1.html",relativePath:"01.前端/01.前端开发笔记/22.如何进行技术方案调研与设计.md",key:"v-5f0bc376",path:"/pages/ee7a1a/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:3873}],headersStr:"精选评论",content:"工作中对开发的要求都不仅限于实现功能。你是否有想过，如果只是编写代码，刚毕业的应届生花几周时间也一样能做到，那么我们的优势在哪里呢？\n\n洞察工作中的瓶颈，并有足够的能力去设计方案、排期开发、解决并复盘，这些技能更能突显我们在岗位上的价值和能力。对团队来说，更需要这样能主动发现并解决问题的成员，而不是安排什么就只做什么的螺丝钉。\n\n所以，从这一讲开始，我会介绍技术方案设计、项目设计和管理的技能。\n\n其中，技术方案设计属于架构能力中的一种，当我们开始作为某些功能/应用的 Owner 或是技术负责人来参与项目时，便会面临独立完成技术方案的调研和设计这样的工作内容。\n\n我们需要确保技术方案的最优化、避免开发过程遇到问题需要推翻重做，从而能够快速落地并达成预期的效果。因此，在进行方案设计之前，对于项目存在的一些技术瓶颈、技术调整，我们需要先进行充分的前期调研。\n\n\n技术方案调研\n\n在进行技术方案调研的时候，我们需要首先结合自身项目的背景、存在的痛点、现状问题进行分析，只有找到项目的问题在哪里，才可以更准确、彻底地去解决这些问题。\n\n分析项目背景，挖掘项目痛点\n\n技术方案的设计很多时候并不是命题作文，更多时候我们需要自己去挖掘项目的痛点，然后才是提出解决方案。\n\n很多前端开发常常觉得自己做的项目没什么意思，认为每天都是重复的工作、烦琐的业务逻辑、糟糕的历史遗留代码。\n\n实际上，那些会让我们觉得枯燥和重复的工作内容，也是可以去改善做好，并能从中获得成长的地方。\n\n好的业务可遇不可求，如果工作内容跟自己的预期不一样，我们就什么都不做了吗？\n\n我们可以主动寻找项目存在的问题和痛点，并尝试去解决。不同的项目或是同一个项目的不同时期，关注的技术点都会不一样。对于一个前端项目来说，技术价值常常体现在系统性能、稳定性、可维护性、效率提升等地方，比如：\n\n * 对于用户量较大的项目，对系统稳定性要求较高，开发过程中需要关注是否会导致历史功能不兼容、是否会引入新的问题等；\n\n * 对于大型复杂的项目，常常涉及多人协作，因此对系统可维护性要求更高，需要避免每次的改动都会导致性能和稳定性的下降，如何提升协作开发的效率等；\n\n * 对于一次性的活动页面、管理端页面开发，技术挑战通常是如何提高开发效率，可以使用配置化、脚手架、自动化等手段来提升页面的开发和上线效率；\n\n以某个大型项目作为例子，参与前端项目开发的同学有 50 人，项目代码约 60 万行。由于项目太大了，每个同学在开发的时候都难以评估是否会影响到其他模块的运行。\n\n在这种情况下，项目的核心痛点在于如何保证确保每次系统上线都不会对现有性能和稳定性带来问题。\n\n找到项目的痛点之后，我们就可以进入项目的现状分析。\n\n现状分析\n\n或许你会感到疑惑，项目的痛点与现状有什么区别呢？\n\n项目的痛点可以转化为一个目标方向，比如：\n\n * 加载慢 → 首屏加载耗时优化\n\n * 开发效率低 → 提升项目自动化程度\n\n * 多人协作容易出问题 → 提升系统稳定性\n\n确定目标之后，我们就需要进行技术方案的设计，但很多时候由于项目现状存在的问题，一些技术优化的方案并不适用，需要进行方向的调整。\n\n举个例子，在上述项目的例子中，一般情况下我们可以通过一系列的自动化测试与人工测试，来保证大部分核心功能可正常运行。\n\n假设有一个同样规模大、成员多的小程序项目，由于该项目处于快速迭代的时期，考虑到投入产出比、产品形态也在不断调整，老板说“每个功能由开发自己保证”，决定不投入测试资源。\n\n这意味着开发不仅需要在自测的时候确保核心用例的覆盖，同时也没有足够的排期来进行自动化测试（单元测试、集成测试、端到端测试等）的开发。\n\n一般来说，我们还可以考虑建立用例录制和自动化回归的解决方案。比如开发一个浏览器插件，来获取用户操作的一些行为（比如 Redux 中的 Action 操作），将操作行为的页面结果（状态数据，比如 Redux 的 State）保存下来。在发布之前，可以通过自动化触发相同的操作行为，并与录制的页面结果进行比较，来进行回归测试。\n\n但对于小程序的特殊性，我们无法让其运行在浏览器中，更无法获取到它的操作行为。在这样的情况下，还有什么办法可以保证系统的稳定性呢？\n\n考虑到一个系统的上线过程包括开发、测试、灰度和发布四个阶段，如果无法通过测试阶段来及时发现问题，那么我们还可以通过灰度过程中来及时发现并解决问题。\n\n\n\n比如，通过全埋点覆盖各个页面的功能，灰度过程中观察埋点曲线是否有异常、及时告警和排查问题、暂停灰度或者回滚等方式，来避免给更多的用户带来不好的体验。\n\n通过灰度的方式来保证系统稳定性，会对局部的用户造成影响，这并不是一个最优的技术方案，它是考虑到项目的现状退而求其次的解决方案，但最终也同样可以达到提升系统稳定性这样一个目的。\n\n当我们确定了技术优化的具体方向之后，便可以进行业界方案的调研阶段了。\n\n\n业界方案调研\n\n当我们遇到一些技术问题并尝试解决的时候，需要提醒自己，这些问题肯定有其他人也遇到过。为了避免技术方案的设计过于局限，我们可以进行前期的调研，找一些业界相对成熟的方案作为参考，分析这些方案的优缺点、是否适用于自己的项目中。\n\n我们可以通过几种方式去进行业界方案的调研：\n\n 1. 与有相关经验的开发进行沟通，交流技术方案，提供参考思路；\n\n 2. 参考其他系统对外公开的方案设计；\n\n 3. 参考开源项目的源码设计。\n\n举个例子，对于交互复杂、规模大型的应用，要如何管理各个模块间的依赖关系呢？业界相对成熟的解决方案是使用依赖注入体系，其中著名的开源项目中有 Angular 和 VSCode 都实现了依赖注入的框架，我们可以通过研究它们的相关代码，分析其中的思路以及实现方式。\n\n开源项目源码很多，要怎么才能找到自己想看的部分呢？带着疑问有目的性地看，会简单轻松得多。比如上述的依赖注入框架，我们可以带着以下的问题进行研究：\n\n 1. 依赖注入框架是什么？\n\n 2. 模块是怎样初始化，什么时候进行销毁的？\n\n 3. 模块是如何获取到其他模块呢？\n\n 4. 模块间是如何进行通信的呢？\n\n通过这样的方式阅读源码，我们可以快速掌握自己需要的一些信息。在业界方案调研完成之后，我们需要结合自身项目进行具体的技术方案设计。\n\n\n技术方案设计\n\n技术方案设计过程中，我们需要根据上述的调研资料进行整理，包括项目痛点、现状、业界方案等，然后进行方案的选型和对比，最终给到适合项目的解决方案。\n\n方案选型/对比\n\n业界的解决方案可能有多套，这时候我们需要对这些方案进行分析比较。\n\n除此之外，如果需要投入人力和时间成本去做一件事，我们就会面临一个问题：如何让团队认同这件事情、并愿意给到资源让我去完成它呢？梳理项目现状和痛点、提供业界认可的案例参考、进行全面的方案对比和选型，也是一种方式。\n\n例如，小明最近需要针对项目进行自动化性能测试能力的支持。\n\n * 项目现状：项目规模大、模块多、参与开发的成员也有几十人。\n\n * 项目痛点：经常因为一些不同模块的变更导致项目的性能下降却没法及时发现问题，往往是等到用户反馈或是某次开发、产品或者测试发现的时候才得知。\n\n小明调研常见的一些性能分析方案，发现有几种方式：\n\n 1. 通过 Chrome Devtools 提供的 Performace 火焰图，来定位和发现问题，但这种方式局限于开发手动分析定位；\n\n 2. 使用 Lighthouse，该工具可以提供初步的网页优化建议，也支持自动化，但 Lighthouse 本身更专注于短时间内对网站进行较全面的评估，存在像分析不够细致和深入这些问题；\n\n 3. 使用 Chrome Devtools 提供的 Chrome Devtools Protocol（CDP）能力，进行自动化生成火焰图需要的 JSON。但业界对该 JSON 的分析工具几乎没有，大家都通过将该 JSON 传到 Chrome Devtools 提供的一个工具来还原火焰图，无法支持全程的自动化分析。\n\n通过仔细的对比和分析，小明认为第一和第二种方案都无法从根本上解决遇到的问题，于是决定采取第三种方案，并打算通过自行研究分析 CDP（Chrome Devtools Protocol）生成的 JSON 来达到完全的自动化目的。\n\n确定了方案之后，小明拿着前期的调研结果（包括业界成熟方案、方案的对比和选择、初步 DEMO 效果）去找老板。老板看着这么完整的调研资料，二话不说就批准了小明继续研究这个方案并落到项目中使用，同时也觉得小明做事特别靠谱。\n\n方案选型和对比是技术方案设计中重要的一个环节，可以将现状和痛点分析得更加全面，同时还可以避开一些其他人踩过的坑。\n\n\n小结\n\n今天我带大家学习了怎么进行技术方案的设计：\n\n 1. 对项目的痛点、现状进行分析；\n\n 2. 调研业界成熟的技术方案；\n\n 3. 结合项目本身的现状和痛点，进行技术方案的选型和对比。\n\n技术的发展都离不开知识的沉淀、分享和相互学习，当我们遇到一些问题不知道该怎么解决的时候，可以试着站到巨人的肩膀上，说不定可以看到更多。\n\n在你负责或者参与的项目中，存在哪些痛点呢？又可以通过怎样的方式去解决呢？欢迎在留言区进行讨论~\n\n----------------------------------------\n\n\n# 精选评论",normalizedContent:"工作中对开发的要求都不仅限于实现功能。你是否有想过，如果只是编写代码，刚毕业的应届生花几周时间也一样能做到，那么我们的优势在哪里呢？\n\n洞察工作中的瓶颈，并有足够的能力去设计方案、排期开发、解决并复盘，这些技能更能突显我们在岗位上的价值和能力。对团队来说，更需要这样能主动发现并解决问题的成员，而不是安排什么就只做什么的螺丝钉。\n\n所以，从这一讲开始，我会介绍技术方案设计、项目设计和管理的技能。\n\n其中，技术方案设计属于架构能力中的一种，当我们开始作为某些功能/应用的 owner 或是技术负责人来参与项目时，便会面临独立完成技术方案的调研和设计这样的工作内容。\n\n我们需要确保技术方案的最优化、避免开发过程遇到问题需要推翻重做，从而能够快速落地并达成预期的效果。因此，在进行方案设计之前，对于项目存在的一些技术瓶颈、技术调整，我们需要先进行充分的前期调研。\n\n\n技术方案调研\n\n在进行技术方案调研的时候，我们需要首先结合自身项目的背景、存在的痛点、现状问题进行分析，只有找到项目的问题在哪里，才可以更准确、彻底地去解决这些问题。\n\n分析项目背景，挖掘项目痛点\n\n技术方案的设计很多时候并不是命题作文，更多时候我们需要自己去挖掘项目的痛点，然后才是提出解决方案。\n\n很多前端开发常常觉得自己做的项目没什么意思，认为每天都是重复的工作、烦琐的业务逻辑、糟糕的历史遗留代码。\n\n实际上，那些会让我们觉得枯燥和重复的工作内容，也是可以去改善做好，并能从中获得成长的地方。\n\n好的业务可遇不可求，如果工作内容跟自己的预期不一样，我们就什么都不做了吗？\n\n我们可以主动寻找项目存在的问题和痛点，并尝试去解决。不同的项目或是同一个项目的不同时期，关注的技术点都会不一样。对于一个前端项目来说，技术价值常常体现在系统性能、稳定性、可维护性、效率提升等地方，比如：\n\n * 对于用户量较大的项目，对系统稳定性要求较高，开发过程中需要关注是否会导致历史功能不兼容、是否会引入新的问题等；\n\n * 对于大型复杂的项目，常常涉及多人协作，因此对系统可维护性要求更高，需要避免每次的改动都会导致性能和稳定性的下降，如何提升协作开发的效率等；\n\n * 对于一次性的活动页面、管理端页面开发，技术挑战通常是如何提高开发效率，可以使用配置化、脚手架、自动化等手段来提升页面的开发和上线效率；\n\n以某个大型项目作为例子，参与前端项目开发的同学有 50 人，项目代码约 60 万行。由于项目太大了，每个同学在开发的时候都难以评估是否会影响到其他模块的运行。\n\n在这种情况下，项目的核心痛点在于如何保证确保每次系统上线都不会对现有性能和稳定性带来问题。\n\n找到项目的痛点之后，我们就可以进入项目的现状分析。\n\n现状分析\n\n或许你会感到疑惑，项目的痛点与现状有什么区别呢？\n\n项目的痛点可以转化为一个目标方向，比如：\n\n * 加载慢 → 首屏加载耗时优化\n\n * 开发效率低 → 提升项目自动化程度\n\n * 多人协作容易出问题 → 提升系统稳定性\n\n确定目标之后，我们就需要进行技术方案的设计，但很多时候由于项目现状存在的问题，一些技术优化的方案并不适用，需要进行方向的调整。\n\n举个例子，在上述项目的例子中，一般情况下我们可以通过一系列的自动化测试与人工测试，来保证大部分核心功能可正常运行。\n\n假设有一个同样规模大、成员多的小程序项目，由于该项目处于快速迭代的时期，考虑到投入产出比、产品形态也在不断调整，老板说“每个功能由开发自己保证”，决定不投入测试资源。\n\n这意味着开发不仅需要在自测的时候确保核心用例的覆盖，同时也没有足够的排期来进行自动化测试（单元测试、集成测试、端到端测试等）的开发。\n\n一般来说，我们还可以考虑建立用例录制和自动化回归的解决方案。比如开发一个浏览器插件，来获取用户操作的一些行为（比如 redux 中的 action 操作），将操作行为的页面结果（状态数据，比如 redux 的 state）保存下来。在发布之前，可以通过自动化触发相同的操作行为，并与录制的页面结果进行比较，来进行回归测试。\n\n但对于小程序的特殊性，我们无法让其运行在浏览器中，更无法获取到它的操作行为。在这样的情况下，还有什么办法可以保证系统的稳定性呢？\n\n考虑到一个系统的上线过程包括开发、测试、灰度和发布四个阶段，如果无法通过测试阶段来及时发现问题，那么我们还可以通过灰度过程中来及时发现并解决问题。\n\n\n\n比如，通过全埋点覆盖各个页面的功能，灰度过程中观察埋点曲线是否有异常、及时告警和排查问题、暂停灰度或者回滚等方式，来避免给更多的用户带来不好的体验。\n\n通过灰度的方式来保证系统稳定性，会对局部的用户造成影响，这并不是一个最优的技术方案，它是考虑到项目的现状退而求其次的解决方案，但最终也同样可以达到提升系统稳定性这样一个目的。\n\n当我们确定了技术优化的具体方向之后，便可以进行业界方案的调研阶段了。\n\n\n业界方案调研\n\n当我们遇到一些技术问题并尝试解决的时候，需要提醒自己，这些问题肯定有其他人也遇到过。为了避免技术方案的设计过于局限，我们可以进行前期的调研，找一些业界相对成熟的方案作为参考，分析这些方案的优缺点、是否适用于自己的项目中。\n\n我们可以通过几种方式去进行业界方案的调研：\n\n 1. 与有相关经验的开发进行沟通，交流技术方案，提供参考思路；\n\n 2. 参考其他系统对外公开的方案设计；\n\n 3. 参考开源项目的源码设计。\n\n举个例子，对于交互复杂、规模大型的应用，要如何管理各个模块间的依赖关系呢？业界相对成熟的解决方案是使用依赖注入体系，其中著名的开源项目中有 angular 和 vscode 都实现了依赖注入的框架，我们可以通过研究它们的相关代码，分析其中的思路以及实现方式。\n\n开源项目源码很多，要怎么才能找到自己想看的部分呢？带着疑问有目的性地看，会简单轻松得多。比如上述的依赖注入框架，我们可以带着以下的问题进行研究：\n\n 1. 依赖注入框架是什么？\n\n 2. 模块是怎样初始化，什么时候进行销毁的？\n\n 3. 模块是如何获取到其他模块呢？\n\n 4. 模块间是如何进行通信的呢？\n\n通过这样的方式阅读源码，我们可以快速掌握自己需要的一些信息。在业界方案调研完成之后，我们需要结合自身项目进行具体的技术方案设计。\n\n\n技术方案设计\n\n技术方案设计过程中，我们需要根据上述的调研资料进行整理，包括项目痛点、现状、业界方案等，然后进行方案的选型和对比，最终给到适合项目的解决方案。\n\n方案选型/对比\n\n业界的解决方案可能有多套，这时候我们需要对这些方案进行分析比较。\n\n除此之外，如果需要投入人力和时间成本去做一件事，我们就会面临一个问题：如何让团队认同这件事情、并愿意给到资源让我去完成它呢？梳理项目现状和痛点、提供业界认可的案例参考、进行全面的方案对比和选型，也是一种方式。\n\n例如，小明最近需要针对项目进行自动化性能测试能力的支持。\n\n * 项目现状：项目规模大、模块多、参与开发的成员也有几十人。\n\n * 项目痛点：经常因为一些不同模块的变更导致项目的性能下降却没法及时发现问题，往往是等到用户反馈或是某次开发、产品或者测试发现的时候才得知。\n\n小明调研常见的一些性能分析方案，发现有几种方式：\n\n 1. 通过 chrome devtools 提供的 performace 火焰图，来定位和发现问题，但这种方式局限于开发手动分析定位；\n\n 2. 使用 lighthouse，该工具可以提供初步的网页优化建议，也支持自动化，但 lighthouse 本身更专注于短时间内对网站进行较全面的评估，存在像分析不够细致和深入这些问题；\n\n 3. 使用 chrome devtools 提供的 chrome devtools protocol（cdp）能力，进行自动化生成火焰图需要的 json。但业界对该 json 的分析工具几乎没有，大家都通过将该 json 传到 chrome devtools 提供的一个工具来还原火焰图，无法支持全程的自动化分析。\n\n通过仔细的对比和分析，小明认为第一和第二种方案都无法从根本上解决遇到的问题，于是决定采取第三种方案，并打算通过自行研究分析 cdp（chrome devtools protocol）生成的 json 来达到完全的自动化目的。\n\n确定了方案之后，小明拿着前期的调研结果（包括业界成熟方案、方案的对比和选择、初步 demo 效果）去找老板。老板看着这么完整的调研资料，二话不说就批准了小明继续研究这个方案并落到项目中使用，同时也觉得小明做事特别靠谱。\n\n方案选型和对比是技术方案设计中重要的一个环节，可以将现状和痛点分析得更加全面，同时还可以避开一些其他人踩过的坑。\n\n\n小结\n\n今天我带大家学习了怎么进行技术方案的设计：\n\n 1. 对项目的痛点、现状进行分析；\n\n 2. 调研业界成熟的技术方案；\n\n 3. 结合项目本身的现状和痛点，进行技术方案的选型和对比。\n\n技术的发展都离不开知识的沉淀、分享和相互学习，当我们遇到一些问题不知道该怎么解决的时候，可以试着站到巨人的肩膀上，说不定可以看到更多。\n\n在你负责或者参与的项目中，存在哪些痛点呢？又可以通过怎样的方式去解决呢？欢迎在留言区进行讨论~\n\n----------------------------------------\n\n\n# 精选评论",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何设计一个前端项目",frontmatter:{title:"如何设计一个前端项目",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/b1d475/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/23.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html",relativePath:"01.前端/01.前端开发笔记/23.如何设计一个前端项目.md",key:"v-68ab505c",path:"/pages/b1d475/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4647}],headersStr:"精选评论",content:"如果说基础知识的掌握是起跑线，那么让大家之间拉开差距的更多是前端项目开发经验和技能。对于一个项目来说，从框架选型和搭建，到项目维护、工程化和自动化、多人协作等各个方面，都需要我们在参与项目中不断地思考和改进，积累经验。\n\n项目是会不断进行演化的，如果没有做好技术方案的设计和选型，后期很可能需要进行较大规模的重构，或是留下难缠的技术债务；如果没有约束好开发规范，则容易导致团队协作出现分歧、开发效率的下降。\n\n因此我们在设计一个项目的时候，需要重点关注：\n\n 1. 技术方案的设计和选型。\n\n 2. 多人协作和团队规范的制订。\n\n我们先来看看第一个。\n\n\n技术方案设计和选型\n\n从 0 开始搭建一个项目，常常需要考虑以下的技术选型：\n\n 1. 前端框架和脚手架。\n\n 2. 状态管理工具。\n\n 3. 路由管理工具。\n\n 4. 代码构建和编译工具。\n\n关于以上技术相关的方案，我已经在第 12、13、17、18 这几讲内容中有详细进行介绍。除此之外，如何对进行技术方案的设计和调研，我们也在上一讲中进行了介绍。\n\n在项目开始之前，我们需基于项目的定位（To B 还是 To C）、用户量体系、项目复杂度等因素，进行技术方案的设计。\n\n技术选型的影响因素\n\n一般来说，从头开始搭建前端项目，首先要思考几个问题。\n\n 1. 项目规模如何、功能交互是否复杂、面向哪些用户？\n\n 2. 是否存在多人协作？团队规模大概是怎样的？\n\n 3. 团队成员技术栈如何？对新技术的接受程度怎样？\n\n 4. 是否有现有的技术方案可以参考？是否需要进行调整？\n\n为什么要考虑这些问题呢？\n\n * 项目规模和功能交互会影响框架和工具的选型，比如轻量项目可能 React/Vue 框架比较灵活，大型项目还可以使用 Angular 全家桶。\n\n * 用户体系会影响系统兼容性的倾向，比如用户受众年龄偏大，则需要考虑使用机型性能可能相对较差、需兼容的机型品牌比较多。\n\n * 存在多人协作需要考虑完善团队规范，同时尽量使用工具来保证流程规范。\n\n * 团队技术栈倾向同样影响技术选型，如果有现成的技术方案和项目案例，可以考虑是否符合实际需要，使用团队成员熟练的工具可以避免很多踩坑的过程。\n\n在明确了这些问题的答案之后，我们需要进行框架和工具的选型。\n\n前端框架和工具选型\n\n对于前端框架和工具的使用，项目面临两个选择：\n\n 1. 使用开源/现有框架；\n\n 2. 造轮子。\n\n使用开源框架的好处是，它们有着完整详细的文档、丰富的社区资源。在遇到问题的时候，也能通过 issues 和 Stack Overflow 来查找。\n\n前端发展到现在，几大框架之间的差距越来越小，好的方案相互学习、不好的地方各自调整。其中，目前主流的三大框架包括 Angular、React 和 Vue，我们在第 18 讲有详细介绍过各自的特色，可以进行选型和对比：\n\n框架        优势                                             不足\nAngular   提供完整的开发规范和解决方案，解决了多人协作、大型应用的痛点                 基于大型复杂项目设计，解决方案大而全导致相对笨重\n                                                         设计和使用的概念很多（如依赖注入/注入器/令牌、指令、模块化、AOT 等），入门成本较大\nReact     概念较少，对前端编码侵入较少，开发者只需要掌握 Javascript 便可实现大多数功能   对于大型复杂项目，需要自行搭配其他配套工具来解决\n          框架（库）轻量，可灵活搭配各种状态管理工具、脚手架等进行开发\nVue       对新人友好、文档和社区较完善                                 如指令和语法糖有一定的概念门槛\n          框架（库）轻量，可灵活搭配各种工具进行开发，官方也提供完整的全家桶解决方案          对于大型复杂项目，需要自行搭配其他配套工具来解决\n\n除了三大热门框架以外，有能力的团队，也可以选择比较贴合自身项目需要、相对小众的框架和工具，甚至可以自行研发合适自己的。\n\n如果想要自己做框架，尤其是想要在业务中尝试使用，需要万分谨慎。除了要贴合业务实际需要，更要具备足够的责任感。比如需要提供友好的文档和 API 给其他人，不然对项目的维护、新加入的成员来说，会带来毁灭性的开发体验。\n\n技术选型其实并没有一个标准的答案，很多时候我们还需要结合项目现状，选择适合团队使用的技术栈。\n\n选择适合团队的技术栈\n\n很多时候，我们选择使用某个工具和框架，需要考虑项目大小、定位之外，还需要考虑团队的情况，包括：\n\n * 团队现有的技术栈\n\n * 团队成员对框架/工具的熟悉程度\n\n * 团队成员是否有倾向的框架/工具\n\n举个例子，小明接到一个好几百个功能页面的管理端项目，老板给了十个人力说让一个月上线。\n\n小明调研了一番，觉得 Angular 框架可以直接拿来开发 DEMO 模块，大家可以通过参考 DEMO 快速实现其他功能页面，而且代码规范、状态管理、脚手架等都特别完善，省去了搭建成本。\n\n“毫无疑问这是最合适的方式。”小明心想。\n\n当他跟团队成员讨论使用 Angular 的时候，大家面面相觑。十个人里只有一个人写过一点点 Angular 代码。基本上大家对 Angular 零认知，入门和熟悉起码也得一周了，这样一个月肯定无法完成任务，小明整个人都傻了。\n\n后来，小明找大家讨论了一番，大家认为管理端页面用 Vue 比较方便，尤其表单类可以直接用双向绑定。考虑到大家基本上对 Vue 也比较熟练，也有 ElementUI 这样可以直接用的组件库，于是小明决定直接一套 Vue CLI + Vue + vue-router + vuex + ElementUI 带走。\n\n由于大家对 Vue 已经很熟练了，脚手架初始化完项目之后，约定了下目录结构，大家就能直接开始进入开发状态了。跑了一段时间后，小明发现虽然有三百多个页面，但管理端这样的系统各个页面间的关联性较少，vuex 也基本上能满足开发需要。\n\n“看来还是得结合团队的技术栈进行技术选型呢。”小明感叹道。\n\n使用一套团队成员比较熟悉的技术栈，可以减少开发过程中遇到的一些问题，同时也能提升大家的开发效率。对于新引入的技术工具，可以通过讨论和投票的方式，一致通过或者协商后的方案，才是最适合的方案。\n\n选用框架、脚手架和一些工具库，我们可以快速搭建项目并进行开发。当我们的项目不断变大，代码量也会随之增加。对于很多代码的生成、校验、编译、测试等流程，也需要根据项目需要进行完善，会涉及代码构建、自动化和工程化的内容，这些内容在 15 讲和 25 讲有进行详细的介绍。\n\n以上便是项目启动时，技术方案设计和选型需要考虑的一些问题。\n\n除此之外，当项目涉及多人协作、工作交接的时候，多人协作和团队规范同样重要。\n\n\n多人协作和团队规范\n\n相比项目的搭建和快速上线，项目的维护永远是程序员的大头。搭建一套代码和流程规范，不只是将规范写得淋漓尽致，更是需要使用流程化的工具来确保大家要遵守规范。\n\n使用一致的代码开发规范\n\n好的编码习惯很重要，语义化的变量命名、适当的注释等，都会对代码的可读性有很大的提升。但是每个人的习惯都不一样，所以我们需要有统一的代码规范。\n\n可以使用一些工具来确保代码符合规范：\n\n * 使用 Eslint 检测代码规范；\n\n * 使用 Prettier 自动化格式代码；\n\n * 使用 Git Commit Hooks 拒绝不符合规范的代码提交；\n\n * 使用流水线检测出不规范的代码，并拒绝合入主干分支；\n\n * 使用流水线检测出不规范的代码，并拒绝进入发布流程。\n\n通过各种流程上的工具校验，确保大家都遵循规范进行开发，才能让规范的价值发挥出来。\n\n使用 Eslint 这些工具能够帮助发现代码错误的规则，但代码的可读性和可维护性远远不止这些编码规则。\n\n很多时候，我们会使用一些设计模式来进行代码设计，也会对代码进行适度的抽象，比如封装成组件和公共库。每个人对代码该如何设计、要怎么抽象和封装、公共代码应该在哪维护等都有不同的理解，这些内容无法使用工具或者规则来强行约定。\n\n在这样的情况下，我们需要在每次合入代码的时候进行 Code Review，大家可以针对提交的代码进行讨论，提出修改的建议。在遇到分歧的时候，可以通过投票等方式来达成一致。\n\n除了编码相关的规范，开发过程中的流程规范也一样重要，比如对合入的代码进行 Code Review，对发布的代码进行自动化回归测试等。\n\n制定合适的代码流程规范\n\n一般来说，开发流程会包括：\n\n * Git 创建分支过程：分支的命名，是否需要关联需求单或是 BUG 单。\n\n * Git 提交代码过程：检查代码是否符合规范，只允许合格的代码（Eslint 规范、单测覆盖率等）进行提交。\n\n * 分支提交过程：需要进行交叉 Code Review，对方同意后才允许合入代码。\n\n * 合入主干过程：对代码进行自动化构建和测试，功能正常且符合规范的代码才可合入主干。\n\n * 代码发布过程：自动拉取主干分支，创建发布分支，对代码进行自动化构建和测试，正常后会开始进入灰度发布流程。\n\n通过自动化的工具我们同样可以确保以上流程按预期进行，很多团队也会使用持续集成（continuous integration，简称 CI）和持续部署（continuous deployment，简称 CD）。CI/CD 在项目中的落地，很多时候会表现为流水线的开发模式。\n\n建立完整的 CI/CD 流水线，除了可以按照规范约束每次代码提交的质量，还可以有效地提高效率。越是大规模的团队，越能体会到 CI/CD 带来的便利，这些内容我们会在第 25 讲中进行更详细的介绍。\n\n一个团队的正常运作，必然需要经过很多的协作方式磨合、合作过程争执、达成一致规范的过程。如果可以通过流程和工具来确保合作方式按约定进行，就不要作为可选项提供给团队成员靠自觉来执行，这样才可以维护稳定友好的团队运作模式。\n\n\n小结\n\n今天给大家介绍在前端项目设计时、维护过程中需要考虑的一些问题。\n\n 1. 项目开始前需要进行技术方案设计，选择适合团队和业务的技术栈进行开发。\n\n 2. 对于多人协作项目，团队需要达成一致的开发和流程规范，同时需要使用工具和流程来保证规范的约束力。\n\n在实际工作中，我们会遇到很多“糟糕”的代码，刚开始会尝试去进行优化，到后面大家都慢慢屈服。“又不是不能用”这样的想法让人生厌，而过于理想的设计往往又难以落地。\n\n代码本身就是会不断演化，也需要不断进行优化，一蹴而就、动不动就推倒重来的想法往往让人望而生畏，我们可以尝试拆成多步，一步一步脚踏实地地往前走。\n\n一个难以维护、却依然不断有新需求开发的项目，你会选择重新设计呢，还是会尝试一步步进行优化呢？欢迎在留言区分享你的想法。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **雨：\n\n> 时间和成本允许，重新设计和重写。反之慢慢重构，一步一步优化\n\n# **宇：\n\n> 只能说不要随便重构，可能你重构出来的后期在别人眼里也是垃圾。如果项目过于臃肿，可以用微服务这样的渐进式方法，分离一些业务出去\n\n#     讲师回复：\n\n>     是的，从业务稳定性来说，渐进式优化会比直接重构效果要好得多，直接选择重构有时候可能带来更多的历史债务\n\n# **童：\n\n> 我认为只要一个项目还在不断迭代更新，就肯定有可优化的余地。一般都会选择边写新需求边逐步优化，可能是现在新增的组件或者逻辑可以复用，也可能是某些旧代码有更优的编写思路。不过要认真看优化的地方所涉及的范围，不要出现漏改的情况，否则可能出现“一个现有的功能一直好好的，突然就不行了”的尴尬情况。。\n\n# *振：\n\n> 我的确遇到了这种项目，很庞大，重新设计会很困难，要花费相当长的时间，反正能用，只好一步步来了。。。可能后期能排上期，会重构一番",normalizedContent:"如果说基础知识的掌握是起跑线，那么让大家之间拉开差距的更多是前端项目开发经验和技能。对于一个项目来说，从框架选型和搭建，到项目维护、工程化和自动化、多人协作等各个方面，都需要我们在参与项目中不断地思考和改进，积累经验。\n\n项目是会不断进行演化的，如果没有做好技术方案的设计和选型，后期很可能需要进行较大规模的重构，或是留下难缠的技术债务；如果没有约束好开发规范，则容易导致团队协作出现分歧、开发效率的下降。\n\n因此我们在设计一个项目的时候，需要重点关注：\n\n 1. 技术方案的设计和选型。\n\n 2. 多人协作和团队规范的制订。\n\n我们先来看看第一个。\n\n\n技术方案设计和选型\n\n从 0 开始搭建一个项目，常常需要考虑以下的技术选型：\n\n 1. 前端框架和脚手架。\n\n 2. 状态管理工具。\n\n 3. 路由管理工具。\n\n 4. 代码构建和编译工具。\n\n关于以上技术相关的方案，我已经在第 12、13、17、18 这几讲内容中有详细进行介绍。除此之外，如何对进行技术方案的设计和调研，我们也在上一讲中进行了介绍。\n\n在项目开始之前，我们需基于项目的定位（to b 还是 to c）、用户量体系、项目复杂度等因素，进行技术方案的设计。\n\n技术选型的影响因素\n\n一般来说，从头开始搭建前端项目，首先要思考几个问题。\n\n 1. 项目规模如何、功能交互是否复杂、面向哪些用户？\n\n 2. 是否存在多人协作？团队规模大概是怎样的？\n\n 3. 团队成员技术栈如何？对新技术的接受程度怎样？\n\n 4. 是否有现有的技术方案可以参考？是否需要进行调整？\n\n为什么要考虑这些问题呢？\n\n * 项目规模和功能交互会影响框架和工具的选型，比如轻量项目可能 react/vue 框架比较灵活，大型项目还可以使用 angular 全家桶。\n\n * 用户体系会影响系统兼容性的倾向，比如用户受众年龄偏大，则需要考虑使用机型性能可能相对较差、需兼容的机型品牌比较多。\n\n * 存在多人协作需要考虑完善团队规范，同时尽量使用工具来保证流程规范。\n\n * 团队技术栈倾向同样影响技术选型，如果有现成的技术方案和项目案例，可以考虑是否符合实际需要，使用团队成员熟练的工具可以避免很多踩坑的过程。\n\n在明确了这些问题的答案之后，我们需要进行框架和工具的选型。\n\n前端框架和工具选型\n\n对于前端框架和工具的使用，项目面临两个选择：\n\n 1. 使用开源/现有框架；\n\n 2. 造轮子。\n\n使用开源框架的好处是，它们有着完整详细的文档、丰富的社区资源。在遇到问题的时候，也能通过 issues 和 stack overflow 来查找。\n\n前端发展到现在，几大框架之间的差距越来越小，好的方案相互学习、不好的地方各自调整。其中，目前主流的三大框架包括 angular、react 和 vue，我们在第 18 讲有详细介绍过各自的特色，可以进行选型和对比：\n\n框架        优势                                             不足\nangular   提供完整的开发规范和解决方案，解决了多人协作、大型应用的痛点                 基于大型复杂项目设计，解决方案大而全导致相对笨重\n                                                         设计和使用的概念很多（如依赖注入/注入器/令牌、指令、模块化、aot 等），入门成本较大\nreact     概念较少，对前端编码侵入较少，开发者只需要掌握 javascript 便可实现大多数功能   对于大型复杂项目，需要自行搭配其他配套工具来解决\n          框架（库）轻量，可灵活搭配各种状态管理工具、脚手架等进行开发\nvue       对新人友好、文档和社区较完善                                 如指令和语法糖有一定的概念门槛\n          框架（库）轻量，可灵活搭配各种工具进行开发，官方也提供完整的全家桶解决方案          对于大型复杂项目，需要自行搭配其他配套工具来解决\n\n除了三大热门框架以外，有能力的团队，也可以选择比较贴合自身项目需要、相对小众的框架和工具，甚至可以自行研发合适自己的。\n\n如果想要自己做框架，尤其是想要在业务中尝试使用，需要万分谨慎。除了要贴合业务实际需要，更要具备足够的责任感。比如需要提供友好的文档和 api 给其他人，不然对项目的维护、新加入的成员来说，会带来毁灭性的开发体验。\n\n技术选型其实并没有一个标准的答案，很多时候我们还需要结合项目现状，选择适合团队使用的技术栈。\n\n选择适合团队的技术栈\n\n很多时候，我们选择使用某个工具和框架，需要考虑项目大小、定位之外，还需要考虑团队的情况，包括：\n\n * 团队现有的技术栈\n\n * 团队成员对框架/工具的熟悉程度\n\n * 团队成员是否有倾向的框架/工具\n\n举个例子，小明接到一个好几百个功能页面的管理端项目，老板给了十个人力说让一个月上线。\n\n小明调研了一番，觉得 angular 框架可以直接拿来开发 demo 模块，大家可以通过参考 demo 快速实现其他功能页面，而且代码规范、状态管理、脚手架等都特别完善，省去了搭建成本。\n\n“毫无疑问这是最合适的方式。”小明心想。\n\n当他跟团队成员讨论使用 angular 的时候，大家面面相觑。十个人里只有一个人写过一点点 angular 代码。基本上大家对 angular 零认知，入门和熟悉起码也得一周了，这样一个月肯定无法完成任务，小明整个人都傻了。\n\n后来，小明找大家讨论了一番，大家认为管理端页面用 vue 比较方便，尤其表单类可以直接用双向绑定。考虑到大家基本上对 vue 也比较熟练，也有 elementui 这样可以直接用的组件库，于是小明决定直接一套 vue cli + vue + vue-router + vuex + elementui 带走。\n\n由于大家对 vue 已经很熟练了，脚手架初始化完项目之后，约定了下目录结构，大家就能直接开始进入开发状态了。跑了一段时间后，小明发现虽然有三百多个页面，但管理端这样的系统各个页面间的关联性较少，vuex 也基本上能满足开发需要。\n\n“看来还是得结合团队的技术栈进行技术选型呢。”小明感叹道。\n\n使用一套团队成员比较熟悉的技术栈，可以减少开发过程中遇到的一些问题，同时也能提升大家的开发效率。对于新引入的技术工具，可以通过讨论和投票的方式，一致通过或者协商后的方案，才是最适合的方案。\n\n选用框架、脚手架和一些工具库，我们可以快速搭建项目并进行开发。当我们的项目不断变大，代码量也会随之增加。对于很多代码的生成、校验、编译、测试等流程，也需要根据项目需要进行完善，会涉及代码构建、自动化和工程化的内容，这些内容在 15 讲和 25 讲有进行详细的介绍。\n\n以上便是项目启动时，技术方案设计和选型需要考虑的一些问题。\n\n除此之外，当项目涉及多人协作、工作交接的时候，多人协作和团队规范同样重要。\n\n\n多人协作和团队规范\n\n相比项目的搭建和快速上线，项目的维护永远是程序员的大头。搭建一套代码和流程规范，不只是将规范写得淋漓尽致，更是需要使用流程化的工具来确保大家要遵守规范。\n\n使用一致的代码开发规范\n\n好的编码习惯很重要，语义化的变量命名、适当的注释等，都会对代码的可读性有很大的提升。但是每个人的习惯都不一样，所以我们需要有统一的代码规范。\n\n可以使用一些工具来确保代码符合规范：\n\n * 使用 eslint 检测代码规范；\n\n * 使用 prettier 自动化格式代码；\n\n * 使用 git commit hooks 拒绝不符合规范的代码提交；\n\n * 使用流水线检测出不规范的代码，并拒绝合入主干分支；\n\n * 使用流水线检测出不规范的代码，并拒绝进入发布流程。\n\n通过各种流程上的工具校验，确保大家都遵循规范进行开发，才能让规范的价值发挥出来。\n\n使用 eslint 这些工具能够帮助发现代码错误的规则，但代码的可读性和可维护性远远不止这些编码规则。\n\n很多时候，我们会使用一些设计模式来进行代码设计，也会对代码进行适度的抽象，比如封装成组件和公共库。每个人对代码该如何设计、要怎么抽象和封装、公共代码应该在哪维护等都有不同的理解，这些内容无法使用工具或者规则来强行约定。\n\n在这样的情况下，我们需要在每次合入代码的时候进行 code review，大家可以针对提交的代码进行讨论，提出修改的建议。在遇到分歧的时候，可以通过投票等方式来达成一致。\n\n除了编码相关的规范，开发过程中的流程规范也一样重要，比如对合入的代码进行 code review，对发布的代码进行自动化回归测试等。\n\n制定合适的代码流程规范\n\n一般来说，开发流程会包括：\n\n * git 创建分支过程：分支的命名，是否需要关联需求单或是 bug 单。\n\n * git 提交代码过程：检查代码是否符合规范，只允许合格的代码（eslint 规范、单测覆盖率等）进行提交。\n\n * 分支提交过程：需要进行交叉 code review，对方同意后才允许合入代码。\n\n * 合入主干过程：对代码进行自动化构建和测试，功能正常且符合规范的代码才可合入主干。\n\n * 代码发布过程：自动拉取主干分支，创建发布分支，对代码进行自动化构建和测试，正常后会开始进入灰度发布流程。\n\n通过自动化的工具我们同样可以确保以上流程按预期进行，很多团队也会使用持续集成（continuous integration，简称 ci）和持续部署（continuous deployment，简称 cd）。ci/cd 在项目中的落地，很多时候会表现为流水线的开发模式。\n\n建立完整的 ci/cd 流水线，除了可以按照规范约束每次代码提交的质量，还可以有效地提高效率。越是大规模的团队，越能体会到 ci/cd 带来的便利，这些内容我们会在第 25 讲中进行更详细的介绍。\n\n一个团队的正常运作，必然需要经过很多的协作方式磨合、合作过程争执、达成一致规范的过程。如果可以通过流程和工具来确保合作方式按约定进行，就不要作为可选项提供给团队成员靠自觉来执行，这样才可以维护稳定友好的团队运作模式。\n\n\n小结\n\n今天给大家介绍在前端项目设计时、维护过程中需要考虑的一些问题。\n\n 1. 项目开始前需要进行技术方案设计，选择适合团队和业务的技术栈进行开发。\n\n 2. 对于多人协作项目，团队需要达成一致的开发和流程规范，同时需要使用工具和流程来保证规范的约束力。\n\n在实际工作中，我们会遇到很多“糟糕”的代码，刚开始会尝试去进行优化，到后面大家都慢慢屈服。“又不是不能用”这样的想法让人生厌，而过于理想的设计往往又难以落地。\n\n代码本身就是会不断演化，也需要不断进行优化，一蹴而就、动不动就推倒重来的想法往往让人望而生畏，我们可以尝试拆成多步，一步一步脚踏实地地往前走。\n\n一个难以维护、却依然不断有新需求开发的项目，你会选择重新设计呢，还是会尝试一步步进行优化呢？欢迎在留言区分享你的想法。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **雨：\n\n> 时间和成本允许，重新设计和重写。反之慢慢重构，一步一步优化\n\n# **宇：\n\n> 只能说不要随便重构，可能你重构出来的后期在别人眼里也是垃圾。如果项目过于臃肿，可以用微服务这样的渐进式方法，分离一些业务出去\n\n#     讲师回复：\n\n>     是的，从业务稳定性来说，渐进式优化会比直接重构效果要好得多，直接选择重构有时候可能带来更多的历史债务\n\n# **童：\n\n> 我认为只要一个项目还在不断迭代更新，就肯定有可优化的余地。一般都会选择边写新需求边逐步优化，可能是现在新增的组件或者逻辑可以复用，也可能是某些旧代码有更优的编写思路。不过要认真看优化的地方所涉及的范围，不要出现漏改的情况，否则可能出现“一个现有的功能一直好好的，突然就不行了”的尴尬情况。。\n\n# *振：\n\n> 我的确遇到了这种项目，很庞大，重新设计会很困难，要花费相当长的时间，反正能用，只好一步步来了。。。可能后期能排上期，会重构一番",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"通过前端工程化提升团队开发效率",frontmatter:{title:"通过前端工程化提升团队开发效率",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/8a03a9/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/24.%E9%80%9A%E8%BF%87%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87.html",relativePath:"01.前端/01.前端开发笔记/24.通过前端工程化提升团队开发效率.md",key:"v-120f2772",path:"/pages/8a03a9/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4747}],headersStr:"精选评论",content:"前端工程化这个词出现的频率越来越高，一直没有明确的定义，有些人认为是模块化和自动化的工具，比如 Webpack/Gulp、脚手架、组件化等，但工具只是一些辅助手段，并不能作为工程化来理解。\n\n从工程角度来看，前端工程化致力于提升工程的开发效率、协作效率、项目质量，贯穿项目设计、开发、测试、上线、维护的整个过程。我们课程中也有介绍项目的设计和搭建、技术选型、监控体系搭建、项目风险控制和复盘等内容，这些内容都包含在前端工程化中。\n\n今天我从项目稳定性、可维护、高效协作的角度，来帮你了解如何在项目中实践前端工程化。\n\n首先，我们来看一下为什么要进行前端工程化。\n\n\n项目中常见问题\n\n相信大家的日常工作中也能感受到，相比于从 0 到 1 搭建项目，我们的大部分工作都是在维护项目，基于现有的项目上进行迭代和开发。正所谓“铁打的营盘流水的兵”，每个项目都会经历很多开发的参与、协作和交接，在这个过程中常常会遇到很多的问题，这些问题可以分为两类：\n\n 1. 系统质量的下降。\n\n 2. 开发效率的下降。\n\n我们分别来看下。\n\n问题 1：系统质量的下降\n\n“没有 Bug 的系统是不存在的”，当我们开始写代码的时候，Bug 也就随即而来。\n\nBug 的出现有很多的可能性，比如需求设计不严谨、代码实现的逻辑有漏洞、不在预期之内的异常逻辑分支，等等。概括来说，Bug 常常是因为对项目的不熟悉、对系统的理解不深入导致，这意味着以下的过程都会导致 Bug 的增加：\n\n 1. 项目频繁地调整（新增或者更换）开发人员，由于不熟悉项目，每个新加入的小伙伴都可能会埋下新的 Bug；\n\n 2. 系统功能新增和迭代、不断壮大，各个模块间的耦合增加、复杂度增加，如果没法掌握系统的所有细节，很可能牵一发而动全身，产生自己认知以外的 Bug。\n\n对于处于快速迭代、不断拓展阶段的项目来说，不管是人员的变动、还是项目的拓展都是无法避免的，这种情况下需要通过系统上线前的质量检测来确保问题尽早发现。但由于系统本身也趋向更加复杂，因此测试成本也会随之上升，未能发现的 Bug 进入线上版本的可能性也上升。\n\n为了降低系统的复杂度，当项目发展到一定阶段的时候，会对系统进行局部或是整体的架构调整，比如模块的拆分、各个模块间的依赖解耦、引入新的状态管理工具、重复逻辑进行抽象和封装，等等。\n\n新技术的引入会缓解系统复杂度带来的稳定性问题，但同时也可能会引入新的问题，比如：\n\n * 部分功能无法与新技术兼容，成为历史遗留问题；\n\n * 较大范围的架构调整影响面很广，可能埋下难以发现的 Bug。\n\n可见，一个项目不断发展的过程中，都会面临系统质量下降的问题，除此之外，还会导致开发效率的下降。\n\n问题 2：开发效率的下降\n\n“今天又要加班了，因为今天的代码还没开始写。”系统上线之后，开发的工作内容重心，会从功能开发逐渐转向其他内容。除了新功能的评审和设计以外，还会包括：\n\n * 用户反馈问题跟进和定位；\n\n * 线上 Bug 修复和紧急发布；\n\n * 处理系统的监控告警，排查异常问题；\n\n * 新功能灰度发布过程，自测、产品验证功能、提测、修复 Bug、灰度发布等各个流程都需要人工操作和主动关注；\n\n * 为了保证系统质量，需要完善自动化测试能力，包括单元测试、UI 测试、集成测试等；\n\n * 项目成员的调整，需要进行工作的交接、指导对方的工作内容等。\n\n开发的工作内容变得复杂，需要关注的事情也更多，对于各个系统（监控告警系统、日志系统、测试系统、发布系统等）也都需要熟悉成本和操作成本。在各个工作内容之间切换，也常常容易出现步骤的遗漏，导致一些流程上的问题，比如：\n\n 1. 系统灰度到一半，处理其他事情忘了全量；\n\n 2. 系统发布之后，去处理紧急 Bug、忘记看监控，直到收到大量的用户反馈；\n\n 3. 线上紧急 Bug 修复了，急着发布忘了进行自动化测试。\n\n随着项目规模变大，系统的复杂度也随之上升，上面所提到的工作量也都会增加，开发效率会肉眼可见地受到影响。以前一天工作量的功能开发，如今需要三天时间才能完成，因为每天只有三分之一的时间（甚至更少）可以用来开发新功能。\n\n在这个项目阶段，开发每天的杂事太多、效率太低、浑浑噩噩不知道都做了些什么，团队面临着项目复杂度上升、系统质量不稳定、技术债务越来越多、团队工作效率下降等问题。\n\n前端工程化的出现，正是为了解决系统质量和效率低下的问题，具体要怎么做呢？我们来看一下。\n\n\n如何进行前端工程化实践\n\n项目维护阶段的最大痛点，其实在于开发无法聚焦自身的工作内容，常常需要在各种系统中进行操作和切换，从而带来开发效率的下降，以及注意力分散、无法更全面的思考导致了不合理的设计、新的 Bug 引入，而影响了系统的质量。\n\n前端工程化同样可以从两个角度来进行。\n\n * 提升系统质量：项目设计和架构优化。\n\n * 提升开发效率：项目研发和发布流程优化。\n\n提升系统质量：项目设计和架构优化\n\n为了提升系统质量，我们需要对项目进行合理的架构调整，提升系统的可读性、可维护性、可测试行、稳定性，从而提升系统发布的稳定性。\n\n首先，在项目设计阶段，需要进行项目定位、技术选型、团队开发规范制定等，这些内容在上一讲有介绍，这里我们主要关注项目维护阶段的设计和优化。\n\n我们在进行架构设计时，需要根据项目的预期和现状来设计，保留拓展性的同时，避免过度设计。因此，随着项目不断发展，原有的架构设计可能不再适合，此时我们需要进行优化和调整的设计包括以下这些点。\n\n 1. 引入新的技术和工具的同时，需要考虑是否能兼容原有设计、团队成员熟悉成本、改造的工作量和预期的效果，选择性价比合适的方案落地。\n\n 2. 团队成员增加，沟通成本和对规范的理解出现差异。使用工具（Eslint/Prettier/Git hooks 等）将团队规范进行落地，保证开发过程中使用一致的技术栈、代码规范以及公共物料库（组件库、工具库），降低团队的沟通成本，确保代码的可读性和可维护性。\n\n 3. 项目功能模块过多，需要进行模块的拆分和解耦。将一些职责独立的模块进行拆包，使用 monorepo 或是 multirepo 的方式进行管理，模块可自行对技术方案、依赖关系梳理、变更、测试、发布等环节进行闭环，从而降低各个模块间的相互影响，降低系统的复杂度。\n\n 4. 项目代码量和文件数的增加，除了进行拆包以外，还需要更新或是优化项目构建工具（使用增量编译、使用 Tree-shaking、升级 Webpack 版本等），减少代码编译、打包等过程的耗时，提升开发效率。\n\n 5. 进行自动化测试能力的覆盖，补齐单模块的功能测试、各个模块间的集成测试、UI 组件的界面测试、接口的模拟环境测试、性能测试等。在每次系统发布的时候都可以自动化进行回归测试，避免某个改动影响了其他的功能模块、带来了认知以外的风险，确保系统质量不受影响。\n\n 6. 搭建完善的监控体系，在系统灰度、发布、线上运行的过程中可实时观察系统质量，配合告警能力及时发现问题并进行解决，保证系统运行的稳定性。\n\n在这个过程中，我们可能分别引入了新的代码构建、代码规范和自动化测试工具，搭建了新的监控系统、发布系统等。对于开发来说，开发流程变得烦琐，意味着工作内容更复杂，同时还增加了很多新工具和系统的熟悉成本。\n\n那么，我们还需要通过优化项目的研发和发布流程，来提升项目的开发效率。\n\n提升开发效率：项目研发和发布流程优化\n\n项目研发和发布流程优化的核心点在于：将一切需要手动操作和关注的内容自动化。\n\n那么，我们先来梳理下项目开发和发布过程中，到底有多少烦琐的工作可以进行自动化。一般来说，开发在接到产品需求单后，需要处理的事情包括：\n\n 1.  从主干创建分支，开始进入开发；\n\n 2.  开发完成后，补充相关自动化测试（单元测试、集成测试、UI 测试等）；\n\n 3.  进行自动化测试的回归，确保系统整体功能能正常运行；\n\n 4.  构建代码，部署测试环境，进入产品体验和测试流程；\n\n 5.  修复产品体验问题和 Bug，并重复 2~4 步骤；\n\n 6.  代码验证完成，进行团队内代码 Review 后，更新主干的分支，并进行代码构建和自动化回归测试；\n\n 7.  根据团队 Git 规范（比如 Git Flow 流程），准备发布；\n\n 8.  先进行版本灰度，灰度过程中登录监控系统关注各个指标是否有异常；\n\n 9.  如果监控系统出现异常，进行问题定位，并在 Bug 修复之后返回到步骤 2；\n\n 10. 灰度过程无异常，进行全量发布，发布完后同样观察监控系统是否有异常；\n\n 11. 全量发布完成，结束需求单，并将版本进行归存（使用分支或者 git tag）。\n\n可以看到，一次功能发布需要花费很多的精力在各个流程步骤上，我们可以将这些步骤都转为自动化，就可以让开发的精力聚焦在功能的设计和实现上。对于流程自动化，业界比较成熟的解决方案是使用持续集成（continuous integration，简称 CI）和持续部署（continuous deployment，简称 CD）。\n\n * 持续集成（CI）：目的是让产品可以快速迭代，同时还能保持高质量。\n\n * 持续部署（CD）：目的是代码在任何时刻都是可部署、可进入生产阶段。\n\nCI 在项目中的实践，指团队成员频繁（一天多次）地提交代码到主干分支，每次提交后会自动触发自动化验证的任务集合，以便尽可能地提前发现问题；CD 在项目中的实践，指代码通过评审以后，可自动化、可控、多批次地部署到生产环境，CD 的前提是能自动化完成测试、构建、部署等步骤。\n\nCI/CD 在项目中的落地，很多时候会表现为流水线的开发模式：通过建立完整的 CI/CD 流水线，涵盖整个研发流程，可有效地提高效率。\n\n以上面的开发流程为例，我们可以搭建这样的 CI/CD 流水线。\n\n\n\n通过将以上流程自动化，可以节省开发的很多人工操作时间、提升开发效率的同时，也避免了人工操作容易出现的遗漏和失误。\n\n这样的自动化流水线与通知/告警机器人、工作群、需求单系统、Bug 系统、代码管理系统、发布系统、监控系统结合，实现了全研发和发布流程的自动化，开发可从各种杂事中释放，专注于功能开发的实现。\n\n越是大规模、系统建设完备的团队，开发流程中消耗在多人协作和各个系统的操作中的精力越多，搭建 CI/CD 后更能体会到自动化流程带来的便利。\n\n当然，搭建 CI/CD 的过程中，也需要投入不少的人力精力。因此，很多时候我们可以考虑性价比，从对研发效能影响最大的痛点开始进行建设，可以最快速和有效地提升团队的开发效率，让更多的人愿意参与到 CI/CD 的建设中。\n\n这便是前端工程化：通过项目设计和架构优化，提升系统质量；通过自动化的方式，将项目研发和发布流程进行优化，提升开发效率。\n\n\n小结\n\n今天我带大家学习了前端工程化相关的内容。\n\n * 为什么要进行前端工程化：项目发展过程中，随着项目人员的增加、系统复杂度的上升，会出现系统质量和效率低下的问题；\n\n * 如何进行前端工程化：通过项目设计和架构优化来提升系统质量，通过优化研发和发布流程提升开发效率；\n\n在本节课结束前，我给大家留个问题：前端工程化和自动化、CI/CD 有什么区别呢？它们之间的关系是什么呢？\n\n欢迎在留言区进行写下你的思考～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **庐：\n\n> 我之前一直以为 前端工程化 基本就是脚手架相关的，可以通过工程化，快速开发新业务。\n\n# *振：\n\n> 前端工程化包括自动化，自动化包括 CI/CD?\n\n#     讲师回复：\n\n>     前端工程化这个词，其实一直没有明确的定义。个人理解是一切能提升开发效率的措施都可以作为工程化的一部分，自动化便是其中的一部分。而 CI/CD 则是自动化的其中一种/一部分解决方案",normalizedContent:"前端工程化这个词出现的频率越来越高，一直没有明确的定义，有些人认为是模块化和自动化的工具，比如 webpack/gulp、脚手架、组件化等，但工具只是一些辅助手段，并不能作为工程化来理解。\n\n从工程角度来看，前端工程化致力于提升工程的开发效率、协作效率、项目质量，贯穿项目设计、开发、测试、上线、维护的整个过程。我们课程中也有介绍项目的设计和搭建、技术选型、监控体系搭建、项目风险控制和复盘等内容，这些内容都包含在前端工程化中。\n\n今天我从项目稳定性、可维护、高效协作的角度，来帮你了解如何在项目中实践前端工程化。\n\n首先，我们来看一下为什么要进行前端工程化。\n\n\n项目中常见问题\n\n相信大家的日常工作中也能感受到，相比于从 0 到 1 搭建项目，我们的大部分工作都是在维护项目，基于现有的项目上进行迭代和开发。正所谓“铁打的营盘流水的兵”，每个项目都会经历很多开发的参与、协作和交接，在这个过程中常常会遇到很多的问题，这些问题可以分为两类：\n\n 1. 系统质量的下降。\n\n 2. 开发效率的下降。\n\n我们分别来看下。\n\n问题 1：系统质量的下降\n\n“没有 bug 的系统是不存在的”，当我们开始写代码的时候，bug 也就随即而来。\n\nbug 的出现有很多的可能性，比如需求设计不严谨、代码实现的逻辑有漏洞、不在预期之内的异常逻辑分支，等等。概括来说，bug 常常是因为对项目的不熟悉、对系统的理解不深入导致，这意味着以下的过程都会导致 bug 的增加：\n\n 1. 项目频繁地调整（新增或者更换）开发人员，由于不熟悉项目，每个新加入的小伙伴都可能会埋下新的 bug；\n\n 2. 系统功能新增和迭代、不断壮大，各个模块间的耦合增加、复杂度增加，如果没法掌握系统的所有细节，很可能牵一发而动全身，产生自己认知以外的 bug。\n\n对于处于快速迭代、不断拓展阶段的项目来说，不管是人员的变动、还是项目的拓展都是无法避免的，这种情况下需要通过系统上线前的质量检测来确保问题尽早发现。但由于系统本身也趋向更加复杂，因此测试成本也会随之上升，未能发现的 bug 进入线上版本的可能性也上升。\n\n为了降低系统的复杂度，当项目发展到一定阶段的时候，会对系统进行局部或是整体的架构调整，比如模块的拆分、各个模块间的依赖解耦、引入新的状态管理工具、重复逻辑进行抽象和封装，等等。\n\n新技术的引入会缓解系统复杂度带来的稳定性问题，但同时也可能会引入新的问题，比如：\n\n * 部分功能无法与新技术兼容，成为历史遗留问题；\n\n * 较大范围的架构调整影响面很广，可能埋下难以发现的 bug。\n\n可见，一个项目不断发展的过程中，都会面临系统质量下降的问题，除此之外，还会导致开发效率的下降。\n\n问题 2：开发效率的下降\n\n“今天又要加班了，因为今天的代码还没开始写。”系统上线之后，开发的工作内容重心，会从功能开发逐渐转向其他内容。除了新功能的评审和设计以外，还会包括：\n\n * 用户反馈问题跟进和定位；\n\n * 线上 bug 修复和紧急发布；\n\n * 处理系统的监控告警，排查异常问题；\n\n * 新功能灰度发布过程，自测、产品验证功能、提测、修复 bug、灰度发布等各个流程都需要人工操作和主动关注；\n\n * 为了保证系统质量，需要完善自动化测试能力，包括单元测试、ui 测试、集成测试等；\n\n * 项目成员的调整，需要进行工作的交接、指导对方的工作内容等。\n\n开发的工作内容变得复杂，需要关注的事情也更多，对于各个系统（监控告警系统、日志系统、测试系统、发布系统等）也都需要熟悉成本和操作成本。在各个工作内容之间切换，也常常容易出现步骤的遗漏，导致一些流程上的问题，比如：\n\n 1. 系统灰度到一半，处理其他事情忘了全量；\n\n 2. 系统发布之后，去处理紧急 bug、忘记看监控，直到收到大量的用户反馈；\n\n 3. 线上紧急 bug 修复了，急着发布忘了进行自动化测试。\n\n随着项目规模变大，系统的复杂度也随之上升，上面所提到的工作量也都会增加，开发效率会肉眼可见地受到影响。以前一天工作量的功能开发，如今需要三天时间才能完成，因为每天只有三分之一的时间（甚至更少）可以用来开发新功能。\n\n在这个项目阶段，开发每天的杂事太多、效率太低、浑浑噩噩不知道都做了些什么，团队面临着项目复杂度上升、系统质量不稳定、技术债务越来越多、团队工作效率下降等问题。\n\n前端工程化的出现，正是为了解决系统质量和效率低下的问题，具体要怎么做呢？我们来看一下。\n\n\n如何进行前端工程化实践\n\n项目维护阶段的最大痛点，其实在于开发无法聚焦自身的工作内容，常常需要在各种系统中进行操作和切换，从而带来开发效率的下降，以及注意力分散、无法更全面的思考导致了不合理的设计、新的 bug 引入，而影响了系统的质量。\n\n前端工程化同样可以从两个角度来进行。\n\n * 提升系统质量：项目设计和架构优化。\n\n * 提升开发效率：项目研发和发布流程优化。\n\n提升系统质量：项目设计和架构优化\n\n为了提升系统质量，我们需要对项目进行合理的架构调整，提升系统的可读性、可维护性、可测试行、稳定性，从而提升系统发布的稳定性。\n\n首先，在项目设计阶段，需要进行项目定位、技术选型、团队开发规范制定等，这些内容在上一讲有介绍，这里我们主要关注项目维护阶段的设计和优化。\n\n我们在进行架构设计时，需要根据项目的预期和现状来设计，保留拓展性的同时，避免过度设计。因此，随着项目不断发展，原有的架构设计可能不再适合，此时我们需要进行优化和调整的设计包括以下这些点。\n\n 1. 引入新的技术和工具的同时，需要考虑是否能兼容原有设计、团队成员熟悉成本、改造的工作量和预期的效果，选择性价比合适的方案落地。\n\n 2. 团队成员增加，沟通成本和对规范的理解出现差异。使用工具（eslint/prettier/git hooks 等）将团队规范进行落地，保证开发过程中使用一致的技术栈、代码规范以及公共物料库（组件库、工具库），降低团队的沟通成本，确保代码的可读性和可维护性。\n\n 3. 项目功能模块过多，需要进行模块的拆分和解耦。将一些职责独立的模块进行拆包，使用 monorepo 或是 multirepo 的方式进行管理，模块可自行对技术方案、依赖关系梳理、变更、测试、发布等环节进行闭环，从而降低各个模块间的相互影响，降低系统的复杂度。\n\n 4. 项目代码量和文件数的增加，除了进行拆包以外，还需要更新或是优化项目构建工具（使用增量编译、使用 tree-shaking、升级 webpack 版本等），减少代码编译、打包等过程的耗时，提升开发效率。\n\n 5. 进行自动化测试能力的覆盖，补齐单模块的功能测试、各个模块间的集成测试、ui 组件的界面测试、接口的模拟环境测试、性能测试等。在每次系统发布的时候都可以自动化进行回归测试，避免某个改动影响了其他的功能模块、带来了认知以外的风险，确保系统质量不受影响。\n\n 6. 搭建完善的监控体系，在系统灰度、发布、线上运行的过程中可实时观察系统质量，配合告警能力及时发现问题并进行解决，保证系统运行的稳定性。\n\n在这个过程中，我们可能分别引入了新的代码构建、代码规范和自动化测试工具，搭建了新的监控系统、发布系统等。对于开发来说，开发流程变得烦琐，意味着工作内容更复杂，同时还增加了很多新工具和系统的熟悉成本。\n\n那么，我们还需要通过优化项目的研发和发布流程，来提升项目的开发效率。\n\n提升开发效率：项目研发和发布流程优化\n\n项目研发和发布流程优化的核心点在于：将一切需要手动操作和关注的内容自动化。\n\n那么，我们先来梳理下项目开发和发布过程中，到底有多少烦琐的工作可以进行自动化。一般来说，开发在接到产品需求单后，需要处理的事情包括：\n\n 1.  从主干创建分支，开始进入开发；\n\n 2.  开发完成后，补充相关自动化测试（单元测试、集成测试、ui 测试等）；\n\n 3.  进行自动化测试的回归，确保系统整体功能能正常运行；\n\n 4.  构建代码，部署测试环境，进入产品体验和测试流程；\n\n 5.  修复产品体验问题和 bug，并重复 2~4 步骤；\n\n 6.  代码验证完成，进行团队内代码 review 后，更新主干的分支，并进行代码构建和自动化回归测试；\n\n 7.  根据团队 git 规范（比如 git flow 流程），准备发布；\n\n 8.  先进行版本灰度，灰度过程中登录监控系统关注各个指标是否有异常；\n\n 9.  如果监控系统出现异常，进行问题定位，并在 bug 修复之后返回到步骤 2；\n\n 10. 灰度过程无异常，进行全量发布，发布完后同样观察监控系统是否有异常；\n\n 11. 全量发布完成，结束需求单，并将版本进行归存（使用分支或者 git tag）。\n\n可以看到，一次功能发布需要花费很多的精力在各个流程步骤上，我们可以将这些步骤都转为自动化，就可以让开发的精力聚焦在功能的设计和实现上。对于流程自动化，业界比较成熟的解决方案是使用持续集成（continuous integration，简称 ci）和持续部署（continuous deployment，简称 cd）。\n\n * 持续集成（ci）：目的是让产品可以快速迭代，同时还能保持高质量。\n\n * 持续部署（cd）：目的是代码在任何时刻都是可部署、可进入生产阶段。\n\nci 在项目中的实践，指团队成员频繁（一天多次）地提交代码到主干分支，每次提交后会自动触发自动化验证的任务集合，以便尽可能地提前发现问题；cd 在项目中的实践，指代码通过评审以后，可自动化、可控、多批次地部署到生产环境，cd 的前提是能自动化完成测试、构建、部署等步骤。\n\nci/cd 在项目中的落地，很多时候会表现为流水线的开发模式：通过建立完整的 ci/cd 流水线，涵盖整个研发流程，可有效地提高效率。\n\n以上面的开发流程为例，我们可以搭建这样的 ci/cd 流水线。\n\n\n\n通过将以上流程自动化，可以节省开发的很多人工操作时间、提升开发效率的同时，也避免了人工操作容易出现的遗漏和失误。\n\n这样的自动化流水线与通知/告警机器人、工作群、需求单系统、bug 系统、代码管理系统、发布系统、监控系统结合，实现了全研发和发布流程的自动化，开发可从各种杂事中释放，专注于功能开发的实现。\n\n越是大规模、系统建设完备的团队，开发流程中消耗在多人协作和各个系统的操作中的精力越多，搭建 ci/cd 后更能体会到自动化流程带来的便利。\n\n当然，搭建 ci/cd 的过程中，也需要投入不少的人力精力。因此，很多时候我们可以考虑性价比，从对研发效能影响最大的痛点开始进行建设，可以最快速和有效地提升团队的开发效率，让更多的人愿意参与到 ci/cd 的建设中。\n\n这便是前端工程化：通过项目设计和架构优化，提升系统质量；通过自动化的方式，将项目研发和发布流程进行优化，提升开发效率。\n\n\n小结\n\n今天我带大家学习了前端工程化相关的内容。\n\n * 为什么要进行前端工程化：项目发展过程中，随着项目人员的增加、系统复杂度的上升，会出现系统质量和效率低下的问题；\n\n * 如何进行前端工程化：通过项目设计和架构优化来提升系统质量，通过优化研发和发布流程提升开发效率；\n\n在本节课结束前，我给大家留个问题：前端工程化和自动化、ci/cd 有什么区别呢？它们之间的关系是什么呢？\n\n欢迎在留言区进行写下你的思考～\n\n----------------------------------------\n\n\n# 精选评论\n\n# **庐：\n\n> 我之前一直以为 前端工程化 基本就是脚手架相关的，可以通过工程化，快速开发新业务。\n\n# *振：\n\n> 前端工程化包括自动化，自动化包括 ci/cd?\n\n#     讲师回复：\n\n>     前端工程化这个词，其实一直没有明确的定义。个人理解是一切能提升开发效率的措施都可以作为工程化的一部分，自动化便是其中的一部分。而 ci/cd 则是自动化的其中一种/一部分解决方案",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"大型前端项目的痛点和优化方案",frontmatter:{title:"大型前端项目的痛点和优化方案",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/e991d8/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/25.%E5%A4%A7%E5%9E%8B%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%97%9B%E7%82%B9%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.html",relativePath:"01.前端/01.前端开发笔记/25.大型前端项目的痛点和优化方案.md",key:"v-09ee94f0",path:"/pages/e991d8/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4765}],headersStr:"精选评论",content:'说到大型前端项目，很多人都会感到疑惑，怎样的项目算是大型前端项目呢？这的确没有一个定级，在这里我们可以粗略地进行定义：当项目的前端开发人员达到 10 人以上、模块数量达到 30 以上、代码量在 30W 行以上的项目，在本课程中可认为是大型前端项目。\n\n在前端业务领域中，除了大型开源项目（热门框架、VsCode、Atom 等）以外，协同编辑类应用（比如在线文档）、复杂交互类应用（比如大型游戏）等，都可以称得上是大型前端项目。不管是不是大型项目，对于如何进行架构设计、如何快速搭建项目、如何通过工程化来提升开发效率，这些都在前面几讲有介绍。\n\n今天我们主要围绕着大型前端项目中的痛点进行介绍，比如：\n\n 1. 各个模块间耦合严重，功能开发、技术优化、重构工作等均难以开展；\n\n 2. 项目规模太大，每个人只了解其中一部分，需要改动到不熟悉的模块时常常出问题；\n\n 3. 项目代码量大，不管是编译、构建，还是浏览器加载，耗时都较多、性能也较差；\n\n 4. 项目交互逻辑复杂，问题定位、Bug 修复等过程效率很低，需要耗费不少精力。\n\n首先我们来看看模块耦合的问题。\n\n\n问题 1：模块耦合严重\n\n不同的模块需要进行分工和配合，因此相互之间必然会产生耦合。在大型项目中，由于模块数量很多，如果没有进行合适的管理和约束，可能会导致以下情况：\n\n 1. 模块职责和边界定义不清晰，导致模糊的工作可能存在多个模块内；\n\n 2. 各个模块没有统一管理，导致模块在状态变更时需要手动通知相关模块；\n\n 3. 模块间的通信方式设计不合理，导致全局事件满天飞、A 模块内直接调用 B 模块等问题，隐藏的引用和事件可能导致内存泄漏。\n\n下面我们来看一个例子。\n\n小明接到一个渲染层的技术需求，需要在 DOM 渲染的基础上支持 Canvas 渲染，从而提升页面渲染和加载性能。小明认为，渲染层只需要从数据层获取数据，然后根据需要进行 DOM 渲染和 Canvas 渲染就可以了。也就是说，他只需要开发一个 Loader 装载器，并分别实现 DOMLoader 和 CanvasLoader，就可以完成这次的改造。\n\n当小明开始研究原有的 DOM 加载代码，试图从中拆解出通用 Loader 的逻辑时，他突然发现渲染层并不只是使用到数据层的数据，还有很多来自网络层的事件、并从中响应数据进行渲染。除此之外，渲染层中还存在用户操作（click/tap/touchmove等事件）的逻辑，甚至这些操作还会在渲染层里与数据层、网络层进行逻辑处理。\n\n考虑到这些逻辑已经存在 2 年多了，当时开发这些功能的小伙伴都不在了，小明对此不熟悉也不敢动，最后只能用兼容的方式（比如if/else）来实现 Canvas 渲染。小明这样的改造方式，虽然实现了需求，最终却给项目添加了新的技术债务。\n\n小明遇到的问题，正是因为各个模块间的耦合过于严重、短时间内无法解耦导致的。那么，我们要怎么避免出现模块耦合过多的情况呢？\n\n 1. 项目规模调整后，对现有架构设计进行分析，如果不再合适则需要进行及时调整和优化。\n\n 2. 使用模块解耦的技术方案，将各个模块统一交由框架处理。\n\n 3. 梳理各个模块的职责，明确每个模块负责的工作和提供的功能，确定各个模块间的边界和调用方式。\n\n在第 14 讲中我已经详细介绍过如何设计模块、使用依赖倒置进行依赖解耦，第 19 讲中也提到如何使用事件监听来管理模块间的通信和状态。在 VsCode 中，我们也可以看到使用依赖注入框架和标准化的Event/Emitter事件监听的方式，来对各个模块进行解耦。\n\n * 各个模块的生命周期（初始化、销毁）统一由框架进行管理：通过提供通用类Disposable，统一管理相关资源的注册和销毁。\n\n * 模块间不直接引入和调用，而是通过声明依赖的方式，从框架中获取相应的服务并使用。\n\n * 不直接使用全局事件进行通信，而是通过订阅具体服务的方式来处理：通过使用同样的方式this._register()注册事件和订阅事件，将事件相关资源的处理统一挂载到dispose()方法中。\n\n使用依赖注入框架的好处在于，各个模块之间不会再有直接联系。模块以服务的方式进行注册，通过声明依赖的方式来获取需要使用的服务，框架会对模块间依赖关系进行分析，判断某个服务是否需要初始化和销毁，从而避免了不必要的服务被加载。\n\n在对模块进行了解耦之后，每个模块都可以专注于自身的功能开发、技术优化，甚至可以在保持对外接口不变的情况下，进行模块重构。\n\n\n问题 2：项目复杂熟悉成本过高\n\n当一个项目中存在 30 个以上的模块的同时，项目还在不断地进行迭代和优化。在这样的情况下，基本上没有一个人能熟悉所有模块的所有细节，这会带来一些问题：\n\n * 对于新需求、新功能，开发无法完整地评估技术方案是否可以实现、会不会带来新的问题；\n\n * 需求开发时需要改动不熟悉的代码，无法评估是否存在风险；\n\n * 架构级别的优化工作，难以确定是否可以真正落地；\n\n * 一些模块遗留的历史债务，由于工作进行过多次交接，相关逻辑已无人熟悉，无法进行处理。\n\n导致这些问题的根本原因有两个：\n\n * 开发者无法专注于某个模块开发；\n\n * 同一个模块可能被多个人调整和变更。\n\n对于这种情况，可以使用模块负责人的机制来对模块进行所有权分配，进行管理和维护。\n\n 1. 每个开发者都认领（或分配）一个或多个模块，并要求完全熟悉和掌握模块的细节，且维护文档进行说明。\n\n 2. 对于需求开发、Bug 修复、技术优化过程中涉及非自身的模块，需要找到对应模块的负责人进行风险评估和代码 Review。\n\n 3. 模块的负责人负责自身模块的技术优化方案，包括性能优化、自动化测试覆盖、代码规范调整等工作。\n\n 4. 对于较核心/复杂的模块，可由多个负责人共同维护，协商技术细节。\n\n通过模块负责人机制，每个模块都有了对应的开发进行维护和优化，开发者也可以专注于自身的某些模块进行功能开发。在人员离职和工作内容交接的时候，也可以通过文档+负责人权限的方式进行模块交接。\n\n\n问题 3：项目代码量过大\n\n对于代码量高达 30W 行以上的项目，如果不做任何优化直接全量跑在浏览器中，不管是加载耗时增加导致用户等待时间过久，还是内存占用过高导致用户交互卡顿，都会给用户带来不好的体验。\n\n性能优化的解决方案我们在第 22 讲中也有介绍，对于代码量、文件过多这样的性能优化，无非就两个字。\n\n * 拆：拆模块、拆公共库、拆组件库；\n\n * 分：分流程、分步骤。\n\n比如你可以这么做。\n\n 1. 代码按需引入，移除不必要的代码（比如使用 Tree-shaking）。\n\n 2. 异步加载模块，根据业务需要将模块拆分成多个步骤加载（比如优化依赖注入框架对模块分批初始化）。\n\n 3. 加载流程优化，分析并对首屏需要的模块做减法。\n\n 4. 差异化服务，对于不同场景只加载所需要的模块内容（比如读写分离）。\n\n 5. 代码复用，对重复逻辑进行组件和公共库的抽象和封装。\n\n对于项目代码量过大，代码开发过程中同样存在糟糕的体验：由于代码量过大，开发的本地构建、编译都变得很慢，甚至去打水+上厕所回来之后，代码还没编译完。\n\n从维护角度来看，一个项目的代码量过大，对开发、编译、构建、部署、发布流程都会同样带来不少的压力。因此除了浏览器加载过程中的代码拆分，对项目代码也可以进行拆分，一般来说有两种方式。\n\n包管理模式       说明                               优点                      缺点\nmultirepo   多仓库模块管理，通过工作流从各个仓库拉取代码并进行编译、打包   模块可根据需要灵活选择各自的编译、构建工具   项目代码分散在各个仓库，问题定位困难\n                                             每个仓库的代码量较小，方便维护         模块变动后，需要更新相关仓库的依赖配置\nmonorepo    单仓库模块管理，可使用 lerna 进行包管理          项目代码可集中进行管理，使用统一的构建工具   仓库体积大，对构建工具要求较高\n                                             模块间调试方便、问题定位和修复相对容易     对项目文件结构和管理、代码可测试和维护性要求较高\n                                                                     为了保证代码质量，对版本控制和 Git 工作流要求更高\n\n两种包管理模式各有优劣，一般来说一个项目只会采用其中一种，但也可以根据具体需要进行调整，比如统一的 UI 组件库进行分仓库管理、核心业务逻辑在主仓库内进行拆包（像渲染层/数据层/网络层拆分模块）管理。\n\n\n问题 4：问题定位效率低\n\n在对模块进行拆分和解耦、使用了模块负责人机制、进行包拆分管理之后，虽然开发同学可以更加专注于自身负责模块的开发和维护，但有些时候依然无法避免接触其他模块。\n\n对于这样大型的项目，维护过程（熟悉代码、定位问题、性能优化等）由于代码量太多、各个函数的调用链路太长，以及函数执行情况黑盒、函数调用链不清晰、函数耗时不清楚等问题，导致问题定位异常困难。要是遇到代码稍微复杂点，事件比较多、函数调用也特别多的，即使使用断点调试也能看到眼花，蒸汽眼罩都得多买一些。\n\n对于这些问题，可以将问题定位过程进行自动化实现，比如：\n\n 1. 模块负责人对自身模块执行的关键点进行标记，在开发+调试模式下，其他开发可通过开启断点的方式来直接定位问题。\n\n 2. 通过使用调用堆栈记录各个关键模块和函数的调用顺序、调用关系、入参出参是否正常，模块负责人提供过往数据的参考和分析建议，其他开发可直接根据指引进行分析。\n\n这个过程，其实是将模块负责人的知识通过工具的方式授予其他开发，大家可以快速找到某个模块经常出问题的地方、模块执行的关键点，根据建议和提示进行问题定位，可极大地提升问题定位的效率。\n\n除了问题定位以外，各个模块和函数的调用关系、调用耗时也可以作为系统功能和性能是否有异常的参考。因此，我们还可以通过将调用堆栈收集过程自动化、接入流水线，在每次发布前合入代码时执行相关的任务，对比以往的数据进行分析，生成系统性能和功能的风险报告，提前在发布前发现风险。\n\n\n小结\n\n今天给大家介绍了大型前端项目中的一些痛点，概括起来就是：大型项目中代码量过大、模块耦合严重，开发对项目的熟悉成本骤增，导致功能开发、技术优化的风险上升，以及开发维护、问题定位的效率下降。\n\n通过模块解耦和拆分、使用模块负责人机制、知识传承工具化等方式可以优化上述问题，核心思想是代码职责的拆分+开发职责的拆分。这样，每个模块可以专注于自身的功能实现，每个开发也可以专注于所负责模块的开发和维护。\n\n当然，每个解决方案都有各自的利弊，你觉得这样的解决方案的问题和风险点在哪呢？欢迎在留言区进行讨论。\n\n在我们的日常工作中，通常也会局限于某块功能的实现和某个领域的开发。如果这些内容并没有足够的深度可以挖掘，对个人的成长发展也可能会有限制。在这种情况下，我们可以主动去了解和学习其他领域的知识，也可以主动承担起更多的工作内容。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **童：\n\n> 以前一直用的是multirepo。最近想写个cli，确实想用现在很流行的monorepo项目管理方式，可能会再加lerna。没想到看到被删这篇文章也有提及~"考虑到这些逻辑已经存在 2 年多了，当时开发这些功能的小伙伴都不在了"，都不在了。。好惨\n\n# **航：\n\n> 对于多人协作开发的大型项目，难以避免就会有模块间的循环引用问题，请教一下这个问题目前有没有好的解决方案，除了把逻辑全包到一个方法里让它延迟执行以外',normalizedContent:'说到大型前端项目，很多人都会感到疑惑，怎样的项目算是大型前端项目呢？这的确没有一个定级，在这里我们可以粗略地进行定义：当项目的前端开发人员达到 10 人以上、模块数量达到 30 以上、代码量在 30w 行以上的项目，在本课程中可认为是大型前端项目。\n\n在前端业务领域中，除了大型开源项目（热门框架、vscode、atom 等）以外，协同编辑类应用（比如在线文档）、复杂交互类应用（比如大型游戏）等，都可以称得上是大型前端项目。不管是不是大型项目，对于如何进行架构设计、如何快速搭建项目、如何通过工程化来提升开发效率，这些都在前面几讲有介绍。\n\n今天我们主要围绕着大型前端项目中的痛点进行介绍，比如：\n\n 1. 各个模块间耦合严重，功能开发、技术优化、重构工作等均难以开展；\n\n 2. 项目规模太大，每个人只了解其中一部分，需要改动到不熟悉的模块时常常出问题；\n\n 3. 项目代码量大，不管是编译、构建，还是浏览器加载，耗时都较多、性能也较差；\n\n 4. 项目交互逻辑复杂，问题定位、bug 修复等过程效率很低，需要耗费不少精力。\n\n首先我们来看看模块耦合的问题。\n\n\n问题 1：模块耦合严重\n\n不同的模块需要进行分工和配合，因此相互之间必然会产生耦合。在大型项目中，由于模块数量很多，如果没有进行合适的管理和约束，可能会导致以下情况：\n\n 1. 模块职责和边界定义不清晰，导致模糊的工作可能存在多个模块内；\n\n 2. 各个模块没有统一管理，导致模块在状态变更时需要手动通知相关模块；\n\n 3. 模块间的通信方式设计不合理，导致全局事件满天飞、a 模块内直接调用 b 模块等问题，隐藏的引用和事件可能导致内存泄漏。\n\n下面我们来看一个例子。\n\n小明接到一个渲染层的技术需求，需要在 dom 渲染的基础上支持 canvas 渲染，从而提升页面渲染和加载性能。小明认为，渲染层只需要从数据层获取数据，然后根据需要进行 dom 渲染和 canvas 渲染就可以了。也就是说，他只需要开发一个 loader 装载器，并分别实现 domloader 和 canvasloader，就可以完成这次的改造。\n\n当小明开始研究原有的 dom 加载代码，试图从中拆解出通用 loader 的逻辑时，他突然发现渲染层并不只是使用到数据层的数据，还有很多来自网络层的事件、并从中响应数据进行渲染。除此之外，渲染层中还存在用户操作（click/tap/touchmove等事件）的逻辑，甚至这些操作还会在渲染层里与数据层、网络层进行逻辑处理。\n\n考虑到这些逻辑已经存在 2 年多了，当时开发这些功能的小伙伴都不在了，小明对此不熟悉也不敢动，最后只能用兼容的方式（比如if/else）来实现 canvas 渲染。小明这样的改造方式，虽然实现了需求，最终却给项目添加了新的技术债务。\n\n小明遇到的问题，正是因为各个模块间的耦合过于严重、短时间内无法解耦导致的。那么，我们要怎么避免出现模块耦合过多的情况呢？\n\n 1. 项目规模调整后，对现有架构设计进行分析，如果不再合适则需要进行及时调整和优化。\n\n 2. 使用模块解耦的技术方案，将各个模块统一交由框架处理。\n\n 3. 梳理各个模块的职责，明确每个模块负责的工作和提供的功能，确定各个模块间的边界和调用方式。\n\n在第 14 讲中我已经详细介绍过如何设计模块、使用依赖倒置进行依赖解耦，第 19 讲中也提到如何使用事件监听来管理模块间的通信和状态。在 vscode 中，我们也可以看到使用依赖注入框架和标准化的event/emitter事件监听的方式，来对各个模块进行解耦。\n\n * 各个模块的生命周期（初始化、销毁）统一由框架进行管理：通过提供通用类disposable，统一管理相关资源的注册和销毁。\n\n * 模块间不直接引入和调用，而是通过声明依赖的方式，从框架中获取相应的服务并使用。\n\n * 不直接使用全局事件进行通信，而是通过订阅具体服务的方式来处理：通过使用同样的方式this._register()注册事件和订阅事件，将事件相关资源的处理统一挂载到dispose()方法中。\n\n使用依赖注入框架的好处在于，各个模块之间不会再有直接联系。模块以服务的方式进行注册，通过声明依赖的方式来获取需要使用的服务，框架会对模块间依赖关系进行分析，判断某个服务是否需要初始化和销毁，从而避免了不必要的服务被加载。\n\n在对模块进行了解耦之后，每个模块都可以专注于自身的功能开发、技术优化，甚至可以在保持对外接口不变的情况下，进行模块重构。\n\n\n问题 2：项目复杂熟悉成本过高\n\n当一个项目中存在 30 个以上的模块的同时，项目还在不断地进行迭代和优化。在这样的情况下，基本上没有一个人能熟悉所有模块的所有细节，这会带来一些问题：\n\n * 对于新需求、新功能，开发无法完整地评估技术方案是否可以实现、会不会带来新的问题；\n\n * 需求开发时需要改动不熟悉的代码，无法评估是否存在风险；\n\n * 架构级别的优化工作，难以确定是否可以真正落地；\n\n * 一些模块遗留的历史债务，由于工作进行过多次交接，相关逻辑已无人熟悉，无法进行处理。\n\n导致这些问题的根本原因有两个：\n\n * 开发者无法专注于某个模块开发；\n\n * 同一个模块可能被多个人调整和变更。\n\n对于这种情况，可以使用模块负责人的机制来对模块进行所有权分配，进行管理和维护。\n\n 1. 每个开发者都认领（或分配）一个或多个模块，并要求完全熟悉和掌握模块的细节，且维护文档进行说明。\n\n 2. 对于需求开发、bug 修复、技术优化过程中涉及非自身的模块，需要找到对应模块的负责人进行风险评估和代码 review。\n\n 3. 模块的负责人负责自身模块的技术优化方案，包括性能优化、自动化测试覆盖、代码规范调整等工作。\n\n 4. 对于较核心/复杂的模块，可由多个负责人共同维护，协商技术细节。\n\n通过模块负责人机制，每个模块都有了对应的开发进行维护和优化，开发者也可以专注于自身的某些模块进行功能开发。在人员离职和工作内容交接的时候，也可以通过文档+负责人权限的方式进行模块交接。\n\n\n问题 3：项目代码量过大\n\n对于代码量高达 30w 行以上的项目，如果不做任何优化直接全量跑在浏览器中，不管是加载耗时增加导致用户等待时间过久，还是内存占用过高导致用户交互卡顿，都会给用户带来不好的体验。\n\n性能优化的解决方案我们在第 22 讲中也有介绍，对于代码量、文件过多这样的性能优化，无非就两个字。\n\n * 拆：拆模块、拆公共库、拆组件库；\n\n * 分：分流程、分步骤。\n\n比如你可以这么做。\n\n 1. 代码按需引入，移除不必要的代码（比如使用 tree-shaking）。\n\n 2. 异步加载模块，根据业务需要将模块拆分成多个步骤加载（比如优化依赖注入框架对模块分批初始化）。\n\n 3. 加载流程优化，分析并对首屏需要的模块做减法。\n\n 4. 差异化服务，对于不同场景只加载所需要的模块内容（比如读写分离）。\n\n 5. 代码复用，对重复逻辑进行组件和公共库的抽象和封装。\n\n对于项目代码量过大，代码开发过程中同样存在糟糕的体验：由于代码量过大，开发的本地构建、编译都变得很慢，甚至去打水+上厕所回来之后，代码还没编译完。\n\n从维护角度来看，一个项目的代码量过大，对开发、编译、构建、部署、发布流程都会同样带来不少的压力。因此除了浏览器加载过程中的代码拆分，对项目代码也可以进行拆分，一般来说有两种方式。\n\n包管理模式       说明                               优点                      缺点\nmultirepo   多仓库模块管理，通过工作流从各个仓库拉取代码并进行编译、打包   模块可根据需要灵活选择各自的编译、构建工具   项目代码分散在各个仓库，问题定位困难\n                                             每个仓库的代码量较小，方便维护         模块变动后，需要更新相关仓库的依赖配置\nmonorepo    单仓库模块管理，可使用 lerna 进行包管理          项目代码可集中进行管理，使用统一的构建工具   仓库体积大，对构建工具要求较高\n                                             模块间调试方便、问题定位和修复相对容易     对项目文件结构和管理、代码可测试和维护性要求较高\n                                                                     为了保证代码质量，对版本控制和 git 工作流要求更高\n\n两种包管理模式各有优劣，一般来说一个项目只会采用其中一种，但也可以根据具体需要进行调整，比如统一的 ui 组件库进行分仓库管理、核心业务逻辑在主仓库内进行拆包（像渲染层/数据层/网络层拆分模块）管理。\n\n\n问题 4：问题定位效率低\n\n在对模块进行拆分和解耦、使用了模块负责人机制、进行包拆分管理之后，虽然开发同学可以更加专注于自身负责模块的开发和维护，但有些时候依然无法避免接触其他模块。\n\n对于这样大型的项目，维护过程（熟悉代码、定位问题、性能优化等）由于代码量太多、各个函数的调用链路太长，以及函数执行情况黑盒、函数调用链不清晰、函数耗时不清楚等问题，导致问题定位异常困难。要是遇到代码稍微复杂点，事件比较多、函数调用也特别多的，即使使用断点调试也能看到眼花，蒸汽眼罩都得多买一些。\n\n对于这些问题，可以将问题定位过程进行自动化实现，比如：\n\n 1. 模块负责人对自身模块执行的关键点进行标记，在开发+调试模式下，其他开发可通过开启断点的方式来直接定位问题。\n\n 2. 通过使用调用堆栈记录各个关键模块和函数的调用顺序、调用关系、入参出参是否正常，模块负责人提供过往数据的参考和分析建议，其他开发可直接根据指引进行分析。\n\n这个过程，其实是将模块负责人的知识通过工具的方式授予其他开发，大家可以快速找到某个模块经常出问题的地方、模块执行的关键点，根据建议和提示进行问题定位，可极大地提升问题定位的效率。\n\n除了问题定位以外，各个模块和函数的调用关系、调用耗时也可以作为系统功能和性能是否有异常的参考。因此，我们还可以通过将调用堆栈收集过程自动化、接入流水线，在每次发布前合入代码时执行相关的任务，对比以往的数据进行分析，生成系统性能和功能的风险报告，提前在发布前发现风险。\n\n\n小结\n\n今天给大家介绍了大型前端项目中的一些痛点，概括起来就是：大型项目中代码量过大、模块耦合严重，开发对项目的熟悉成本骤增，导致功能开发、技术优化的风险上升，以及开发维护、问题定位的效率下降。\n\n通过模块解耦和拆分、使用模块负责人机制、知识传承工具化等方式可以优化上述问题，核心思想是代码职责的拆分+开发职责的拆分。这样，每个模块可以专注于自身的功能实现，每个开发也可以专注于所负责模块的开发和维护。\n\n当然，每个解决方案都有各自的利弊，你觉得这样的解决方案的问题和风险点在哪呢？欢迎在留言区进行讨论。\n\n在我们的日常工作中，通常也会局限于某块功能的实现和某个领域的开发。如果这些内容并没有足够的深度可以挖掘，对个人的成长发展也可能会有限制。在这种情况下，我们可以主动去了解和学习其他领域的知识，也可以主动承担起更多的工作内容。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **童：\n\n> 以前一直用的是multirepo。最近想写个cli，确实想用现在很流行的monorepo项目管理方式，可能会再加lerna。没想到看到被删这篇文章也有提及~"考虑到这些逻辑已经存在 2 年多了，当时开发这些功能的小伙伴都不在了"，都不在了。。好惨\n\n# **航：\n\n> 对于多人协作开发的大型项目，难以避免就会有模块间的循环引用问题，请教一下这个问题目前有没有好的解决方案，除了把逻辑全包到一个方法里让它延迟执行以外',charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"如何通过前期准备和后期复盘让项目稳定上线",frontmatter:{title:"如何通过前期准备和后期复盘让项目稳定上线",date:"2022-04-23T14:47:16.000Z",permalink:"/pages/75d6fd/",categories:["前端","前端开发笔记"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/26.%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%92%8C%E5%90%8E%E6%9C%9F%E5%A4%8D%E7%9B%98%E8%AE%A9%E9%A1%B9%E7%9B%AE%E7%A8%B3%E5%AE%9A%E4%B8%8A%E7%BA%BF.html",relativePath:"01.前端/01.前端开发笔记/26.如何通过前期准备和后期复盘让项目稳定上线.md",key:"v-ea0cd796",path:"/pages/75d6fd/",headers:[{level:3,title:"精选评论",slug:"精选评论",normalizedTitle:"精选评论",charIndex:4311}],headersStr:"精选评论",content:"课程快接近尾声了，前面我也跟大家介绍了很多技术选型、从 0 开始建设前端项目的经验。今天，我想再跟大家聊一聊关于项目管理和项目复盘这件事情。\n\n日常工作中，我们常常会以项目的形式参与到具体的开发中，可能会负责项目的主导，或是作为核心开发负责某个模块、某个技术方案的落地。\n\n很多人会觉得做一个普通的前端项目，从开发到上线都没什么难度。一个字：“干”就完了。\n\n实际上，项目的管理、推动和落地是工作中不可或缺的能力，这不同于技术方案设计、代码编写，这属于工作中的软技能。但正是这样的软技能会对我们的工作成果产生很大影响，也会影响自身的成长速度，更是升职加薪的必备技能。\n\n在项目进行的每个阶段，我们都可以通过同样的方式去提升自己：预期→结果→复盘。我们来分别看下。\n\n\n事前\n\n就像在开发前进行架构设计一样重要，我们在项目开始前，需要对项目的整个过程进行初步的预估，包括：\n\n 1. 预期功能是否能实现？存在哪些不确定的功能？\n\n 2. 预计的工作量和分工排期是怎样的？\n\n 3. 每个阶段（开发、联调、产品体验、提测、发布）的时间点大概是怎样的？\n\n 4. 哪些工作涉及外部资源的依赖和对接（交互/设计/接口协议等），是否存在延期风险？\n\n 5. 如果存在风险，有没有什么方法可以避免？\n\n这么做有什么好处呢？我们来看个小故事。\n\n小明接到个新活，老板说现在的项目代码量很多，各个模块之间耦合相当严重，需要重构。\n\n这是个大活，小明接到之后就开始进行调研和设计。但是这么大规模的项目，又进行大规模重构的案例实在太少了，基本找不到可以直接借鉴的解决方案。于是，小明跟老板要了一周的时间，打算拉个分支边写 DEMO 边调整方案。\n\n这样的大重构，需要对各个模块做好充分调研，也需要对方案进行全面完整的风险评估，但小明觉得这根本就没法做到，太麻烦了，于是就想到哪写到哪。一周过去了，小明改好了一个模块，感觉这样改比较可行，于是跟老板要了三个月的完整改造期。\n\n一个月过去了，小明发现代码写到一半写不下去了，有几个模块不支持预期的改法，需要对方案进行大调整。接下来，项目从预期的三个月变成了四个月，四个月又拖到了半年，迟迟上线不了。老板对小明表示很失望，小明的绩效也跟着失望。\n\n或许在大家看来，小明做事太不靠谱了。实际上在我们的工作中，这样的情况常常会遇到，很多人甚至对需求延期都已经习以为常了，认为需求能准时上线才是稀奇的事情。正因为大家都是这样的想法，我们更应该把这些事情做好，这样才可以弯道超车。\n\n首先，在项目开始的时候，需要进行工作量评估和分工排期。\n\n如何进行合理的分工排期\n\n进行工作量评估的过程可以分为三步：\n\n 1. 确认技术方案，以及分工合作方式；\n\n 2. 拆分具体功能模块，分别进行工作量评估，输出具体的排期时间表；\n\n 3. 标注资源依赖情况和协作存在的风险，进行延期风险评估。\n\n当我们确认好技术方案之后，需要针对实现细节拆分具体的功能模块，分别进行工作量的预估和分工排期。否则可能面临分工不明确、接口协议未对齐就匆忙开工、最终因为各种问题而返工等情况。\n\n我们在进行工作量评估的时候，可以精确到半天的工作量预期。对独自开发的项目来说，同样可以通过拆解功能模块这个过程，来思考具体的实现方式，也能提前发现一些可能存在的问题，并相应地进行规避。\n\n提供完整的工作量评估和排期计划表（精确到具体的日期），可以帮助我们有计划地推进项目。在开发过程中，我们可以及时更新计划的执行情况，团队的其他人也可以了解我们的工作情况。\n\n工作量评估和排期计划表的另外一个重要作用，是通过时间线去严格约束我们的工作效率、及时发现问题，并在项目结束后可针对时间维度进行项目复盘。\n\n为了确保项目能按照预期进行，我们还要对可能存在的风险进行分析，提前做好对应的准备措施。\n\n对项目风险进行把控\n\n我们在项目开发过程中，经常会遇到这样的情况：\n\n * 因为方案设计考虑不周，部分工作需要返工，导致项目延期；\n\n * 在项目进行过程中，常常会遇到依赖资源无法及时给到、依赖方因为种种原因无法按时支援等问题，导致项目无法按计划进行；\n\n * 团队协作方式未对齐，开发过程中出现矛盾，反复的争执和调整协作方式导致项目延期。\n\n一个项目能按照预期计划进行，技术方案设计、分工和协作方式、依赖资源是否确定等，任何一个环节出现问题，都可能导致延误。因此，我们需要主动把控各个环节的情况，及时推动和解决一些多方协作的问题。\n\n下面我们来看一个详细的例子。\n\n小明接到一个需要带外包同学进行小程序开发的项目，张三听说了，就跟小明吐槽说之前也做过类似的项目，外包同学写的代码可乱了，最后交付的时候甚至都还有报错。\n\n换作是其他人，听了张三的话可能都开始泄气了，内心想着：这么麻烦的活，估计最后还得自己擦屁股。可小明不一样，他找到张三详细咨询了之前项目的一些情况，整理出来以下问题。\n\n\n\n小明分析了下，问题的确很多，但都是可预估的风险。为了避免同样的问题出现，小明特地做了一些前期的准备工作，并且最后达到了不错的使用效果。\n\n\n\n通过前期准备的这些方案和工具控制了很多可预见的风险，一期整个开发过程比较顺利，外包同学表示合作过程很愉悦，最终的交付质量也比预期好很多，连张三也拍手称好。\n\n在这个项目中，小明对可能存在的问题做了充分的调查，并提供了一系列的技术方案避免了问题的出现。但小明觉得这还不够，项目虽然成功上线了，但其实也出现了一些延期的情况。项目还要进行二期开发，于是小明决定要进行项目复盘，找到问题在哪。\n\n\n事后\n\n很多开发习惯了当代码开发完成、发布上线之后就结束了这个项目，其实他们遗漏了一个很重要的环节：复盘。\n\n对于大多数开发来说，很多时候都不屑于主动邀功，觉得自己做了些什么老板肯定都看在眼里，写什么总结和复盘都是刷存在感的表现。实际上老板们每天的事情很多，根本没法关注到每一个人，我以前也曾经跟老板们问过这样一个问题：做和说到底哪个重要？\n\n答案是两个都重要。把一件事做好是必须的，但将这件事分享出来，同样可以给团队带来更多的成长。\n\n通过对项目进行复盘，除了可以让团队其他人和老板知道我们做了些什么，更重要的是，我们可以及时发现自身的一些问题并改进。\n\n及时反馈与复盘\n\n小明在一期的项目结束后，整理了这次开发过程中存在的问题。\n\n * 外包同学开发效率上问题不大，项目延期主要原因整理如下。\n   \n   * 等待后台接口可联调时间比预期要长\n   \n   * 产品对接问题：提供资源、体验产品不够及时，需求描述不够详细\n   \n   * 过程中存在需求变更，主要体现在设计和交互调整\n\n * 沟通上，外包同学态度比较积极，反馈及时，但还可以改进的地方如下。\n   \n   * 每日、每周工作进度及时做总结和汇总。\n   \n   * 对产品设计和体验的合理性可具备有一定的思考，主动发现问题、提出问题、解决问题。\n   \n   * 开发风格不一致，导致部分问题如下：过度抽象、逻辑管理较乱、变量类型混乱、重复代码过多。\n\n既然发现问题了，就需要进行解决。为此，小明及时与外包同学进行交流后，对方已调整和优化大部分代码，也更加主动积极地进行反馈。\n\n项目结束后，小明还收集了外包同学的一些建议和反馈。\n\n * 该项目过程的一些优点。\n   \n   * 初始化时提供的代码大大减少了搭建环境的时间，部分功能模块也得到了复用，对开发速度有很大帮助\n   \n   * 项目相关文档很细，降低了不少沟通成本\n   \n   * 项目开发过程中，外包同学成长很多，也知道了之前存在的一些问题\n\n * 对该项目的一些建议。\n   \n   * 代码规范：外包同学希望负责人（小明）能提供一份前端代码规范\n   \n   * 分工：外包同学负责业务相关页面开发，负责人（小明）负责提供基础框架和工具库\n   \n   * 视觉还原：外包同学大部分都是编程方向的，对 UI 理解不深，如果希望高度还原或者想做细致的交互，需要在开发前特别提醒\n\n小明梳理了这些内容，打算通过邮件的方式发送给团队以及合作方，同时还可以作为自身的经验沉淀，在后续更多项目中可以进行参考。但是只有这些纯文字内容的输出，似乎除了作为后续项目的参考之外，比较难作为这次项目的复盘结果。所以小明决定，要用数据说话。\n\n\n用数据说话\n\n性能优化的工作可以用具体的耗时和 CPU 资源占用这些数据来做总结，工具的开发可以用接入使用的用户数量来说明效果，这种普普通通的项目上线，又该怎么表达呢？\n\n前面说过，这次带外包同学进行开发的项目一共分成了两期，第一期开发的时候依然存在一些问题导致延期。小明整理的具体的延期数据如下。\n\n\n\n复盘的作用在于可以避免下一次出现同样的问题。于是在二期开发的时候，小明通过一些对策来避免这些问题，例如：\n\n * 开发评估项目预留多一些 buffer；\n\n * 对涉及多方合作的项目，开发负责人（小明）需多预留些 buffer；\n\n * 如果希望高度还原或者想做细致的交互，提前告知外包同学；\n\n * 体验过程中，对开发、体验问题及时反馈；\n\n * 把控需求文档质量，完善交互细节，才给到外包同学进行开发；\n\n * 开发者需预留足够的自测时间，对正常路径、异常路径都完成充分自测。\n\n通过这些对策，二期开发的时候成功地避免了同样的问题。小明以时间线的方式对比了两期的开发时间结果。\n\n\n\n除了时间维度，小明还通过质量的维度来对比两期的开发情况。\n\n\n\n通过这些数据，再加上前面的问题整理和反馈结果收集，结合前期的准备工作和解决方案，小明将项目的复盘结果输出给团队，大家纷纷表示赞赏。\n\n所以，为什么项目复盘很重要呢？小明来给大家总结下：\n\n 1. 及时发现自己的问题并改进，避免掉进同一个坑；\n\n 2. 让团队成员和管理者知道自己在做什么；\n\n 3. 整理沉淀和分享项目经验，让整个团队都得到成长。\n\n\n小结\n\n对于大部分前端开发来说，接触工具和框架开发、参与开源项目的机会比较少，很多时候我们写的都是“枯燥无聊”的业务代码。我们总认为只有做工具才会比较有意思、有技术挑战，很多时候会先入为主，认为业务代码写得再好也没用，也渐渐放弃思考要怎么把事情做好。\n\n大家可以尝试对最近做的项目或是事情进行复盘，在这个过程中如果遇到了什么问题，欢迎在留言区进行交流。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **童：\n\n> 举的例子好真实。。小明仿佛就是我自己。。不，小明是贝珊，不是我才对。。\n\n# console_man：\n\n> 小明真厉害\n\n# *宇：\n\n> 好的，王·小明·贝珊",normalizedContent:"课程快接近尾声了，前面我也跟大家介绍了很多技术选型、从 0 开始建设前端项目的经验。今天，我想再跟大家聊一聊关于项目管理和项目复盘这件事情。\n\n日常工作中，我们常常会以项目的形式参与到具体的开发中，可能会负责项目的主导，或是作为核心开发负责某个模块、某个技术方案的落地。\n\n很多人会觉得做一个普通的前端项目，从开发到上线都没什么难度。一个字：“干”就完了。\n\n实际上，项目的管理、推动和落地是工作中不可或缺的能力，这不同于技术方案设计、代码编写，这属于工作中的软技能。但正是这样的软技能会对我们的工作成果产生很大影响，也会影响自身的成长速度，更是升职加薪的必备技能。\n\n在项目进行的每个阶段，我们都可以通过同样的方式去提升自己：预期→结果→复盘。我们来分别看下。\n\n\n事前\n\n就像在开发前进行架构设计一样重要，我们在项目开始前，需要对项目的整个过程进行初步的预估，包括：\n\n 1. 预期功能是否能实现？存在哪些不确定的功能？\n\n 2. 预计的工作量和分工排期是怎样的？\n\n 3. 每个阶段（开发、联调、产品体验、提测、发布）的时间点大概是怎样的？\n\n 4. 哪些工作涉及外部资源的依赖和对接（交互/设计/接口协议等），是否存在延期风险？\n\n 5. 如果存在风险，有没有什么方法可以避免？\n\n这么做有什么好处呢？我们来看个小故事。\n\n小明接到个新活，老板说现在的项目代码量很多，各个模块之间耦合相当严重，需要重构。\n\n这是个大活，小明接到之后就开始进行调研和设计。但是这么大规模的项目，又进行大规模重构的案例实在太少了，基本找不到可以直接借鉴的解决方案。于是，小明跟老板要了一周的时间，打算拉个分支边写 demo 边调整方案。\n\n这样的大重构，需要对各个模块做好充分调研，也需要对方案进行全面完整的风险评估，但小明觉得这根本就没法做到，太麻烦了，于是就想到哪写到哪。一周过去了，小明改好了一个模块，感觉这样改比较可行，于是跟老板要了三个月的完整改造期。\n\n一个月过去了，小明发现代码写到一半写不下去了，有几个模块不支持预期的改法，需要对方案进行大调整。接下来，项目从预期的三个月变成了四个月，四个月又拖到了半年，迟迟上线不了。老板对小明表示很失望，小明的绩效也跟着失望。\n\n或许在大家看来，小明做事太不靠谱了。实际上在我们的工作中，这样的情况常常会遇到，很多人甚至对需求延期都已经习以为常了，认为需求能准时上线才是稀奇的事情。正因为大家都是这样的想法，我们更应该把这些事情做好，这样才可以弯道超车。\n\n首先，在项目开始的时候，需要进行工作量评估和分工排期。\n\n如何进行合理的分工排期\n\n进行工作量评估的过程可以分为三步：\n\n 1. 确认技术方案，以及分工合作方式；\n\n 2. 拆分具体功能模块，分别进行工作量评估，输出具体的排期时间表；\n\n 3. 标注资源依赖情况和协作存在的风险，进行延期风险评估。\n\n当我们确认好技术方案之后，需要针对实现细节拆分具体的功能模块，分别进行工作量的预估和分工排期。否则可能面临分工不明确、接口协议未对齐就匆忙开工、最终因为各种问题而返工等情况。\n\n我们在进行工作量评估的时候，可以精确到半天的工作量预期。对独自开发的项目来说，同样可以通过拆解功能模块这个过程，来思考具体的实现方式，也能提前发现一些可能存在的问题，并相应地进行规避。\n\n提供完整的工作量评估和排期计划表（精确到具体的日期），可以帮助我们有计划地推进项目。在开发过程中，我们可以及时更新计划的执行情况，团队的其他人也可以了解我们的工作情况。\n\n工作量评估和排期计划表的另外一个重要作用，是通过时间线去严格约束我们的工作效率、及时发现问题，并在项目结束后可针对时间维度进行项目复盘。\n\n为了确保项目能按照预期进行，我们还要对可能存在的风险进行分析，提前做好对应的准备措施。\n\n对项目风险进行把控\n\n我们在项目开发过程中，经常会遇到这样的情况：\n\n * 因为方案设计考虑不周，部分工作需要返工，导致项目延期；\n\n * 在项目进行过程中，常常会遇到依赖资源无法及时给到、依赖方因为种种原因无法按时支援等问题，导致项目无法按计划进行；\n\n * 团队协作方式未对齐，开发过程中出现矛盾，反复的争执和调整协作方式导致项目延期。\n\n一个项目能按照预期计划进行，技术方案设计、分工和协作方式、依赖资源是否确定等，任何一个环节出现问题，都可能导致延误。因此，我们需要主动把控各个环节的情况，及时推动和解决一些多方协作的问题。\n\n下面我们来看一个详细的例子。\n\n小明接到一个需要带外包同学进行小程序开发的项目，张三听说了，就跟小明吐槽说之前也做过类似的项目，外包同学写的代码可乱了，最后交付的时候甚至都还有报错。\n\n换作是其他人，听了张三的话可能都开始泄气了，内心想着：这么麻烦的活，估计最后还得自己擦屁股。可小明不一样，他找到张三详细咨询了之前项目的一些情况，整理出来以下问题。\n\n\n\n小明分析了下，问题的确很多，但都是可预估的风险。为了避免同样的问题出现，小明特地做了一些前期的准备工作，并且最后达到了不错的使用效果。\n\n\n\n通过前期准备的这些方案和工具控制了很多可预见的风险，一期整个开发过程比较顺利，外包同学表示合作过程很愉悦，最终的交付质量也比预期好很多，连张三也拍手称好。\n\n在这个项目中，小明对可能存在的问题做了充分的调查，并提供了一系列的技术方案避免了问题的出现。但小明觉得这还不够，项目虽然成功上线了，但其实也出现了一些延期的情况。项目还要进行二期开发，于是小明决定要进行项目复盘，找到问题在哪。\n\n\n事后\n\n很多开发习惯了当代码开发完成、发布上线之后就结束了这个项目，其实他们遗漏了一个很重要的环节：复盘。\n\n对于大多数开发来说，很多时候都不屑于主动邀功，觉得自己做了些什么老板肯定都看在眼里，写什么总结和复盘都是刷存在感的表现。实际上老板们每天的事情很多，根本没法关注到每一个人，我以前也曾经跟老板们问过这样一个问题：做和说到底哪个重要？\n\n答案是两个都重要。把一件事做好是必须的，但将这件事分享出来，同样可以给团队带来更多的成长。\n\n通过对项目进行复盘，除了可以让团队其他人和老板知道我们做了些什么，更重要的是，我们可以及时发现自身的一些问题并改进。\n\n及时反馈与复盘\n\n小明在一期的项目结束后，整理了这次开发过程中存在的问题。\n\n * 外包同学开发效率上问题不大，项目延期主要原因整理如下。\n   \n   * 等待后台接口可联调时间比预期要长\n   \n   * 产品对接问题：提供资源、体验产品不够及时，需求描述不够详细\n   \n   * 过程中存在需求变更，主要体现在设计和交互调整\n\n * 沟通上，外包同学态度比较积极，反馈及时，但还可以改进的地方如下。\n   \n   * 每日、每周工作进度及时做总结和汇总。\n   \n   * 对产品设计和体验的合理性可具备有一定的思考，主动发现问题、提出问题、解决问题。\n   \n   * 开发风格不一致，导致部分问题如下：过度抽象、逻辑管理较乱、变量类型混乱、重复代码过多。\n\n既然发现问题了，就需要进行解决。为此，小明及时与外包同学进行交流后，对方已调整和优化大部分代码，也更加主动积极地进行反馈。\n\n项目结束后，小明还收集了外包同学的一些建议和反馈。\n\n * 该项目过程的一些优点。\n   \n   * 初始化时提供的代码大大减少了搭建环境的时间，部分功能模块也得到了复用，对开发速度有很大帮助\n   \n   * 项目相关文档很细，降低了不少沟通成本\n   \n   * 项目开发过程中，外包同学成长很多，也知道了之前存在的一些问题\n\n * 对该项目的一些建议。\n   \n   * 代码规范：外包同学希望负责人（小明）能提供一份前端代码规范\n   \n   * 分工：外包同学负责业务相关页面开发，负责人（小明）负责提供基础框架和工具库\n   \n   * 视觉还原：外包同学大部分都是编程方向的，对 ui 理解不深，如果希望高度还原或者想做细致的交互，需要在开发前特别提醒\n\n小明梳理了这些内容，打算通过邮件的方式发送给团队以及合作方，同时还可以作为自身的经验沉淀，在后续更多项目中可以进行参考。但是只有这些纯文字内容的输出，似乎除了作为后续项目的参考之外，比较难作为这次项目的复盘结果。所以小明决定，要用数据说话。\n\n\n用数据说话\n\n性能优化的工作可以用具体的耗时和 cpu 资源占用这些数据来做总结，工具的开发可以用接入使用的用户数量来说明效果，这种普普通通的项目上线，又该怎么表达呢？\n\n前面说过，这次带外包同学进行开发的项目一共分成了两期，第一期开发的时候依然存在一些问题导致延期。小明整理的具体的延期数据如下。\n\n\n\n复盘的作用在于可以避免下一次出现同样的问题。于是在二期开发的时候，小明通过一些对策来避免这些问题，例如：\n\n * 开发评估项目预留多一些 buffer；\n\n * 对涉及多方合作的项目，开发负责人（小明）需多预留些 buffer；\n\n * 如果希望高度还原或者想做细致的交互，提前告知外包同学；\n\n * 体验过程中，对开发、体验问题及时反馈；\n\n * 把控需求文档质量，完善交互细节，才给到外包同学进行开发；\n\n * 开发者需预留足够的自测时间，对正常路径、异常路径都完成充分自测。\n\n通过这些对策，二期开发的时候成功地避免了同样的问题。小明以时间线的方式对比了两期的开发时间结果。\n\n\n\n除了时间维度，小明还通过质量的维度来对比两期的开发情况。\n\n\n\n通过这些数据，再加上前面的问题整理和反馈结果收集，结合前期的准备工作和解决方案，小明将项目的复盘结果输出给团队，大家纷纷表示赞赏。\n\n所以，为什么项目复盘很重要呢？小明来给大家总结下：\n\n 1. 及时发现自己的问题并改进，避免掉进同一个坑；\n\n 2. 让团队成员和管理者知道自己在做什么；\n\n 3. 整理沉淀和分享项目经验，让整个团队都得到成长。\n\n\n小结\n\n对于大部分前端开发来说，接触工具和框架开发、参与开源项目的机会比较少，很多时候我们写的都是“枯燥无聊”的业务代码。我们总认为只有做工具才会比较有意思、有技术挑战，很多时候会先入为主，认为业务代码写得再好也没用，也渐渐放弃思考要怎么把事情做好。\n\n大家可以尝试对最近做的项目或是事情进行复盘，在这个过程中如果遇到了什么问题，欢迎在留言区进行交流。\n\n----------------------------------------\n\n\n# 精选评论\n\n# **童：\n\n> 举的例子好真实。。小明仿佛就是我自己。。不，小明是贝珊，不是我才对。。\n\n# console_man：\n\n> 小明真厉害\n\n# *宇：\n\n> 好的，王·小明·贝珊",charsets:{cjk:!0},lastUpdated:"2022/04/23, 06:56:29",lastUpdatedTimestamp:1650696989e3},{title:"33个非常实用的JavaScript一行代码",frontmatter:{title:"33个非常实用的JavaScript一行代码",date:"2021-11-02T09:51:37.000Z",permalink:"/pages/a61298/",categories:["前端","JavaScript文章"],tags:["JavaScript"],author:"CUGGZ"},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/01.33%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81.html",relativePath:"01.前端/25.JavaScript/01.33个非常实用的JavaScript一行代码.md",key:"v-19777b50",path:"/pages/a61298/",headers:[{level:2,title:"一、日期处理",slug:"一、日期处理",normalizedTitle:"一、日期处理",charIndex:2},{level:3,title:"1. 检察日期是否有效",slug:"_1-检察日期是否有效",normalizedTitle:"1. 检察日期是否有效",charIndex:13},{level:3,title:"2. 计算两个日期之间的间隔",slug:"_2-计算两个日期之间的间隔",normalizedTitle:"2. 计算两个日期之间的间隔",charIndex:193},{level:3,title:"3. 查找日期位于一年中的第几天",slug:"_3-查找日期位于一年中的第几天",normalizedTitle:"3. 查找日期位于一年中的第几天",charIndex:421},{level:3,title:"4. 时间格式化",slug:"_4-时间格式化",normalizedTitle:"4. 时间格式化",charIndex:640},{level:2,title:"二、字符串处理",slug:"二、字符串处理",normalizedTitle:"二、字符串处理",charIndex:881},{level:3,title:"1. 字符串首字母大写",slug:"_1-字符串首字母大写",normalizedTitle:"1. 字符串首字母大写",charIndex:893},{level:3,title:"2. 翻转字符串",slug:"_2-翻转字符串",normalizedTitle:"2. 翻转字符串",charIndex:1060},{level:3,title:"3. 随机字符串",slug:"_3-随机字符串",normalizedTitle:"3. 随机字符串",charIndex:1221},{level:3,title:"4. 截断字符串",slug:"_4-截断字符串",normalizedTitle:"4. 截断字符串",charIndex:1350},{level:3,title:"5. 去除字符串中的HTML",slug:"_5-去除字符串中的html",normalizedTitle:"5. 去除字符串中的html",charIndex:1632},{level:2,title:"三、数组处理",slug:"三、数组处理",normalizedTitle:"三、数组处理",charIndex:1788},{level:3,title:"1. 从数组中移除重复项",slug:"_1-从数组中移除重复项",normalizedTitle:"1. 从数组中移除重复项",charIndex:1799},{level:3,title:"2. 判断数组是否为空",slug:"_2-判断数组是否为空",normalizedTitle:"2. 判断数组是否为空",charIndex:1967},{level:3,title:"3. 合并两个数组",slug:"_3-合并两个数组",normalizedTitle:"3. 合并两个数组",charIndex:2127},{level:2,title:"四、数字操作",slug:"四、数字操作",normalizedTitle:"四、数字操作",charIndex:2254},{level:3,title:"1. 判断一个数是奇数还是偶数",slug:"_1-判断一个数是奇数还是偶数",normalizedTitle:"1. 判断一个数是奇数还是偶数",charIndex:2265},{level:3,title:"2. 获得一组数的平均值",slug:"_2-获得一组数的平均值",normalizedTitle:"2. 获得一组数的平均值",charIndex:2374},{level:3,title:"3. 获取两个整数之间的随机整数",slug:"_3-获取两个整数之间的随机整数",normalizedTitle:"3. 获取两个整数之间的随机整数",charIndex:2513},{level:3,title:"4. 指定位数四舍五入",slug:"_4-指定位数四舍五入",normalizedTitle:"4. 指定位数四舍五入",charIndex:2667},{level:2,title:"五、颜色操作",slug:"五、颜色操作",normalizedTitle:"五、颜色操作",charIndex:2840},{level:3,title:"1. 将RGB转化为十六机制",slug:"_1-将rgb转化为十六机制",normalizedTitle:"1. 将rgb转化为十六机制",charIndex:2851},{level:3,title:"2. 获取随机十六进制颜色",slug:"_2-获取随机十六进制颜色",normalizedTitle:"2. 获取随机十六进制颜色",charIndex:3051},{level:2,title:"六、浏览器操作",slug:"六、浏览器操作",normalizedTitle:"六、浏览器操作",charIndex:3218},{level:3,title:"1. 复制内容到剪切板",slug:"_1-复制内容到剪切板",normalizedTitle:"1. 复制内容到剪切板",charIndex:3230},{level:3,title:"2. 清除所有cookie",slug:"_2-清除所有cookie",normalizedTitle:"2. 清除所有cookie",charIndex:3418},{level:3,title:"3. 获取选中的文本",slug:"_3-获取选中的文本",normalizedTitle:"3. 获取选中的文本",charIndex:3684},{level:3,title:"4. 检测是否是黑暗模式",slug:"_4-检测是否是黑暗模式",normalizedTitle:"4. 检测是否是黑暗模式",charIndex:3836},{level:3,title:"5. 滚动到页面顶部",slug:"_5-滚动到页面顶部",normalizedTitle:"5. 滚动到页面顶部",charIndex:4023},{level:3,title:"6. 判断当前标签页是否激活",slug:"_6-判断当前标签页是否激活",normalizedTitle:"6. 判断当前标签页是否激活",charIndex:4128},{level:3,title:"7. 判断当前是否是苹果设备",slug:"_7-判断当前是否是苹果设备",normalizedTitle:"7. 判断当前是否是苹果设备",charIndex:4225},{level:3,title:"8. 是否滚动到页面底部",slug:"_8-是否滚动到页面底部",normalizedTitle:"8. 是否滚动到页面底部",charIndex:4379},{level:3,title:"9. 重定向到一个URL",slug:"_9-重定向到一个url",normalizedTitle:"9. 重定向到一个url",charIndex:4555},{level:3,title:"10. 打开浏览器打印框",slug:"_10-打开浏览器打印框",normalizedTitle:"10. 打开浏览器打印框",charIndex:4689},{level:2,title:"七、其他操作",slug:"七、其他操作",normalizedTitle:"七、其他操作",charIndex:4781},{level:3,title:"1. 随机布尔值",slug:"_1-随机布尔值",normalizedTitle:"1. 随机布尔值",charIndex:4792},{level:3,title:"2. 变量交换",slug:"_2-变量交换",normalizedTitle:"2. 变量交换",charIndex:4960},{level:3,title:"3. 获取变量的类型",slug:"_3-获取变量的类型",normalizedTitle:"3. 获取变量的类型",charIndex:5043},{level:3,title:"4. 华氏度和摄氏度之间的转化",slug:"_4-华氏度和摄氏度之间的转化",normalizedTitle:"4. 华氏度和摄氏度之间的转化",charIndex:5446},{level:3,title:"5. 检测对象是否为空",slug:"_5-检测对象是否为空",normalizedTitle:"5. 检测对象是否为空",charIndex:5813}],headersStr:"一、日期处理 1. 检察日期是否有效 2. 计算两个日期之间的间隔 3. 查找日期位于一年中的第几天 4. 时间格式化 二、字符串处理 1. 字符串首字母大写 2. 翻转字符串 3. 随机字符串 4. 截断字符串 5. 去除字符串中的HTML 三、数组处理 1. 从数组中移除重复项 2. 判断数组是否为空 3. 合并两个数组 四、数字操作 1. 判断一个数是奇数还是偶数 2. 获得一组数的平均值 3. 获取两个整数之间的随机整数 4. 指定位数四舍五入 五、颜色操作 1. 将RGB转化为十六机制 2. 获取随机十六进制颜色 六、浏览器操作 1. 复制内容到剪切板 2. 清除所有cookie 3. 获取选中的文本 4. 检测是否是黑暗模式 5. 滚动到页面顶部 6. 判断当前标签页是否激活 7. 判断当前是否是苹果设备 8. 是否滚动到页面底部 9. 重定向到一个URL 10. 打开浏览器打印框 七、其他操作 1. 随机布尔值 2. 变量交换 3. 获取变量的类型 4. 华氏度和摄氏度之间的转化 5. 检测对象是否为空",content:"# 一、日期处理\n\n\n# 1. 检察日期是否有效\n\n该方法用于检测给出的日期是否有效：\n\nconst isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());\n\nisDateValid(\"December 17, 1995 03:24:00\");  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 计算两个日期之间的间隔\n\n该方法用于计算两个日期之间的间隔时间：\n\nconst dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\n\ndayDif(new Date(\"2021-11-3\"), new Date(\"2022-2-1\"))  // 90\n复制代码\n\n\n1\n2\n3\n4\n\n\n距离过年还有90天~\n\n\n# 3. 查找日期位于一年中的第几天\n\n该方法用于检测给出的日期位于今年的第几天：\n\nconst dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayOfYear(new Date());   // 307\n复制代码\n\n\n1\n2\n3\n4\n\n\n2021年已经过去300多天了~\n\n\n# 4. 时间格式化\n\n该方法可以用于将时间转化为hour:minutes:seconds的格式：\n\nconst timeFromDate = date => date.toTimeString().slice(0, 8);\n\ntimeFromDate(new Date(2021, 11, 2, 12, 30, 0));  // 12:30:00\ntimeFromDate(new Date());  // 返回当前时间 09:00:00\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 二、字符串处理\n\n\n# 1. 字符串首字母大写\n\n该方法用于将英文字符串的首字母大写处理：\n\nconst capitalize = str => str.charAt(0).toUpperCase() + str.slice(1)\n\ncapitalize(\"hello world\")  // Hello world\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 翻转字符串\n\n该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\nconst reverse = str => str.split('').reverse().join('');\n\nreverse('hello world');   // 'dlrow olleh'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 随机字符串\n\n该方法用于生成一个随机的字符串：\n\nconst randomString = () => Math.random().toString(36).slice(2);\n\nrandomString();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 截断字符串\n\n该方法可以从指定长度处截断字符串:\n\nconst truncateString = (string, length) => string.length < length ? string : `${string.slice(0, length - 3)}...`;\n\ntruncateString('Hi, I should be truncated because I am too loooong!', 36)   // 'Hi, I should be truncated because...'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 去除字符串中的HTML\n\n该方法用于去除字符串中的HTML元素：\n\nconst stripHtml = html => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || '';\n复制代码\n\n\n1\n2\n\n\n\n# 三、数组处理\n\n\n# 1. 从数组中移除重复项\n\n该方法用于移除数组中的重复项：\n\nconst removeDuplicates = (arr) => [...new Set(arr)];\n\nconsole.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 判断数组是否为空\n\n该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\nconst isNotEmpty = arr => Array.isArray(arr) && arr.length > 0;\n\nisNotEmpty([1, 2, 3]);  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 合并两个数组\n\n可以使用下面两个方法来合并两个数组：\n\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 四、数字操作\n\n\n# 1. 判断一个数是奇数还是偶数\n\n该方法用于判断一个数字是奇数还是偶数：\n\nconst isEven = num => num % 2 === 0;\n\nisEven(996);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获得一组数的平均值\n\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5);   // 3\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 获取两个整数之间的随机整数\n\n该方法用于获取两个整数之间的随机整数\n\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 指定位数四舍五入\n\n该方法用于将一个数字按照指定位进行四舍五入：\n\nconst round = (n, d) => Number(Math.round(n + \"e\" + d) + \"e-\" + d)\n\nround(1.005, 2) //1.01\nround(1.555, 2) //1.56\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 五、颜色操作\n\n\n# 1. 将RGB转化为十六机制\n\n该方法可以将一个RGB的颜色值转化为16进制值：\n\nconst rgbToHex = (r, g, b) => \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\nrgbToHex(255, 255, 255);  // '#ffffff'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获取随机十六进制颜色\n\n该方法用于获取一个随机的十六进制颜色值：\n\nconst randomHex = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}`;\n\nrandomHex();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 六、浏览器操作\n\n\n# 1. 复制内容到剪切板\n\n该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：\n\nconst copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\ncopyToClipboard(\"Hello World\");\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 清除所有cookie\n\n该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\nconst clearCookies = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`));\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取选中的文本\n\n该方法通过内置的 getSelection 属性获取用户选择的文本：\n\nconst getSelectedText = () => window.getSelection().toString();\n\ngetSelectedText();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 检测是否是黑暗模式\n\n该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：\n\nconst isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches\n\nconsole.log(isDarkMode)\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 滚动到页面顶部\n\n该方法用于在页面中返回顶部：\n\nconst goToTop = () => window.scrollTo(0, 0);\n\ngoToTop();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 6. 判断当前标签页是否激活\n\n该方法用于检测当前标签页是否已经激活：\n\nconst isTabInView = () => !document.hidden;\n复制代码\n\n\n1\n2\n\n\n\n# 7. 判断当前是否是苹果设备\n\n该方法用于检测当前的设备是否是苹果的设备：\n\nconst isAppleDevice = () => /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n\nisAppleDevice();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 8. 是否滚动到页面底部\n\n该方法用于判断页面是否已经底部：\n\nconst scrolledToBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n复制代码\n\n\n1\n2\n\n\n\n# 9. 重定向到一个URL\n\n该方法用于重定向到一个新的URL：\n\nconst redirect = url => location.href = url\n\nredirect(\"https://www.google.com/\")\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 10. 打开浏览器打印框\n\n该方法用于打开浏览器的打印框：\n\nconst showPrintDialog = () => window.print()\n复制代码\n\n\n1\n2\n\n\n\n# 七、其他操作\n\n\n# 1. 随机布尔值\n\n该方法可以返回一个随机的布尔值，使用Math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。\n\nconst randomBoolean = () => Math.random() >= 0.5;\n\nrandomBoolean();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 变量交换\n\n可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：\n\n[foo, bar] = [bar, foo];\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取变量的类型\n\n该方法用于获取一个变量的类型：\n\nconst trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n\ntrueTypeOf('');     // string\ntrueTypeOf(0);      // number\ntrueTypeOf();       // undefined\ntrueTypeOf(null);   // null\ntrueTypeOf({});     // object\ntrueTypeOf([]);     // array\ntrueTypeOf(0);      // number\ntrueTypeOf(() => {});  // function\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4. 华氏度和摄氏度之间的转化\n\n该方法用于摄氏度和华氏度之间的转化：\n\nconst celsiusToFahrenheit = (celsius) => celsius * 9/5 + 32;\nconst fahrenheitToCelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;\n\ncelsiusToFahrenheit(15);    // 59\ncelsiusToFahrenheit(0);     // 32\ncelsiusToFahrenheit(-20);   // -4\nfahrenheitToCelsius(59);    // 15\nfahrenheitToCelsius(32);    // 0\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5. 检测对象是否为空\n\n该方法用于检测一个JavaScript对象是否为空：\n\nconst isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;\n复制代码\n\n\n1\n2\n\n\n> 作者：CUGGZ 链接：https://juejin.cn/post/7025771605422768159",normalizedContent:"# 一、日期处理\n\n\n# 1. 检察日期是否有效\n\n该方法用于检测给出的日期是否有效：\n\nconst isdatevalid = (...val) => !number.isnan(new date(...val).valueof());\n\nisdatevalid(\"december 17, 1995 03:24:00\");  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 计算两个日期之间的间隔\n\n该方法用于计算两个日期之间的间隔时间：\n\nconst daydif = (date1, date2) => math.ceil(math.abs(date1.gettime() - date2.gettime()) / 86400000)\n\ndaydif(new date(\"2021-11-3\"), new date(\"2022-2-1\"))  // 90\n复制代码\n\n\n1\n2\n3\n4\n\n\n距离过年还有90天~\n\n\n# 3. 查找日期位于一年中的第几天\n\n该方法用于检测给出的日期位于今年的第几天：\n\nconst dayofyear = (date) => math.floor((date - new date(date.getfullyear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayofyear(new date());   // 307\n复制代码\n\n\n1\n2\n3\n4\n\n\n2021年已经过去300多天了~\n\n\n# 4. 时间格式化\n\n该方法可以用于将时间转化为hour:minutes:seconds的格式：\n\nconst timefromdate = date => date.totimestring().slice(0, 8);\n\ntimefromdate(new date(2021, 11, 2, 12, 30, 0));  // 12:30:00\ntimefromdate(new date());  // 返回当前时间 09:00:00\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 二、字符串处理\n\n\n# 1. 字符串首字母大写\n\n该方法用于将英文字符串的首字母大写处理：\n\nconst capitalize = str => str.charat(0).touppercase() + str.slice(1)\n\ncapitalize(\"hello world\")  // hello world\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 翻转字符串\n\n该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\nconst reverse = str => str.split('').reverse().join('');\n\nreverse('hello world');   // 'dlrow olleh'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 随机字符串\n\n该方法用于生成一个随机的字符串：\n\nconst randomstring = () => math.random().tostring(36).slice(2);\n\nrandomstring();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 截断字符串\n\n该方法可以从指定长度处截断字符串:\n\nconst truncatestring = (string, length) => string.length < length ? string : `${string.slice(0, length - 3)}...`;\n\ntruncatestring('hi, i should be truncated because i am too loooong!', 36)   // 'hi, i should be truncated because...'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 去除字符串中的html\n\n该方法用于去除字符串中的html元素：\n\nconst striphtml = html => (new domparser().parsefromstring(html, 'text/html')).body.textcontent || '';\n复制代码\n\n\n1\n2\n\n\n\n# 三、数组处理\n\n\n# 1. 从数组中移除重复项\n\n该方法用于移除数组中的重复项：\n\nconst removeduplicates = (arr) => [...new set(arr)];\n\nconsole.log(removeduplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 判断数组是否为空\n\n该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\nconst isnotempty = arr => array.isarray(arr) && arr.length > 0;\n\nisnotempty([1, 2, 3]);  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 合并两个数组\n\n可以使用下面两个方法来合并两个数组：\n\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 四、数字操作\n\n\n# 1. 判断一个数是奇数还是偶数\n\n该方法用于判断一个数字是奇数还是偶数：\n\nconst iseven = num => num % 2 === 0;\n\niseven(996);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获得一组数的平均值\n\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5);   // 3\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 获取两个整数之间的随机整数\n\n该方法用于获取两个整数之间的随机整数\n\nconst random = (min, max) => math.floor(math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 指定位数四舍五入\n\n该方法用于将一个数字按照指定位进行四舍五入：\n\nconst round = (n, d) => number(math.round(n + \"e\" + d) + \"e-\" + d)\n\nround(1.005, 2) //1.01\nround(1.555, 2) //1.56\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 五、颜色操作\n\n\n# 1. 将rgb转化为十六机制\n\n该方法可以将一个rgb的颜色值转化为16进制值：\n\nconst rgbtohex = (r, g, b) => \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).tostring(16).slice(1);\n\nrgbtohex(255, 255, 255);  // '#ffffff'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获取随机十六进制颜色\n\n该方法用于获取一个随机的十六进制颜色值：\n\nconst randomhex = () => `#${math.floor(math.random() * 0xffffff).tostring(16).padend(6, \"0\")}`;\n\nrandomhex();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 六、浏览器操作\n\n\n# 1. 复制内容到剪切板\n\n该方法使用 navigator.clipboard.writetext 来实现将文本复制到剪贴板：\n\nconst copytoclipboard = (text) => navigator.clipboard.writetext(text);\n\ncopytoclipboard(\"hello world\");\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 清除所有cookie\n\n该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\nconst clearcookies = document.cookie.split(';').foreach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new date(0).toutcstring()};path=/`));\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取选中的文本\n\n该方法通过内置的 getselection 属性获取用户选择的文本：\n\nconst getselectedtext = () => window.getselection().tostring();\n\ngetselectedtext();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 检测是否是黑暗模式\n\n该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：\n\nconst isdarkmode = window.matchmedia && window.matchmedia('(prefers-color-scheme: dark)').matches\n\nconsole.log(isdarkmode)\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 滚动到页面顶部\n\n该方法用于在页面中返回顶部：\n\nconst gototop = () => window.scrollto(0, 0);\n\ngototop();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 6. 判断当前标签页是否激活\n\n该方法用于检测当前标签页是否已经激活：\n\nconst istabinview = () => !document.hidden;\n复制代码\n\n\n1\n2\n\n\n\n# 7. 判断当前是否是苹果设备\n\n该方法用于检测当前的设备是否是苹果的设备：\n\nconst isappledevice = () => /mac|ipod|iphone|ipad/.test(navigator.platform);\n\nisappledevice();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 8. 是否滚动到页面底部\n\n该方法用于判断页面是否已经底部：\n\nconst scrolledtobottom = () => document.documentelement.clientheight + window.scrolly >= document.documentelement.scrollheight;\n复制代码\n\n\n1\n2\n\n\n\n# 9. 重定向到一个url\n\n该方法用于重定向到一个新的url：\n\nconst redirect = url => location.href = url\n\nredirect(\"https://www.google.com/\")\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 10. 打开浏览器打印框\n\n该方法用于打开浏览器的打印框：\n\nconst showprintdialog = () => window.print()\n复制代码\n\n\n1\n2\n\n\n\n# 七、其他操作\n\n\n# 1. 随机布尔值\n\n该方法可以返回一个随机的布尔值，使用math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。\n\nconst randomboolean = () => math.random() >= 0.5;\n\nrandomboolean();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 变量交换\n\n可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：\n\n[foo, bar] = [bar, foo];\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取变量的类型\n\n该方法用于获取一个变量的类型：\n\nconst truetypeof = (obj) => object.prototype.tostring.call(obj).slice(8, -1).tolowercase();\n\ntruetypeof('');     // string\ntruetypeof(0);      // number\ntruetypeof();       // undefined\ntruetypeof(null);   // null\ntruetypeof({});     // object\ntruetypeof([]);     // array\ntruetypeof(0);      // number\ntruetypeof(() => {});  // function\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4. 华氏度和摄氏度之间的转化\n\n该方法用于摄氏度和华氏度之间的转化：\n\nconst celsiustofahrenheit = (celsius) => celsius * 9/5 + 32;\nconst fahrenheittocelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;\n\ncelsiustofahrenheit(15);    // 59\ncelsiustofahrenheit(0);     // 32\ncelsiustofahrenheit(-20);   // -4\nfahrenheittocelsius(59);    // 15\nfahrenheittocelsius(32);    // 0\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5. 检测对象是否为空\n\n该方法用于检测一个javascript对象是否为空：\n\nconst isempty = obj => reflect.ownkeys(obj).length === 0 && obj.constructor === object;\n复制代码\n\n\n1\n2\n\n\n> 作者：cuggz 链接：https://juejin.cn/post/7025771605422768159",charsets:{cjk:!0},lastUpdated:"2022/03/02, 12:18:40",lastUpdatedTimestamp:164622352e4},{title:"new命令原理",frontmatter:{title:"new命令原理",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/8143cc480faf9a11",categories:["前端","JavaScript文章"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/25.JavaScript/02.new命令原理.md",key:"v-57f48596",path:"/pages/8143cc480faf9a11/",excerpt:'<h1 id="new命令原理"><a class="header-anchor" href="#new命令原理">#</a> new命令原理</h1>\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\n<ol>\n<li>创建一个空对象，作为将要返回的实例对象。</li>\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\n<li>将这个空对象赋值给函数内部的this关键字。</li>\n<li>开始执行构造函数内部的代码。</li>\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\n</ol>\n',headersStr:null,content:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction Person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(Person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(Person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new Person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",normalizedContent:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"ES5面向对象",frontmatter:{title:"ES5面向对象",date:"2020-02-22T10:35:43.000Z",permalink:"/pages/b1af5cb8996363c5",categories:["前端","JavaScript文章"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/03.ES5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.前端/25.JavaScript/03.ES5面向对象.md",key:"v-2bab44b8",path:"/pages/b1af5cb8996363c5/",headersStr:null,content:"# ES5面向对象\n\n//面向对象封装\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\n  this.name = props.name || '匿名';  // 默认‘匿名’\n  this.grade = props.grade || 1;\n}\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\n}\n\n\n//使用\nfunction createStudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new Student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar niming = createStudent(); \nniming.hello();\n\nvar xiaoming = createStudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n//继承\nfunction inherits(Child, Parent) { // 继承的封装方法 inherits(子类, 父类) \n    var F = function () {}; // 定义空方法F\n    F.prototype = Parent.prototype; //F原型指向父类原型\n    Child.prototype = new F(); // 子类原型指向 new F() 方法\n    Child.prototype.constructor = Child; // 修正子类原型上的构造函数为子类本身函数\n}\n\nfunction PrimaryStudent(props) { //定义子类 构造函数\n    Student.call(this, props); // 修正this指向\n    this.age = props.age || 8; //新增子类属性\n}\n\ninherits(PrimaryStudent, Student);//调用继承封装方法实现继承\n\nPrimaryStudent.prototype.getAge = function(){ //对子类添加方法\n  console.log(this.name +'同学，你今年'+ this.age +'岁');\n}\n\n\n//使用继承后的\nfunction createPrimaryStudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new PrimaryStudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar xiaohong = createPrimaryStudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getAge();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n",normalizedContent:"# es5面向对象\n\n//面向对象封装\nfunction student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\n  this.name = props.name || '匿名';  // 默认‘匿名’\n  this.grade = props.grade || 1;\n}\nstudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\n}\n\n\n//使用\nfunction createstudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar niming = createstudent(); \nniming.hello();\n\nvar xiaoming = createstudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n//继承\nfunction inherits(child, parent) { // 继承的封装方法 inherits(子类, 父类) \n    var f = function () {}; // 定义空方法f\n    f.prototype = parent.prototype; //f原型指向父类原型\n    child.prototype = new f(); // 子类原型指向 new f() 方法\n    child.prototype.constructor = child; // 修正子类原型上的构造函数为子类本身函数\n}\n\nfunction primarystudent(props) { //定义子类 构造函数\n    student.call(this, props); // 修正this指向\n    this.age = props.age || 8; //新增子类属性\n}\n\ninherits(primarystudent, student);//调用继承封装方法实现继承\n\nprimarystudent.prototype.getage = function(){ //对子类添加方法\n  console.log(this.name +'同学，你今年'+ this.age +'岁');\n}\n\n\n//使用继承后的\nfunction createprimarystudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new primarystudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar xiaohong = createprimarystudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getage();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n",charsets:{cjk:!0},lastUpdated:"2022/03/02, 12:18:40",lastUpdatedTimestamp:164622352e4},{title:"ES6面向对象",frontmatter:{title:"ES6面向对象",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/1f4123be6f45abcd",categories:["前端","JavaScript文章"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/04.ES6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.前端/25.JavaScript/04.ES6面向对象.md",key:"v-eaa110c0",path:"/pages/1f4123be6f45abcd/",headersStr:null,content:"# ES6面向对象\n\n//面向对象封装\nclass Student{ //定义类 (尊从首字母大写的约定)\n    constructor(props){  // 构造函数 （构造函数内定于属性）\n        this.name = props.name || '匿名'; // 默认'匿名'\n      this.grade = props.grade || 1;\n    }\n    hello(){ // 在构造函数的原型上定义方法\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\n    }\n}\n\n\n\n//使用\nfunction createStudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new Student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet niming = createStudent(); \nniming.hello();\n\nlet xiaoming = createStudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n\n//继承\nclass PrimaryStudent extends Student { //class 子类 extends 父类\n    constructor(props) {\n        super(props); // 用super调用父类的构造方法实现属性继承\n        this.age = props.age || 8; //新增子类属性\n    }\n\n    getAge() { //对子类添加方法\n        console.log(`${this.name}同学，你今年${this.age}岁`);\n    }\n}\n\n\n//使用继承后的\nfunction createPrimaryStudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new PrimaryStudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet xiaohong = createPrimaryStudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getAge();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n",normalizedContent:"# es6面向对象\n\n//面向对象封装\nclass student{ //定义类 (尊从首字母大写的约定)\n    constructor(props){  // 构造函数 （构造函数内定于属性）\n        this.name = props.name || '匿名'; // 默认'匿名'\n      this.grade = props.grade || 1;\n    }\n    hello(){ // 在构造函数的原型上定义方法\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\n    }\n}\n\n\n\n//使用\nfunction createstudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet niming = createstudent(); \nniming.hello();\n\nlet xiaoming = createstudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n\n//继承\nclass primarystudent extends student { //class 子类 extends 父类\n    constructor(props) {\n        super(props); // 用super调用父类的构造方法实现属性继承\n        this.age = props.age || 8; //新增子类属性\n    }\n\n    getage() { //对子类添加方法\n        console.log(`${this.name}同学，你今年${this.age}岁`);\n    }\n}\n\n\n//使用继承后的\nfunction createprimarystudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new primarystudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet xiaohong = createprimarystudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getage();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"Service Worker简述",frontmatter:{title:"Service Worker简述",date:"2021-11-04T14:53:15.000Z",permalink:"/pages/dcebaf/",titleTag:"原创",categories:["更多","实用技巧"],tags:["JavaScript","实用技巧"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/10.Service%20Worker%E7%AE%80%E8%BF%B0.html",relativePath:"01.前端/25.JavaScript/10.Service Worker简述.md",key:"v-7cc4c202",path:"/pages/dcebaf/",headers:[{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:73},{level:3,title:"什么是Service Worker",slug:"什么是service-worker",normalizedTitle:"什么是service worker",charIndex:255},{level:3,title:"Service Worker生命周期",slug:"service-worker生命周期",normalizedTitle:"service worker生命周期",charIndex:913},{level:3,title:"瑕疵与问题",slug:"瑕疵与问题",normalizedTitle:"瑕疵与问题",charIndex:7989},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9712}],excerpt:'<h1 id="虽然云q同学由于工作原因-好久没有更新了。-虽然有很多想分享的"><a class="header-anchor" href="#虽然云q同学由于工作原因-好久没有更新了。-虽然有很多想分享的">#</a> 虽然云Q同学由于工作原因，好久没有更新了。(虽然有很多想分享的)</h1>\n<p align="center"><img src="https://cdn.jsdelivr.net/gh/rwerplus/rwerplus.github.io@master/20220225/xxx.mrtsg0up228.webp" width="500" style="cursor: zoom-in;"></p>\n',headersStr:"背景 什么是Service Worker Service Worker生命周期 瑕疵与问题 使用场景",content:'# 虽然云Q同学由于工作原因，好久没有更新了。(虽然有很多想分享的)\n\n\n\n提示\n\n今天的文章有点长，如果你没时间一次性读完，建议先收藏\n\n\n# 背景\n\n由于最近使用语雀比较频繁，偶然一次点进去语雀的源码看到了serviceWorker，便产生了好奇去研究\n\n丰富的离线体验、定期的后台同步以及推送通知等通常需要将面向本机应用的功能将引入到网页应用中。Service Worker 提供所有这些功能所依赖的技术基础。\n\n----------------------------------------\n\n\n# 什么是Service Worker\n\nService Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。现在，它们已包括如推送通知和后台同步等功能。将来，Service Worker 将会支持如定期同步或地理围栏等其他功能。 在 Service Worker 出现前，存在能够在网络上为用户提供离线体验的另一个 API，称为 AppCache。AppCache API 存在的许多相关问题，在设计 Service Worker 时已予以避免。\n\nService Worker 相关注意事项:\n\n * 它是一种 JavaScript Worker，无法直接访问 DOM。Service Worker 通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。\n * Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。\n * Service Worker 在不用时会被中止，并在下次有需要时重启，因此，您不能依赖 Service Worker onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，Service Worker 可以访问 IndexedDB API。\n * Service Worker 广泛地利用了 promise\n\n----------------------------------------\n\n\n# Service Worker生命周期\n\nService Worker 的生命周期完全独立于网页。\n\n要为网站安装服务工作线程，您需要先在页面的 JavaScript 中注册。注册服务工作线程将会导致浏览器在后台启动服务工作线程安装步骤。\n\n在安装过程中，通常需要缓存某些静态资产。如果所有文件均已成功缓存，那么 Service Worker 就安装完毕。如果任何文件下载失败或缓存失败，那么安装步骤将会失败，Service Worker 就无法激活（也就是说， 不会安装）。如果发生这种情况，不必担心，它下次会再试一次。但这意味着，如果安装完成，便知道已在缓存中有哪些静态资产。\n\n安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，后面将在 Service Worker 的更新部分对此详加介绍。\n\n激活之后，Service Worker 将会对其作用域内的所有页面实施控制，不过，首次注册该 Service Worker 的页面需要再次加载才会受其控制。服务工作线程实施控制后，它将处于以下两种状态之一: 服务工作线程终止以节省内存，或处理获取和消息事件，从页面发出网络请求或消息后将会出现后一种状态。\n\n以下为简化的生命周期：\n\n\n\n\n\n图片来源于 google 开发\n\n * # 先决条件\n\n * 浏览器支持\n\n可用的浏览器日益增多。Service Worker 受 Chrome、Firefox 和 Opera 支持。Microsoft Edge 现在表示公开支持。甚至 Safari 也暗示未来会进行相关开发。您可以在 Jake Archibald 的 is Serviceworker ready 网站上查看所有浏览器的支持情况 。\n\n * 需要HTTPS/localhost\n\n在开发过程中，可以通过 localhost 使用 Service Worker，但如果要在网站上部署 Service Worker，则需要在服务器上设置 HTTPS。\n\n使用服务工作线程，您可以劫持连接、编撰以及过滤响应。这是一个很强大的工具。您可能会善意地使用这些功能，但中间人可会将其用于不良目的。为避免这种情况，可仅在通过 HTTPS 提供的页面上注册 Service Worker，如此我们便知道浏览器接收的 Service Worker 在整个网络传输过程中都没有被篡改。\n\n如果想要向服务器添加 HTTPS，您需要获得 TLS 证书并在服务器上进行设置。具体因您的设置而异，因此请查看服务器的文档，并务必查阅 Mozilla SSL 配置生成器，了解最佳做法。\n\n * # 注册Service Worker\n\n若要安装 Service Worker，您需要通过在页面中对其进行注册来启动安装。这将告诉浏览器 Service Worker JavaScript 文件的位置。\n\nif (\'serviceWorker\' in navigator) {\n  window.addEventListener(\'load\', function() {\n    navigator.serviceWorker.register(\'/sw.js\').then(function(registration) {\n      // Registration was successful\n      console.log(\'ServiceWorker registration successful with scope: \', registration.scope);\n    }, function(err) {\n      // registration failed :(\n      console.log(\'ServiceWorker registration failed: \', err);\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此代码用于检查 Service Worker API 是否可用，如果可用，则在页面加载后注册位于 /sw.js 的 Service Worker。\n\n每次页面加载无误时，即可调用 register()；浏览器将会判断服务工作线程是否已注册并做出相应的处理。\n\nregister() 方法的精妙之处在于服务工作线程文件的位置。您会发现在本例中服务工作线程文件位于根网域。这意味着服务工作线程的作用域将是整个来源。换句话说，Service Worker 将接收此网域上所有事项的 fetch 事件。如果我们在 /example/sw.js 处注册 Service Worker 文件，则 Service Worker将只能看到网址以/example/ 开头(即/example/page1/、/example/page2/)的页面的 fetch 事件。\n\n现在，您可以通过转至 chrome://inspect/#service-workers 并寻找您的网站来检查 Service Worker 是否已启用。\n\n\n\n首次实施 Service Worker 时，您还可以通过 chrome://serviceworker-internals 来查看 Service Worker 详情。如果只是想了解 Service Worker 的生命周期，这仍很有用，但是日后其很有可能被 chrome://inspect/#service-workers 完全取代。\n\n您会发现，它还可用于测试隐身窗口中的服务工作线程，您可以关闭服务工作线程并重新打开，因为之前的服务工作线程不会影响新窗口。从无痕式窗口创建的任何注册和缓存在该窗口关闭后均将被清除。\n\n * # 安装Service Worker\n\n在受控页面启动注册流程后，我们来看看处理 install 事件的 Service Worker 脚本。\n\n最基本的例子是，您需要为安装事件定义回调，并决定想要缓存的文件。\n\nself.addEventListener(\'install\', function(event) {\n  // Perform install steps\n});\n\n\n1\n2\n3\n\n\n在 install 回调的内部，我们需要执行以下步骤:\n\n 打开缓存。\n 缓存文件;\n 确认所有需要的资产是否已缓存;\n\n\n1\n2\n3\n\n\nvar CACHE_NAME = \'my-site-cache-v1\';\nvar urlsToCache = [\n  \'/\',\n  \'/styles/main.css\',\n  \'/script/main.js\'\n];\n\nself.addEventListener(\'install\', function(event) {\n  // Perform install steps\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        console.log(\'Opened cache\');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n * 此处，我们以所需的缓存名称调用 caches.open()，之后再调用 cache.addAll() 并传入文件数组。这是一个 promise 链（caches.open() 和 cache.addAll()）。 event.waitUntil() 方法带有 promise 参数并使用它来判断安装所花费的时间，以及安装是否成功。\n\n * 如果所有文件都成功缓存，则将安装 Service Worker。如有任何文件无法下载，则安装步骤将失败。这可让您依赖于所定义的所有资产，但也意味着需要对您决定在安装步骤缓存的文件列表格外留意。定义一个过长的文件列表将会增加文件缓存失败的几率，从而导致服务工作线程未能安装。\n\n * 这仅是一个示例，实际您可以在 install 事件中执行其他任务，或完全避免设置 install 事件侦听器。\n\n * # 缓存和返回请求\n\n您已安装 Service Worker，现在可能会想要返回一个缓存的响应，对吧？\n\n在安装 Service Worker 且用户转至其他页面或刷新当前页面后，Service Worker 将开始接收 fetch 事件。下面提供了一个示例。\n\nself.addEventListener(\'fetch\', function(event) {\n  event.respondWith(\n    caches.match(event.request)\n      .then(function(response) {\n        // Cache hit - return response\n        if (response) {\n          return response;\n        }\n        return fetch(event.request);\n      }\n    )\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 这里我们定义了 fetch 事件，并且在 event.respondWith() 中，我们传入来自 caches.match() 的一个 promise。此方法检视该请求，并从服务工作线程所创建的任何缓存中查找缓存的结果。\n\n * 如果发现匹配的响应，则返回缓存的值，否则，将调用 fetch 以发出网络请求，并将从网络检索到的任何数据作为结果返回。这是一个简单的例子，它使用了在安装步骤中缓存的所有资产。\n\n * 如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示。\n\nself.addEventListener(\'fetch\', function(event) {\n  event.respondWith(\n    caches.match(event.request)\n      .then(function(response) {\n        // Cache hit - return response\n        if (response) {\n          return response;\n        }\n\n        // IMPORTANT:Clone the request. A request is a stream and\n        // can only be consumed once. Since we are consuming this\n        // once by cache and once by the browser for fetch, we need\n        // to clone the response.\n        var fetchRequest = event.request.clone();\n\n        return fetch(fetchRequest).then(\n          function(response) {\n            // Check if we received a valid response\n            if(!response || response.status !== 200 || response.type !== \'basic\') {\n              return response;\n            }\n\n            // IMPORTANT:Clone the response. A response is a stream\n            // and because we want the browser to consume the response\n            // as well as the cache consuming the response, we need\n            // to clone it so we have two streams.\n            var responseToCache = response.clone();\n\n            caches.open(CACHE_NAME)\n              .then(function(cache) {\n                cache.put(event.request, responseToCache);\n              });\n\n            return response;\n          }\n        );\n      })\n    );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n执行的操作如下:\n\n在 fetch 请求中添加对 .then() 的回调。\n\n获得响应后，执行以下检查:\n\n- 确保响应有效。\n\n- 检查并确保响应的状态为 200。\n\n- 确保响应类型为 basic，亦即由自身发起的请求。这意味着，对第三方资产的请求也不会添加到缓存。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 如果通过检查，则克隆响应。这样做的原因在于，该响应是数据流， 因此主体只能使用一次。由于我们想要返回能被浏览器使用的响应，并将其传递到缓存以供使用，因此需要克隆一份副本。我们将一份发送给浏览器，另一份则保留在缓存。\n\n * # 更新Service Worker\n\n在某个时间点，您的 Service Worker 需要更新。此时，您需要遵循以下步骤:\n\n- 更新您的服务工作线程 JavaScript 文件。用户导航至您的站点时，浏览器会尝试在后台重新下载定义 Service Worker 的脚本文件。如果 Service Worker 文件与其当前所用文件存在字节差异，则将其视为新 Service Worker。\n\n- 新 Service Worker 将会启动，且将会触发 install 事件。\n\n- 此时，旧 Service Worker 仍控制着当前页面，因此新 Service Worker 将进入 waiting 状态。\n\n- 当网站上当前打开的页面关闭时，旧 Service Worker 将会被终止，新 Service Worker 将会取得控制权。\n\n- 新 Service Worker 取得控制权后，将会触发其 activate 事件。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n出现在 activate 回调中的一个常见任务是缓存管理。您希望在 activate 回调中执行此任务的原因在于，如果您在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 Service Worker 将突然无法从缓存中提供文件。\n\n比如说我们有一个名为 \'my-site-cache-v1\' 的缓存，我们想要将该缓存拆分为一个页面缓存和一个博文缓存。这就意味着在安装步骤中我们创建了两个缓存: \'pages-cache-v1\' 和 \'blog-posts-cache-v1\'，且在激活步骤中我们要删除旧的 \'my-site-cache-v1\'。\n\n以下代码将执行此操作，具体做法为: 遍历 Service Worker 中的所有缓存，并删除未在缓存白名单中定义的任何缓存。\n\nself.addEventListener(\'activate\', function(event) {\n\n  var cacheAllowlist = [\'pages-cache-v1\', \'blog-posts-cache-v1\'];\n\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          if (cacheAllowlist.indexOf(cacheName) === -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 瑕疵与问题\n\n如果 Worker注册后未在 chrome://inspect/#service-workers 或 chrome://serviceworker-internals 中显示，则有可能是引发错误或向 event.waitUntil() 发送被拒绝的 promise 而导致无法安装。\n\n要解决该问题，请转至 chrome://serviceworker-internals 并勾选“Open DevTools window and pause JavaScript execution on service worker startup for debugging”，然后将调试程序语句置于安装事件开始处。这与未捕获异常中的暂停共同揭露问题。\n\n使用 fetch 时，默认情况下请求中不包含 Cookie 等凭据。如需凭据，改为调用\n\nfetch(url, {\n  credentials: \'include\'\n})\n\n\n1\n2\n3\n\n\n这一行为是有意为之，可以说比 XHR 更复杂的以下默认行为更好: 如果网址具有相同来源，则默认发送凭据，否则忽略。提取的行为更接近于其他 CORS 请求，如 ，它将决不会发送 Cookie，除非您使用 选择加入。\n\n非 CORS 默认失败\n\n默认情况下，从不支持 CORS 的第三方网址中提取资源将会失败。您可以向请求中添加 no-CORS 选项来克服此问题，不过这可能会导致“不透明”的响应，这意味着您无法辨别响应是否成功。\n\ncache.addAll(urlsToPrefetch.map(function(urlToPrefetch) {\n  returnnewRequest(urlToPrefetch, { mode: \'no-cors\'});}))\n      .then(function() {\n            console.log(\'All resources have been fetched and cached.\');\n});\n\n\n1\n2\n3\n4\n5\n\n\n处理响应式图像\n\nsrcset 属性或 元素将在运行期间选择最适当的图像资产，并发出网络请求。\n\n对于 Service Worker，如果您想要在安装过程中缓存图像，您有下列几种选择:\n\n安装 <picture> 元素和 srcset 属性将请求的所有图像。\n\n安装一个低分辨率版本的图像。\n\n安装一个高分辨率版本的图像。\n\n\n1\n2\n3\n4\n5\n\n\n实际上，您应该选择 2 或 3，因为下载所有图像会浪费存储空间。\n\n假定您在安装期间选择安装低分辨率版本的图像，在页面加载时您想要尝试从网络中检索高分辨率的图像，但是如果检索高分辨率版本失败，则回退到低分辨率版本。这没有问题，而且这种做法很好，但是有另外一个问题。\n\n如果我们有以下两张图像:\n\n屏幕密度   宽度    高度\n1x     400   400\n2x     800   800\n\n在 srcset 图像中，我们有一些像这样的标记:\n\n<img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" />\n\n\n1\n\n\n如果我们使用的是 2x 显示屏，浏览器将会选择下载 image-2x.png。如果我们处于离线状态，您可以对请求执行 .catch() 并返回 image-src.png（如已缓存）。但是，浏览器会期望 2x 屏幕上的图像有额外的像素，这样图像将显示为 200x200 CSS 像素而不是 400x400 CSS 像素。解决该问题的唯一办法是设定固定的图像高度和宽度。\n\n<img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" style="width:400px; height: 400px;" />\n\n\n1\n\n\n对于要用于艺术指导的 元素，这会变得相当困难，而且很大程度上取决于图像的创建和使用方式，但是您可以使用类似于 srcset 的方法\n\n\n * # 使用场景\n   \n   * 预加载 && 离线化\n   \n   打开语雀官网就可以看到https://www.yuque.com/，首次是从网络请求，但是第二次进入后便是通过serviceworker读取\n   \n   访问开发者后台的service-worker.js查看源代码\n\nself.assets = ["https://gw.alipayobjects.com/os/chair-script/skylark/common.b4c03be5.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/common.e2d71ce8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Recommend~p__explore__routers__Docs~p__explore__routers__Repos~p_~d6257766.aa1bcc43.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Recommend~p__explore__routers__Docs~p__explore__routers__Repos~p_~d6257766.fac19d5b.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/c__Lakex~p__editor__routers__TextEditor.9defba11.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/c__Lakex~p__editor__routers__TextEditor.3a98afb8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers.244d87f7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers.ef3c862f.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/c__Lakex.acd5cec4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/c__Lakex.653d1e93.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/layout__MainLayout.ae548301.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/layout__MainLayout.c0075e36.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__model.511a24e3.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__EditCustomIndex.d4fbfe9e.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__EditCustomIndex.28048163.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__ShareExpired.8113c1a2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__ShareExpired.b6dff962.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__SharePassword.1a6ae926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookRepo__routers__SharePassword.f76c7685.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Events.6d43e196.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Events.979d04c6.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Recommend.ab8c57cb.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__Explore__Recommend.ac025d9d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__model.2d27d4bc.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__App.4d4a0a8c.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__App.08fcac15.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__CollabBooks.40627926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__CollabBooks.91d8d56d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Collects.0a516ca7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Collects.b5f172fe.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Dashboard.5f89b7f3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Dashboard.be7c1714.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Explore.b51bb073.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Groups.198f522b.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Groups.ad67b3b7.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__History.086ddd9c.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__History.5387e7a8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__MyBooks.40627926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__MyBooks.61608f6e.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Notes.a878e2d7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Notes.ffe2cc7a.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Recycles.ab448ca1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__Recycles.3434b09c.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__model__page.424fcfd2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers.66f72a35.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers.39267068.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers__version.e7b71a05.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers__version.186ff53b.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__model.7ef254a2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__Asl.60282b53.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__Asl.fa585dad.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__TextEditor.f413dbfc.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__TextEditor.81c5d11d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__board.591d841b.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__board.832f1003.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__doc.a1ccd84d.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__doc.e652cf65.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed.500645af.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed.743631c5.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed_extreme.5563bfd4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed_extreme.88434cbe.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__sheet.8a86af45.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__sheet.2daf2fb0.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__show.75463f8e.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__show.14157f9c.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__table.60aad9c2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__table.29a799ed.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__model.263db0b2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Books.cfc93cd2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Books.8ffd07d8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Custom.710dc957.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Custom.604bf4aa.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Embed.daf129f3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Embed.1a8cd333.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Error403.8113c1a2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Error403.e426da8e.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Group.a1fbd1b1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Group.aca6ba40.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Members.c73713ca.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Members.fc9d4e92.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Migrate.e821f2d6.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Migrate.c5718315.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Recycles.724821a4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Recycles.9b99a94d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Statistics.e849f2e3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Statistics.e2b4dc68.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Upgrade.a42075c1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__Upgrade.d80c9df1.async.js", "https://gw.alipayobjects.com/os/lib/??react/16.13.1/umd/react.production.min.js,react-dom/16.13.1/umd/react-dom.production.min.js,react-dom/16.13.1/umd/react-dom-server.browser.production.min.js,moment/2.24.0/min/moment.min.js", "https://gw.alipayobjects.com/as/g/larkgroup/lake-codemirror/6.0.2/CodeMirror.js", "https://gw.alipayobjects.com/as/g/larkgroup/lark-sheet/11.0.20/lark-sheet.css", "https://gw.alipayobjects.com/a/g/lark/??immutable/3.8.2/immutable.min.js", "https://gw.alipayobjects.com/as/g/larkgroup/lark-sheet/11.0.20/lark-sheet.js"];\nself.resourceBase = "https://gw.alipayobjects.com/os/chair-script/skylark/";\n\nself.addEventListener("install", (e => {\n      //预加载常用资源\n    Array.isArray(self.assets) && e.waitUntil(caches.open("v1").then((e => {\n      e.addAll(self.assets)\n    })))\n})), self.addEventListener("activate", (e => {\n  Array.isArray(self.assets) && caches.open("v1").then((e => {\n    e.keys().then((t => {\n      t.forEach((t => {\n        //过期资源释放\n        self.assets.includes(t.url) || e.delete(t)\n      }))\n    }))\n  }))\n}));\nconst r = [self.resourceBase, "https://at.alicdn.com/t/", "https://gw.alipayobjects.com/os/"];\nself.addEventListener("fetch", (e => {\n  //拦截资源，满足上述域名，优先使用缓存，否则使用网络下载资源并更新资源。\n  r.some((t => e.request.url.startsWith(t))) && e.respondWith(caches.match(e.request).then((t => t && 200 === t.status ? t : fetch(e.request).then((t => {\n    if (200 !== t.status) return t;\n    const r = t.clone();\n    return caches.open("v1").then((t => {\n      t.put(e.request, r)\n    })), t\n  })).catch((() => {})))))\n}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n此处只是访问首页，Cache 就已经加载了大量的 js 资源和 css 资源，总缓存占据了 64 MB，作为一个偏展示型官网，加载 64MB 显示是不科学的，更合理的解释是，在不堵塞用户使用的情况，优先缓存了后续页面所需要使用的 js 文件来加速后续页面的打开速度，比如其 TextEditor 组件就是为了后续的编辑页提前缓存的：\n\n * 其它预加载使用场景\n   \n   那么现在换为移动App的场景，以一个复杂的页面为例，如果Boss 今天给你的任务是秒开该工作台应用下的一个子应用，包括第一次打开，如何利用 ServiceWorker 来做到?\n\n * 错误页面\n\n当你的某个重要资源无法从网络下载时，可以使用降级策略，返回到一个 Error 页面，这个 Error 页面可以是你事先缓存的一个资源。\n\n以上面提到的工作台场景为例，移动端最常见的故障是子应用白屏，子应用白屏时会在进入正常页面之前产生出完全白色的界面，原因是下一个页面的某个 html 或者 js 资源获取异常或者加载时间很漫长，导致了页面白屏。\n\n如果使用了ServiceWorker 拦截了请求，就可以在无法正常返回资源的时候返回给前台一个error页面，当前如果把 error 链接设置成一个动态地址，我们就可以实现在后台做到各种策略的优雅降级了。',normalizedContent:'# 虽然云q同学由于工作原因，好久没有更新了。(虽然有很多想分享的)\n\n\n\n提示\n\n今天的文章有点长，如果你没时间一次性读完，建议先收藏\n\n\n# 背景\n\n由于最近使用语雀比较频繁，偶然一次点进去语雀的源码看到了serviceworker，便产生了好奇去研究\n\n丰富的离线体验、定期的后台同步以及推送通知等通常需要将面向本机应用的功能将引入到网页应用中。service worker 提供所有这些功能所依赖的技术基础。\n\n----------------------------------------\n\n\n# 什么是service worker\n\nservice worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。现在，它们已包括如推送通知和后台同步等功能。将来，service worker 将会支持如定期同步或地理围栏等其他功能。 在 service worker 出现前，存在能够在网络上为用户提供离线体验的另一个 api，称为 appcache。appcache api 存在的许多相关问题，在设计 service worker 时已予以避免。\n\nservice worker 相关注意事项:\n\n * 它是一种 javascript worker，无法直接访问 dom。service worker 通过响应 postmessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 dom 执行操作。\n * service worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。\n * service worker 在不用时会被中止，并在下次有需要时重启，因此，您不能依赖 service worker onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，service worker 可以访问 indexeddb api。\n * service worker 广泛地利用了 promise\n\n----------------------------------------\n\n\n# service worker生命周期\n\nservice worker 的生命周期完全独立于网页。\n\n要为网站安装服务工作线程，您需要先在页面的 javascript 中注册。注册服务工作线程将会导致浏览器在后台启动服务工作线程安装步骤。\n\n在安装过程中，通常需要缓存某些静态资产。如果所有文件均已成功缓存，那么 service worker 就安装完毕。如果任何文件下载失败或缓存失败，那么安装步骤将会失败，service worker 就无法激活（也就是说， 不会安装）。如果发生这种情况，不必担心，它下次会再试一次。但这意味着，如果安装完成，便知道已在缓存中有哪些静态资产。\n\n安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，后面将在 service worker 的更新部分对此详加介绍。\n\n激活之后，service worker 将会对其作用域内的所有页面实施控制，不过，首次注册该 service worker 的页面需要再次加载才会受其控制。服务工作线程实施控制后，它将处于以下两种状态之一: 服务工作线程终止以节省内存，或处理获取和消息事件，从页面发出网络请求或消息后将会出现后一种状态。\n\n以下为简化的生命周期：\n\n\n\n\n\n图片来源于 google 开发\n\n * # 先决条件\n\n * 浏览器支持\n\n可用的浏览器日益增多。service worker 受 chrome、firefox 和 opera 支持。microsoft edge 现在表示公开支持。甚至 safari 也暗示未来会进行相关开发。您可以在 jake archibald 的 is serviceworker ready 网站上查看所有浏览器的支持情况 。\n\n * 需要https/localhost\n\n在开发过程中，可以通过 localhost 使用 service worker，但如果要在网站上部署 service worker，则需要在服务器上设置 https。\n\n使用服务工作线程，您可以劫持连接、编撰以及过滤响应。这是一个很强大的工具。您可能会善意地使用这些功能，但中间人可会将其用于不良目的。为避免这种情况，可仅在通过 https 提供的页面上注册 service worker，如此我们便知道浏览器接收的 service worker 在整个网络传输过程中都没有被篡改。\n\n如果想要向服务器添加 https，您需要获得 tls 证书并在服务器上进行设置。具体因您的设置而异，因此请查看服务器的文档，并务必查阅 mozilla ssl 配置生成器，了解最佳做法。\n\n * # 注册service worker\n\n若要安装 service worker，您需要通过在页面中对其进行注册来启动安装。这将告诉浏览器 service worker javascript 文件的位置。\n\nif (\'serviceworker\' in navigator) {\n  window.addeventlistener(\'load\', function() {\n    navigator.serviceworker.register(\'/sw.js\').then(function(registration) {\n      // registration was successful\n      console.log(\'serviceworker registration successful with scope: \', registration.scope);\n    }, function(err) {\n      // registration failed :(\n      console.log(\'serviceworker registration failed: \', err);\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此代码用于检查 service worker api 是否可用，如果可用，则在页面加载后注册位于 /sw.js 的 service worker。\n\n每次页面加载无误时，即可调用 register()；浏览器将会判断服务工作线程是否已注册并做出相应的处理。\n\nregister() 方法的精妙之处在于服务工作线程文件的位置。您会发现在本例中服务工作线程文件位于根网域。这意味着服务工作线程的作用域将是整个来源。换句话说，service worker 将接收此网域上所有事项的 fetch 事件。如果我们在 /example/sw.js 处注册 service worker 文件，则 service worker将只能看到网址以/example/ 开头(即/example/page1/、/example/page2/)的页面的 fetch 事件。\n\n现在，您可以通过转至 chrome://inspect/#service-workers 并寻找您的网站来检查 service worker 是否已启用。\n\n\n\n首次实施 service worker 时，您还可以通过 chrome://serviceworker-internals 来查看 service worker 详情。如果只是想了解 service worker 的生命周期，这仍很有用，但是日后其很有可能被 chrome://inspect/#service-workers 完全取代。\n\n您会发现，它还可用于测试隐身窗口中的服务工作线程，您可以关闭服务工作线程并重新打开，因为之前的服务工作线程不会影响新窗口。从无痕式窗口创建的任何注册和缓存在该窗口关闭后均将被清除。\n\n * # 安装service worker\n\n在受控页面启动注册流程后，我们来看看处理 install 事件的 service worker 脚本。\n\n最基本的例子是，您需要为安装事件定义回调，并决定想要缓存的文件。\n\nself.addeventlistener(\'install\', function(event) {\n  // perform install steps\n});\n\n\n1\n2\n3\n\n\n在 install 回调的内部，我们需要执行以下步骤:\n\n 打开缓存。\n 缓存文件;\n 确认所有需要的资产是否已缓存;\n\n\n1\n2\n3\n\n\nvar cache_name = \'my-site-cache-v1\';\nvar urlstocache = [\n  \'/\',\n  \'/styles/main.css\',\n  \'/script/main.js\'\n];\n\nself.addeventlistener(\'install\', function(event) {\n  // perform install steps\n  event.waituntil(\n    caches.open(cache_name)\n      .then(function(cache) {\n        console.log(\'opened cache\');\n        return cache.addall(urlstocache);\n      })\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n * 此处，我们以所需的缓存名称调用 caches.open()，之后再调用 cache.addall() 并传入文件数组。这是一个 promise 链（caches.open() 和 cache.addall()）。 event.waituntil() 方法带有 promise 参数并使用它来判断安装所花费的时间，以及安装是否成功。\n\n * 如果所有文件都成功缓存，则将安装 service worker。如有任何文件无法下载，则安装步骤将失败。这可让您依赖于所定义的所有资产，但也意味着需要对您决定在安装步骤缓存的文件列表格外留意。定义一个过长的文件列表将会增加文件缓存失败的几率，从而导致服务工作线程未能安装。\n\n * 这仅是一个示例，实际您可以在 install 事件中执行其他任务，或完全避免设置 install 事件侦听器。\n\n * # 缓存和返回请求\n\n您已安装 service worker，现在可能会想要返回一个缓存的响应，对吧？\n\n在安装 service worker 且用户转至其他页面或刷新当前页面后，service worker 将开始接收 fetch 事件。下面提供了一个示例。\n\nself.addeventlistener(\'fetch\', function(event) {\n  event.respondwith(\n    caches.match(event.request)\n      .then(function(response) {\n        // cache hit - return response\n        if (response) {\n          return response;\n        }\n        return fetch(event.request);\n      }\n    )\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 这里我们定义了 fetch 事件，并且在 event.respondwith() 中，我们传入来自 caches.match() 的一个 promise。此方法检视该请求，并从服务工作线程所创建的任何缓存中查找缓存的结果。\n\n * 如果发现匹配的响应，则返回缓存的值，否则，将调用 fetch 以发出网络请求，并将从网络检索到的任何数据作为结果返回。这是一个简单的例子，它使用了在安装步骤中缓存的所有资产。\n\n * 如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示。\n\nself.addeventlistener(\'fetch\', function(event) {\n  event.respondwith(\n    caches.match(event.request)\n      .then(function(response) {\n        // cache hit - return response\n        if (response) {\n          return response;\n        }\n\n        // important:clone the request. a request is a stream and\n        // can only be consumed once. since we are consuming this\n        // once by cache and once by the browser for fetch, we need\n        // to clone the response.\n        var fetchrequest = event.request.clone();\n\n        return fetch(fetchrequest).then(\n          function(response) {\n            // check if we received a valid response\n            if(!response || response.status !== 200 || response.type !== \'basic\') {\n              return response;\n            }\n\n            // important:clone the response. a response is a stream\n            // and because we want the browser to consume the response\n            // as well as the cache consuming the response, we need\n            // to clone it so we have two streams.\n            var responsetocache = response.clone();\n\n            caches.open(cache_name)\n              .then(function(cache) {\n                cache.put(event.request, responsetocache);\n              });\n\n            return response;\n          }\n        );\n      })\n    );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n执行的操作如下:\n\n在 fetch 请求中添加对 .then() 的回调。\n\n获得响应后，执行以下检查:\n\n- 确保响应有效。\n\n- 检查并确保响应的状态为 200。\n\n- 确保响应类型为 basic，亦即由自身发起的请求。这意味着，对第三方资产的请求也不会添加到缓存。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 如果通过检查，则克隆响应。这样做的原因在于，该响应是数据流， 因此主体只能使用一次。由于我们想要返回能被浏览器使用的响应，并将其传递到缓存以供使用，因此需要克隆一份副本。我们将一份发送给浏览器，另一份则保留在缓存。\n\n * # 更新service worker\n\n在某个时间点，您的 service worker 需要更新。此时，您需要遵循以下步骤:\n\n- 更新您的服务工作线程 javascript 文件。用户导航至您的站点时，浏览器会尝试在后台重新下载定义 service worker 的脚本文件。如果 service worker 文件与其当前所用文件存在字节差异，则将其视为新 service worker。\n\n- 新 service worker 将会启动，且将会触发 install 事件。\n\n- 此时，旧 service worker 仍控制着当前页面，因此新 service worker 将进入 waiting 状态。\n\n- 当网站上当前打开的页面关闭时，旧 service worker 将会被终止，新 service worker 将会取得控制权。\n\n- 新 service worker 取得控制权后，将会触发其 activate 事件。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n出现在 activate 回调中的一个常见任务是缓存管理。您希望在 activate 回调中执行此任务的原因在于，如果您在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 service worker 将突然无法从缓存中提供文件。\n\n比如说我们有一个名为 \'my-site-cache-v1\' 的缓存，我们想要将该缓存拆分为一个页面缓存和一个博文缓存。这就意味着在安装步骤中我们创建了两个缓存: \'pages-cache-v1\' 和 \'blog-posts-cache-v1\'，且在激活步骤中我们要删除旧的 \'my-site-cache-v1\'。\n\n以下代码将执行此操作，具体做法为: 遍历 service worker 中的所有缓存，并删除未在缓存白名单中定义的任何缓存。\n\nself.addeventlistener(\'activate\', function(event) {\n\n  var cacheallowlist = [\'pages-cache-v1\', \'blog-posts-cache-v1\'];\n\n  event.waituntil(\n    caches.keys().then(function(cachenames) {\n      return promise.all(\n        cachenames.map(function(cachename) {\n          if (cacheallowlist.indexof(cachename) === -1) {\n            return caches.delete(cachename);\n          }\n        })\n      );\n    })\n  );\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 瑕疵与问题\n\n如果 worker注册后未在 chrome://inspect/#service-workers 或 chrome://serviceworker-internals 中显示，则有可能是引发错误或向 event.waituntil() 发送被拒绝的 promise 而导致无法安装。\n\n要解决该问题，请转至 chrome://serviceworker-internals 并勾选“open devtools window and pause javascript execution on service worker startup for debugging”，然后将调试程序语句置于安装事件开始处。这与未捕获异常中的暂停共同揭露问题。\n\n使用 fetch 时，默认情况下请求中不包含 cookie 等凭据。如需凭据，改为调用\n\nfetch(url, {\n  credentials: \'include\'\n})\n\n\n1\n2\n3\n\n\n这一行为是有意为之，可以说比 xhr 更复杂的以下默认行为更好: 如果网址具有相同来源，则默认发送凭据，否则忽略。提取的行为更接近于其他 cors 请求，如 ，它将决不会发送 cookie，除非您使用 选择加入。\n\n非 cors 默认失败\n\n默认情况下，从不支持 cors 的第三方网址中提取资源将会失败。您可以向请求中添加 no-cors 选项来克服此问题，不过这可能会导致“不透明”的响应，这意味着您无法辨别响应是否成功。\n\ncache.addall(urlstoprefetch.map(function(urltoprefetch) {\n  returnnewrequest(urltoprefetch, { mode: \'no-cors\'});}))\n      .then(function() {\n            console.log(\'all resources have been fetched and cached.\');\n});\n\n\n1\n2\n3\n4\n5\n\n\n处理响应式图像\n\nsrcset 属性或 元素将在运行期间选择最适当的图像资产，并发出网络请求。\n\n对于 service worker，如果您想要在安装过程中缓存图像，您有下列几种选择:\n\n安装 <picture> 元素和 srcset 属性将请求的所有图像。\n\n安装一个低分辨率版本的图像。\n\n安装一个高分辨率版本的图像。\n\n\n1\n2\n3\n4\n5\n\n\n实际上，您应该选择 2 或 3，因为下载所有图像会浪费存储空间。\n\n假定您在安装期间选择安装低分辨率版本的图像，在页面加载时您想要尝试从网络中检索高分辨率的图像，但是如果检索高分辨率版本失败，则回退到低分辨率版本。这没有问题，而且这种做法很好，但是有另外一个问题。\n\n如果我们有以下两张图像:\n\n屏幕密度   宽度    高度\n1x     400   400\n2x     800   800\n\n在 srcset 图像中，我们有一些像这样的标记:\n\n<img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" />\n\n\n1\n\n\n如果我们使用的是 2x 显示屏，浏览器将会选择下载 image-2x.png。如果我们处于离线状态，您可以对请求执行 .catch() 并返回 image-src.png（如已缓存）。但是，浏览器会期望 2x 屏幕上的图像有额外的像素，这样图像将显示为 200x200 css 像素而不是 400x400 css 像素。解决该问题的唯一办法是设定固定的图像高度和宽度。\n\n<img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" style="width:400px; height: 400px;" />\n\n\n1\n\n\n对于要用于艺术指导的 元素，这会变得相当困难，而且很大程度上取决于图像的创建和使用方式，但是您可以使用类似于 srcset 的方法\n\n\n * # 使用场景\n   \n   * 预加载 && 离线化\n   \n   打开语雀官网就可以看到https://www.yuque.com/，首次是从网络请求，但是第二次进入后便是通过serviceworker读取\n   \n   访问开发者后台的service-worker.js查看源代码\n\nself.assets = ["https://gw.alipayobjects.com/os/chair-script/skylark/common.b4c03be5.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/common.e2d71ce8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__recommend~p__explore__routers__docs~p__explore__routers__repos~p_~d6257766.aa1bcc43.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__recommend~p__explore__routers__docs~p__explore__routers__repos~p_~d6257766.fac19d5b.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/c__lakex~p__editor__routers__texteditor.9defba11.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/c__lakex~p__editor__routers__texteditor.3a98afb8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers.244d87f7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers.ef3c862f.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/c__lakex.acd5cec4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/c__lakex.653d1e93.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/layout__mainlayout.ae548301.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/layout__mainlayout.c0075e36.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__model.511a24e3.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__editcustomindex.d4fbfe9e.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__editcustomindex.28048163.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__shareexpired.8113c1a2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__shareexpired.b6dff962.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__sharepassword.1a6ae926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__bookrepo__routers__sharepassword.f76c7685.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__events.6d43e196.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__events.979d04c6.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__recommend.ab8c57cb.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__components__explore__recommend.ac025d9d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__model.2d27d4bc.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__app.4d4a0a8c.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__app.08fcac15.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__collabbooks.40627926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__collabbooks.91d8d56d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__collects.0a516ca7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__collects.b5f172fe.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__dashboard.5f89b7f3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__dashboard.be7c1714.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__explore.b51bb073.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__groups.198f522b.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__groups.ad67b3b7.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__history.086ddd9c.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__history.5387e7a8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__mybooks.40627926.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__mybooks.61608f6e.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__notes.a878e2d7.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__notes.ffe2cc7a.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__recycles.ab448ca1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__dashboard__routers__recycles.3434b09c.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__model__page.424fcfd2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers.66f72a35.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers.39267068.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers__version.e7b71a05.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__doc__routers__version.186ff53b.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__model.7ef254a2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__asl.60282b53.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__asl.fa585dad.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__texteditor.f413dbfc.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__texteditor.81c5d11d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__board.591d841b.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__board.832f1003.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__doc.a1ccd84d.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__doc.e652cf65.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed.500645af.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed.743631c5.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed_extreme.5563bfd4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__embed_extreme.88434cbe.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__sheet.8a86af45.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__sheet.2daf2fb0.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__show.75463f8e.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__show.14157f9c.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__table.60aad9c2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__editor__routers__table.29a799ed.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__model.263db0b2.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__books.cfc93cd2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__books.8ffd07d8.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__custom.710dc957.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__custom.604bf4aa.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__embed.daf129f3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__embed.1a8cd333.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__error403.8113c1a2.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__error403.e426da8e.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__group.a1fbd1b1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__group.aca6ba40.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__members.c73713ca.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__members.fc9d4e92.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__migrate.e821f2d6.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__migrate.c5718315.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__recycles.724821a4.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__recycles.9b99a94d.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__statistics.e849f2e3.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__statistics.e2b4dc68.async.js", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__upgrade.a42075c1.chunk.css", "https://gw.alipayobjects.com/os/chair-script/skylark/p__group__routers__upgrade.d80c9df1.async.js", "https://gw.alipayobjects.com/os/lib/??react/16.13.1/umd/react.production.min.js,react-dom/16.13.1/umd/react-dom.production.min.js,react-dom/16.13.1/umd/react-dom-server.browser.production.min.js,moment/2.24.0/min/moment.min.js", "https://gw.alipayobjects.com/as/g/larkgroup/lake-codemirror/6.0.2/codemirror.js", "https://gw.alipayobjects.com/as/g/larkgroup/lark-sheet/11.0.20/lark-sheet.css", "https://gw.alipayobjects.com/a/g/lark/??immutable/3.8.2/immutable.min.js", "https://gw.alipayobjects.com/as/g/larkgroup/lark-sheet/11.0.20/lark-sheet.js"];\nself.resourcebase = "https://gw.alipayobjects.com/os/chair-script/skylark/";\n\nself.addeventlistener("install", (e => {\n      //预加载常用资源\n    array.isarray(self.assets) && e.waituntil(caches.open("v1").then((e => {\n      e.addall(self.assets)\n    })))\n})), self.addeventlistener("activate", (e => {\n  array.isarray(self.assets) && caches.open("v1").then((e => {\n    e.keys().then((t => {\n      t.foreach((t => {\n        //过期资源释放\n        self.assets.includes(t.url) || e.delete(t)\n      }))\n    }))\n  }))\n}));\nconst r = [self.resourcebase, "https://at.alicdn.com/t/", "https://gw.alipayobjects.com/os/"];\nself.addeventlistener("fetch", (e => {\n  //拦截资源，满足上述域名，优先使用缓存，否则使用网络下载资源并更新资源。\n  r.some((t => e.request.url.startswith(t))) && e.respondwith(caches.match(e.request).then((t => t && 200 === t.status ? t : fetch(e.request).then((t => {\n    if (200 !== t.status) return t;\n    const r = t.clone();\n    return caches.open("v1").then((t => {\n      t.put(e.request, r)\n    })), t\n  })).catch((() => {})))))\n}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n此处只是访问首页，cache 就已经加载了大量的 js 资源和 css 资源，总缓存占据了 64 mb，作为一个偏展示型官网，加载 64mb 显示是不科学的，更合理的解释是，在不堵塞用户使用的情况，优先缓存了后续页面所需要使用的 js 文件来加速后续页面的打开速度，比如其 texteditor 组件就是为了后续的编辑页提前缓存的：\n\n * 其它预加载使用场景\n   \n   那么现在换为移动app的场景，以一个复杂的页面为例，如果boss 今天给你的任务是秒开该工作台应用下的一个子应用，包括第一次打开，如何利用 serviceworker 来做到?\n\n * 错误页面\n\n当你的某个重要资源无法从网络下载时，可以使用降级策略，返回到一个 error 页面，这个 error 页面可以是你事先缓存的一个资源。\n\n以上面提到的工作台场景为例，移动端最常见的故障是子应用白屏，子应用白屏时会在进入正常页面之前产生出完全白色的界面，原因是下一个页面的某个 html 或者 js 资源获取异常或者加载时间很漫长，导致了页面白屏。\n\n如果使用了serviceworker 拦截了请求，就可以在无法正常返回资源的时候返回给前台一个error页面，当前如果把 error 链接设置成一个动态地址，我们就可以实现在后台做到各种策略的优雅降级了。',charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"比typeof运算符更准确的类型判断",frontmatter:{title:"比typeof运算符更准确的类型判断",date:"2020-04-13T15:56:54.000Z",permalink:"/pages/fd4a16d56b83c1bc",categories:["前端","JavaScript文章"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/100.%E6%AF%94typeof%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9B%B4%E5%87%86%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.html",relativePath:"01.前端/25.JavaScript/100.比typeof运算符更准确的类型判断.md",key:"v-9ff076e8",path:"/pages/fd4a16d56b83c1bc/",headersStr:null,content:'# 比typeof运算符更准确的类型判断\n\n不同数据类型的Object.prototype.toString方法返回值如下。\n\n * 数值：返回[object Number]。\n * 字符串：返回[object String]。\n * 布尔值：返回[object Boolean]。\n * undefined：返回[object Undefined]。\n * null：返回[object Null]。\n * 数组：返回[object Array]。\n * arguments 对象：返回[object Arguments]。\n * 函数：返回[object Function]。\n * Error 对象：返回[object Error]。\n * Date 对象：返回[object Date]。\n * RegExp 对象：返回[object RegExp]。\n * 其他对象：返回[object Object]。\n\n这就是说，Object.prototype.toString可以看出一个值到底是什么类型。\n\nObject.prototype.toString.call(2) // "[object Number]"\nObject.prototype.toString.call(\'\') // "[object String]"\nObject.prototype.toString.call(true) // "[object Boolean]"\nObject.prototype.toString.call(undefined) // "[object Undefined]"\nObject.prototype.toString.call(null) // "[object Null]"\nObject.prototype.toString.call(Math) // "[object Math]"\nObject.prototype.toString.call({}) // "[object Object]"\nObject.prototype.toString.call([]) // "[object Array]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。\n\nvar type = function (o){\n    var s = Object.prototype.toString.call(o)\n    return s.match(/\\[object (.*?)\\]/)[1].toLowerCase()\n}\ntype({}); // "object"\ntype([]); // "array"\ntype(5); // "number"\ntype(null); // "null"\ntype(); // "undefined"\ntype(/abcd/); // "regex"\ntype(new Date()); // "date"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。\n\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\n[\'Null\',\n \'Undefined\',\n \'Object\',\n \'Array\',\n \'String\',\n \'Number\',\n \'Boolean\',\n \'Function\',\n \'RegExp\'\n].forEach(function (t) {\n  type[\'is\' + t] = function (o) {\n    return type(o) === t.toLowerCase();\n  };\n});\n\ntype.isObject({}) // true\ntype.isNumber(NaN) // true\ntype.isRegExp(/abc/) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',normalizedContent:'# 比typeof运算符更准确的类型判断\n\n不同数据类型的object.prototype.tostring方法返回值如下。\n\n * 数值：返回[object number]。\n * 字符串：返回[object string]。\n * 布尔值：返回[object boolean]。\n * undefined：返回[object undefined]。\n * null：返回[object null]。\n * 数组：返回[object array]。\n * arguments 对象：返回[object arguments]。\n * 函数：返回[object function]。\n * error 对象：返回[object error]。\n * date 对象：返回[object date]。\n * regexp 对象：返回[object regexp]。\n * 其他对象：返回[object object]。\n\n这就是说，object.prototype.tostring可以看出一个值到底是什么类型。\n\nobject.prototype.tostring.call(2) // "[object number]"\nobject.prototype.tostring.call(\'\') // "[object string]"\nobject.prototype.tostring.call(true) // "[object boolean]"\nobject.prototype.tostring.call(undefined) // "[object undefined]"\nobject.prototype.tostring.call(null) // "[object null]"\nobject.prototype.tostring.call(math) // "[object math]"\nobject.prototype.tostring.call({}) // "[object object]"\nobject.prototype.tostring.call([]) // "[object array]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。\n\nvar type = function (o){\n    var s = object.prototype.tostring.call(o)\n    return s.match(/\\[object (.*?)\\]/)[1].tolowercase()\n}\ntype({}); // "object"\ntype([]); // "array"\ntype(5); // "number"\ntype(null); // "null"\ntype(); // "undefined"\ntype(/abcd/); // "regex"\ntype(new date()); // "date"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。\n\nvar type = function (o){\n  var s = object.prototype.tostring.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].tolowercase();\n};\n\n[\'null\',\n \'undefined\',\n \'object\',\n \'array\',\n \'string\',\n \'number\',\n \'boolean\',\n \'function\',\n \'regexp\'\n].foreach(function (t) {\n  type[\'is\' + t] = function (o) {\n    return type(o) === t.tolowercase();\n  };\n});\n\ntype.isobject({}) // true\ntype.isnumber(nan) // true\ntype.isregexp(/abc/) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"JS随机打乱数组",frontmatter:{title:"JS随机打乱数组",date:"2020-02-08T17:42:03.000Z",permalink:"/pages/40b4db2d38ba85f2",categories:["前端","JavaScript文章"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/50.js%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84.html",relativePath:"01.前端/25.JavaScript/50.js随机打乱数组.md",key:"v-411acbf5",path:"/pages/40b4db2d38ba85f2/",headersStr:null,content:"# JS随机打乱数组\n\nfunction shuffle(arr) { // 随机打乱数组\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\n  for (let i = 0; i < _arr.length; i++) {\n    let j = getRandomInt(0, i)\n    let t = _arr[i]\n    _arr[i] = _arr[j]\n    _arr[j] = t\n  }\n  return _arr\n}\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<html>\n  原数组：<span id=\"span1\"></span>\n  <button id=\"btn\">click me！打乱数组</button> </br></br>\n  打乱结果：<span id=\"span2\"></span>\n</html>\n<script>\n    function getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\n      return Math.floor(Math.random() * (max - min + 1) + min)\n    }\n\n    function shuffle(arr) { // 随机打乱数组\n      let _arr = arr.slice() // 调用数组副本，不改变原数组\n      for (let i = 0; i < _arr.length; i++) {\n        let j = getRandomInt(0, i)\n        let t = _arr[i]\n        _arr[i] = _arr[j]\n        _arr[j] = t\n      }\n      return _arr\n    }\n\n    //使用\n    function $(el){\n      return document.querySelector(el)\n    }\n    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const $span2 = $('#span2');\n\n    $('#span1').textContent = arr;\n    $('#btn').onclick = function () {\n      $span2.textContent = shuffle(arr);\n    }\n  <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n",normalizedContent:"# js随机打乱数组\n\nfunction shuffle(arr) { // 随机打乱数组\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\n  for (let i = 0; i < _arr.length; i++) {\n    let j = getrandomint(0, i)\n    let t = _arr[i]\n    _arr[i] = _arr[j]\n    _arr[j] = t\n  }\n  return _arr\n}\nfunction getrandomint(min, max) { // 获取min到max的一个随机数，包含min和max本身\n  return math.floor(math.random() * (max - min + 1) + min)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<html>\n  原数组：<span id=\"span1\"></span>\n  <button id=\"btn\">click me！打乱数组</button> </br></br>\n  打乱结果：<span id=\"span2\"></span>\n</html>\n<script>\n    function getrandomint(min, max) { // 获取min到max的一个随机数，包含min和max本身\n      return math.floor(math.random() * (max - min + 1) + min)\n    }\n\n    function shuffle(arr) { // 随机打乱数组\n      let _arr = arr.slice() // 调用数组副本，不改变原数组\n      for (let i = 0; i < _arr.length; i++) {\n        let j = getrandomint(0, i)\n        let t = _arr[i]\n        _arr[i] = _arr[j]\n        _arr[j] = t\n      }\n      return _arr\n    }\n\n    //使用\n    function $(el){\n      return document.queryselector(el)\n    }\n    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const $span2 = $('#span2');\n\n    $('#span1').textcontent = arr;\n    $('#btn').onclick = function () {\n      $span2.textcontent = shuffle(arr);\n    }\n  <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"将一维数组按指定长度转为二维数组",frontmatter:{title:"将一维数组按指定长度转为二维数组",date:"2020-02-23T13:49:31.000Z",permalink:"/pages/f1acb712033ac8da",categories:["前端","JavaScript文章"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript/70.%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E8%BD%AC%E4%B8%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.html",relativePath:"01.前端/25.JavaScript/70.将一维数组按指定长度转为二维数组.md",key:"v-72dfcce0",path:"/pages/f1acb712033ac8da/",headers:[{level:2,title:"应用场景示例",slug:"应用场景示例",normalizedTitle:"应用场景示例",charIndex:509}],headersStr:"应用场景示例",content:'# 将一维数组按指定长度转为二维数组\n\n将一维数组按指定长度转为二维数组\n\nfunction pages(arr, len) {\n    const pages = []\n    arr.forEach((item, index) => {\n        const page = Math.floor(index / len)\n        if (!pages[page]) {\n            pages[page] = []\n        }\n        pages[page].push(item)\n    })\n    return pages\n}\n\n// 使用\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(pages(arr, 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nconsole.log(pages(arr, 8)) // [[1, 2, 3, 4, 5, 6, 7, 8], [9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 应用场景示例\n\n如图，按需求，图标模块中的图标个数是不确定的，每页最多显示8个，超出8个的显示到第二页，实现向左滑动翻页。提供的数据是一个一维数组，这时就可以使用上面的代码按长度为8转为二维数组，再分页渲染到页面。\n\n\n\n<template>\n    <swiper>\n        <swiper-slide v-for="(page, index) of pages" :key="index">\n            <div class="icon" v-for="item of page" :key="item.id">\n                <div class="icon-img">\n                    <img :src="item.imgUrl">\n                </div>\n                <p>{{item.desc}}</p>\n            </div>\n        </swiper-slide>\n    </swiper>\n<template>\n<script>\n  ...\n  data () {\n    return {\n      iconList: [] // 图标数据\n    }\n  },\n  computed: {\n    pages () {\n      const pages = []\n      this.iconList.forEach((item, index) => {\n        const page = Math.floor(index / 8)\n        if (!pages[page]) {\n          pages[page] = []\n        }\n        pages[page].push(item)\n      })\n      return pages\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',normalizedContent:'# 将一维数组按指定长度转为二维数组\n\n将一维数组按指定长度转为二维数组\n\nfunction pages(arr, len) {\n    const pages = []\n    arr.foreach((item, index) => {\n        const page = math.floor(index / len)\n        if (!pages[page]) {\n            pages[page] = []\n        }\n        pages[page].push(item)\n    })\n    return pages\n}\n\n// 使用\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(pages(arr, 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nconsole.log(pages(arr, 8)) // [[1, 2, 3, 4, 5, 6, 7, 8], [9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 应用场景示例\n\n如图，按需求，图标模块中的图标个数是不确定的，每页最多显示8个，超出8个的显示到第二页，实现向左滑动翻页。提供的数据是一个一维数组，这时就可以使用上面的代码按长度为8转为二维数组，再分页渲染到页面。\n\n\n\n<template>\n    <swiper>\n        <swiper-slide v-for="(page, index) of pages" :key="index">\n            <div class="icon" v-for="item of page" :key="item.id">\n                <div class="icon-img">\n                    <img :src="item.imgurl">\n                </div>\n                <p>{{item.desc}}</p>\n            </div>\n        </swiper-slide>\n    </swiper>\n<template>\n<script>\n  ...\n  data () {\n    return {\n      iconlist: [] // 图标数据\n    }\n  },\n  computed: {\n    pages () {\n      const pages = []\n      this.iconlist.foreach((item, index) => {\n        const page = math.floor(index / 8)\n        if (!pages[page]) {\n          pages[page] = []\n        }\n        pages[page].push(item)\n      })\n      return pages\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"Cesium入门",frontmatter:{title:"Cesium入门",date:"2022-03-02T16:56:47.000Z",permalink:"/pages/8a70a2/",titleTag:"原创",categories:["前端","3D地图相关"],tags:["Cesium 3D","javascript"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/26.3D%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%85%B3/01.Cesium%E5%85%A5%E9%97%A8.html",relativePath:"01.前端/26.3D地图相关/01.Cesium入门.md",key:"v-2b6c3a17",path:"/pages/8a70a2/",headers:[{level:2,title:"⭐️Cesium是为3D地图而打造的开源软件",slug:"⭐️cesium是为3d地图而打造的开源软件",normalizedTitle:"⭐️cesium是为3d地图而打造的开源软件",charIndex:2},{level:3,title:"🔨安装",slug:"🔨安装",normalizedTitle:"🔨安装",charIndex:31},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:87}],excerpt:'<h2 id="⭐️cesium是为3d地图而打造的开源软件"><a class="header-anchor" href="#⭐️cesium是为3d地图而打造的开源软件">#</a> ⭐️Cesium是为3D地图而打造的开源软件</h2>\n<p align="center"><img src="/img/WX20220303-003218@2x.png" width="500" style="cursor: zoom-in;"></p>\n',headersStr:"⭐️Cesium是为3D地图而打造的开源软件 🔨安装 使用",content:'# ⭐️Cesium是为3D地图而打造的开源软件\n\n\n\n\n# 🔨安装\n\n> 虽然作为一名前端开发人员，但并非gis专业人士，所以推荐这个微信公众号，专门讲解cesium如何使用的\n\n注意\n\n🐛Cesium并非cnpm i cesium直接就结束了，它需要在webpack中添加额外的参数配置并引入相关资源文件\n\n> 当前使用的版本号为 "vue": "^2.6.12","cesium": "^1.73.0","@vue/cli-service": "~4.5.0",\n\nmodule.exports = {\n  lintOnSave: false,\n  publicPath:\n    process.env.NODE_ENV === "production" ? "/\\n" + "vue-cesium-example/" : "/",\n  configureWebpack: {\n    plugins: [\n      // Copy Cesium Assets, Widgets, and Workers to a static directory\n      new CopyWebpackPlugin({\n        patterns: [\n          { from: "node_modules/cesium/Build/Cesium/Workers", to: "Workers" },\n          {\n            from: "node_modules/cesium/Build/Cesium/ThirdParty",\n            to: "ThirdParty"\n          },\n          { from: "node_modules/cesium/Build/Cesium/Assets", to: "Assets" },\n          { from: "node_modules/cesium/Build/Cesium/Widgets", to: "Widgets" }\n        ]\n      }),\n      new webpack.DefinePlugin({\n        // Define relative base path in cesium for loading assets\n        CESIUM_BASE_URL: JSON.stringify("")\n      })\n    ],\n    module: {\n      // Removes these errors: "Critical dependency: require function is used in a way in which dependencies cannot be statically extracted"\n      // https://github.com/AnalyticalGraphicsInc/cesium-webpack-example/issues/6\n      unknownContextCritical: false,\n      unknownContextRegExp: /\\/cesium\\/cesium\\/Source\\/Core\\/buildModuleUrl\\.js/\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> 推荐一套为 GISer 准备的基于 Vue 2.x & Vue 3.x 的 CesiumJS 组件库 VueCesium,减少开发工作量.\n\n\n# 使用\n\n> 使用vue中的template语法按照官方文档提供的例子即可实现一个如下所示的地图\n\n\n\n注意\n\n启动项目后可能会有cesium文件找不到的错误，此时需要将cesium的build包放入public中static文件夹下面，并引用public下面的cesium中js和css， 注意路径的正确性 以保证正常引入\n\n点击查看\n\n\n<template>\n  <div id="cesiumContainer"></div>\n</template>\n\n<script>\nimport "cesium/Build/Cesium/Widgets/widgets.css";\nimport * as Cesium from "cesium";\nimport AmapImageryProvider from "@/transform/AmapImageryProvider";\nimport "./Sandcastle-header";\nfunction startup(Cesium) {\n  \'use strict\';\n//Sandcastle_Begin\n  const viewer = new Cesium.Viewer("cesiumContainer", {\n    terrainProvider: Cesium.createWorldTerrain(),\n  });\n\n  const tileset = new Cesium.Cesium3DTileset({\n    url: Cesium.IonResource.fromAssetId(40866),\n  });\n  viewer.scene.primitives.add(tileset);\n\n  tileset.readyPromise.then(function () {\n    const boundingSphere = tileset.boundingSphere;\n    viewer.camera.viewBoundingSphere(\n        boundingSphere,\n        new Cesium.HeadingPitchRange(\n            0.0,\n            -0.5,\n            boundingSphere.radius + 500.0\n        )\n    );\n    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);\n  });\n\n  const polygon = viewer.entities.add({\n    polygon: {\n      hierarchy: new Cesium.PolygonHierarchy(\n          Cesium.Cartesian3.fromRadiansArray([\n            -1.3194369277314022,\n            0.6988062530900625,\n            -1.3193955980204217,\n            0.6988091578771254,\n            -1.3193931220959367,\n            0.698743632490865,\n            -1.3194358224045408,\n            0.6987471965556998,\n          ])\n      ),\n      material: Cesium.Color.RED.withAlpha(0.5),\n      classificationType: Cesium.ClassificationType.BOTH,\n    },\n  });\n\n  const polyline = viewer.entities.add({\n    polyline: {\n      positions: Cesium.Cartesian3.fromDegreesArray([\n        -75.60217330403601,\n        40.04102882709425,\n        -75.59968252414251,\n        40.04093615560871,\n        -75.598020153828,\n        40.04079437042357,\n        -75.59674934074435,\n        40.040816173283304,\n        -75.59630042791713,\n        40.03986900370842,\n        -75.59563636849978,\n        40.03930996506271,\n        -75.59492397899098,\n        40.03873932846581,\n        -75.59457991226778,\n        40.038392701955786,\n        -75.59424838652453,\n        40.03775403572295,\n        -75.59387104290336,\n        40.03677022167725,\n        -75.59355000490342,\n        40.03588760913535,\n      ]),\n      width: 8,\n      material: new Cesium.PolylineOutlineMaterialProperty({\n        color: Cesium.Color.YELLOW,\n        outlineWidth: 2,\n        outlineColor: Cesium.Color.BLACK,\n      }),\n      clampToGround: true,\n    },\n  });\n\n  const classificationOptions = [\n    {\n      text: "Classify Both",\n      onselect: function () {\n        polygon.polygon.classificationType =\n            Cesium.ClassificationType.BOTH;\n        polyline.polyline.classificationType =\n            Cesium.ClassificationType.BOTH;\n      },\n    },\n    {\n      text: "Classify Terrain",\n      onselect: function () {\n        polygon.polygon.classificationType =\n            Cesium.ClassificationType.TERRAIN;\n        polyline.polyline.classificationType =\n            Cesium.ClassificationType.TERRAIN;\n      },\n    },\n    {\n      text: "Classify 3D Tiles",\n      onselect: function () {\n        polygon.polygon.classificationType =\n            Cesium.ClassificationType.CESIUM_3D_TILE;\n        polyline.polyline.classificationType =\n            Cesium.ClassificationType.CESIUM_3D_TILE;\n      },\n    },\n  ];\n\n  const materialOptions = [\n    {\n      text: "Red Material",\n      onselect: function () {\n        polygon.polygon.material = Cesium.Color.RED.withAlpha(0.5);\n      },\n    },\n    {\n      text: "Textured Material",\n      onselect: function () {\n        if (\n            !Cesium.Entity.supportsMaterialsforEntitiesOnTerrain(\n                viewer.scene\n            )\n        ) {\n          window.alert(\n              "Terrain Entity materials are not supported on this platform"\n          );\n        }\n        polygon.polygon.material = "../images/Cesium_Logo_Color.jpg";\n      },\n    },\n  ];\n\n  Sandcastle.addToolbarMenu(classificationOptions);\n  Sandcastle.addToolbarMenu(materialOptions);\n//Sandcastle_End\n  Sandcastle.finishedLoading();\n}\n\nexport default {\n  name: "Map",\n  mounted() {\n    startup(Cesium)\n  },\n  methods: {\n    init() {\n      const viewer = new Cesium.Viewer("cesiumContainer", {\n        shouldAnimate: true\n      });\n      const planePosition = Cesium.Cartesian3.fromDegrees(\n        -75.59777,\n        40.03883,\n        800.0\n      );\n      const particlesOffset = new Cesium.Cartesian3(\n        -8.950115473940969,\n        34.852766731753945,\n        -30.235411095432937\n      );\n      const cameraLocation = Cesium.Cartesian3.add(\n        planePosition,\n        particlesOffset,\n        new Cesium.Cartesian3()\n      );\n      const resetCamera = function() {\n        viewer.camera.lookAt(\n          cameraLocation,\n          new Cesium.Cartesian3(-450, -300, 200)\n        );\n      };\n      resetCamera();\n\n      // Draw particle image to a canvas\n      let particleCanvas;\n      function getImage() {\n        if (!Cesium.defined(particleCanvas)) {\n          particleCanvas = document.createElement("canvas");\n          particleCanvas.width = 20;\n          particleCanvas.height = 20;\n          const context2D = particleCanvas.getContext("2d");\n          context2D.beginPath();\n          context2D.arc(8, 8, 8, 0, Cesium.Math.TWO_PI, true);\n          context2D.closePath();\n          context2D.fillStyle = "rgb(255, 255, 255)";\n          context2D.fill();\n        }\n        return particleCanvas;\n      }\n\n      // Add plane to scene\n      const hpr = new Cesium.HeadingPitchRoll(\n        0.0,\n        Cesium.Math.PI_OVER_TWO,\n        0.0\n      );\n      const orientation = Cesium.Transforms.headingPitchRollQuaternion(\n        planePosition,\n        hpr\n      );\n      const entity = viewer.entities.add({\n        model: {\n          uri: "../SampleData/models/CesiumAir/Cesium_Air.glb",\n          scale: 3.5\n        },\n        position: planePosition,\n        orientation: orientation\n      });\n\n      // creating particles model matrix\n      const translationOffset = Cesium.Matrix4.fromTranslation(\n        particlesOffset,\n        new Cesium.Matrix4()\n      );\n      const translationOfPlane = Cesium.Matrix4.fromTranslation(\n        planePosition,\n        new Cesium.Matrix4()\n      );\n      const particlesModelMatrix = Cesium.Matrix4.multiplyTransformation(\n        translationOfPlane,\n        translationOffset,\n        new Cesium.Matrix4()\n      );\n\n      // creating the particle systems\n      const rocketOptions = {\n        numberOfSystems: 50.0,\n        iterationOffset: 0.1,\n        cartographicStep: 0.000001,\n        baseRadius: 0.0005,\n\n        colorOptions: [\n          {\n            minimumRed: 1.0,\n            green: 0.5,\n            minimumBlue: 0.05,\n            alpha: 1.0\n          },\n          {\n            red: 0.9,\n            minimumGreen: 0.6,\n            minimumBlue: 0.01,\n            alpha: 1.0\n          },\n          {\n            red: 0.8,\n            green: 0.05,\n            minimumBlue: 0.09,\n            alpha: 1.0\n          },\n          {\n            minimumRed: 1,\n            minimumGreen: 0.05,\n            blue: 0.09,\n            alpha: 1.0\n          }\n        ]\n      };\n\n      const cometOptions = {\n        numberOfSystems: 100.0,\n        iterationOffset: 0.003,\n        cartographicStep: 0.0000001,\n        baseRadius: 0.0005,\n\n        colorOptions: [\n          {\n            red: 0.6,\n            green: 0.6,\n            blue: 0.6,\n            alpha: 1.0\n          },\n          {\n            red: 0.6,\n            green: 0.6,\n            blue: 0.9,\n            alpha: 0.9\n          },\n          {\n            red: 0.5,\n            green: 0.5,\n            blue: 0.7,\n            alpha: 0.5\n          }\n        ]\n      };\n\n      let scratchCartesian3 = new Cesium.Cartesian3();\n      let scratchCartographic = new Cesium.Cartographic();\n      const forceFunction = function(options, iteration) {\n        return function(particle, dt) {\n          dt = Cesium.Math.clamp(dt, 0.0, 0.05);\n\n          scratchCartesian3 = Cesium.Cartesian3.normalize(\n            particle.position,\n            new Cesium.Cartesian3()\n          );\n          scratchCartesian3 = Cesium.Cartesian3.multiplyByScalar(\n            scratchCartesian3,\n            -40.0 * dt,\n            scratchCartesian3\n          );\n\n          scratchCartesian3 = Cesium.Cartesian3.add(\n            particle.position,\n            scratchCartesian3,\n            scratchCartesian3\n          );\n\n          scratchCartographic = Cesium.Cartographic.fromCartesian(\n            scratchCartesian3,\n            Cesium.Ellipsoid.WGS84,\n            scratchCartographic\n          );\n\n          const angle =\n            (Cesium.Math.PI * 2.0 * iteration) / options.numberOfSystems;\n          iteration += options.iterationOffset;\n          scratchCartographic.longitude +=\n            Math.cos(angle) * options.cartographicStep * 30.0 * dt;\n          scratchCartographic.latitude +=\n            Math.sin(angle) * options.cartographicStep * 30.0 * dt;\n\n          particle.position = Cesium.Cartographic.toCartesian(\n            scratchCartographic\n          );\n        };\n      };\n\n      const matrix4Scratch = new Cesium.Matrix4();\n      let scratchAngleForOffset = 0.0;\n      const scratchOffset = new Cesium.Cartesian3();\n      const imageSize = new Cesium.Cartesian2(15.0, 15.0);\n      function createParticleSystems(options, systemsArray) {\n        const length = options.numberOfSystems;\n        for (let i = 0; i < length; ++i) {\n          scratchAngleForOffset = (Math.PI * 2.0 * i) / options.numberOfSystems;\n          scratchOffset.x +=\n            options.baseRadius * Math.cos(scratchAngleForOffset);\n          scratchOffset.y +=\n            options.baseRadius * Math.sin(scratchAngleForOffset);\n\n          const emitterModelMatrix = Cesium.Matrix4.fromTranslation(\n            scratchOffset,\n            matrix4Scratch\n          );\n          const color = Cesium.Color.fromRandom(\n            options.colorOptions[i % options.colorOptions.length]\n          );\n          const force = forceFunction(options, i);\n\n          const item = viewer.scene.primitives.add(\n            new Cesium.ParticleSystem({\n              image: getImage(),\n              startColor: color,\n              endColor: color.withAlpha(0.0),\n              particleLife: 3.5,\n              speed: 0.00005,\n              imageSize: imageSize,\n              emissionRate: 30.0,\n              emitter: new Cesium.CircleEmitter(0.1),\n              lifetime: 0.1,\n              updateCallback: force,\n              modelMatrix: particlesModelMatrix,\n              emitterModelMatrix: emitterModelMatrix\n            })\n          );\n          systemsArray.push(item);\n        }\n      }\n\n      const rocketSystems = [];\n      const cometSystems = [];\n      createParticleSystems(rocketOptions, rocketSystems);\n      createParticleSystems(cometOptions, cometSystems);\n\n      // toolbar elements\n      function showAll(systemsArray, show) {\n        const length = systemsArray.length;\n        for (let i = 0; i < length; ++i) {\n          systemsArray[i].show = show;\n        }\n      }\n\n      const options = [\n        {\n          text: "Comet Tail",\n          onselect: function() {\n            showAll(rocketSystems, false);\n            showAll(cometSystems, true);\n            resetCamera();\n          }\n        },\n        {\n          text: "Rocket Thruster",\n          onselect: function() {\n            showAll(cometSystems, false);\n            showAll(rocketSystems, true);\n            resetCamera();\n          }\n        }\n      ];\n      Sandcastle.addToolbarMenu(options);\n    }\n  }\n};\n<\/script>\n\n<style lang="scss">\n#cesiumContainer {\n  width: 100vw;\n  height: 100vh;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.cesium-viewer-bottom {\n  display: none !important;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n',normalizedContent:'# ⭐️cesium是为3d地图而打造的开源软件\n\n\n\n\n# 🔨安装\n\n> 虽然作为一名前端开发人员，但并非gis专业人士，所以推荐这个微信公众号，专门讲解cesium如何使用的\n\n注意\n\n🐛cesium并非cnpm i cesium直接就结束了，它需要在webpack中添加额外的参数配置并引入相关资源文件\n\n> 当前使用的版本号为 "vue": "^2.6.12","cesium": "^1.73.0","@vue/cli-service": "~4.5.0",\n\nmodule.exports = {\n  lintonsave: false,\n  publicpath:\n    process.env.node_env === "production" ? "/\\n" + "vue-cesium-example/" : "/",\n  configurewebpack: {\n    plugins: [\n      // copy cesium assets, widgets, and workers to a static directory\n      new copywebpackplugin({\n        patterns: [\n          { from: "node_modules/cesium/build/cesium/workers", to: "workers" },\n          {\n            from: "node_modules/cesium/build/cesium/thirdparty",\n            to: "thirdparty"\n          },\n          { from: "node_modules/cesium/build/cesium/assets", to: "assets" },\n          { from: "node_modules/cesium/build/cesium/widgets", to: "widgets" }\n        ]\n      }),\n      new webpack.defineplugin({\n        // define relative base path in cesium for loading assets\n        cesium_base_url: json.stringify("")\n      })\n    ],\n    module: {\n      // removes these errors: "critical dependency: require function is used in a way in which dependencies cannot be statically extracted"\n      // https://github.com/analyticalgraphicsinc/cesium-webpack-example/issues/6\n      unknowncontextcritical: false,\n      unknowncontextregexp: /\\/cesium\\/cesium\\/source\\/core\\/buildmoduleurl\\.js/\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> 推荐一套为 giser 准备的基于 vue 2.x & vue 3.x 的 cesiumjs 组件库 vuecesium,减少开发工作量.\n\n\n# 使用\n\n> 使用vue中的template语法按照官方文档提供的例子即可实现一个如下所示的地图\n\n\n\n注意\n\n启动项目后可能会有cesium文件找不到的错误，此时需要将cesium的build包放入public中static文件夹下面，并引用public下面的cesium中js和css， 注意路径的正确性 以保证正常引入\n\n点击查看\n\n\n<template>\n  <div id="cesiumcontainer"></div>\n</template>\n\n<script>\nimport "cesium/build/cesium/widgets/widgets.css";\nimport * as cesium from "cesium";\nimport amapimageryprovider from "@/transform/amapimageryprovider";\nimport "./sandcastle-header";\nfunction startup(cesium) {\n  \'use strict\';\n//sandcastle_begin\n  const viewer = new cesium.viewer("cesiumcontainer", {\n    terrainprovider: cesium.createworldterrain(),\n  });\n\n  const tileset = new cesium.cesium3dtileset({\n    url: cesium.ionresource.fromassetid(40866),\n  });\n  viewer.scene.primitives.add(tileset);\n\n  tileset.readypromise.then(function () {\n    const boundingsphere = tileset.boundingsphere;\n    viewer.camera.viewboundingsphere(\n        boundingsphere,\n        new cesium.headingpitchrange(\n            0.0,\n            -0.5,\n            boundingsphere.radius + 500.0\n        )\n    );\n    viewer.camera.lookattransform(cesium.matrix4.identity);\n  });\n\n  const polygon = viewer.entities.add({\n    polygon: {\n      hierarchy: new cesium.polygonhierarchy(\n          cesium.cartesian3.fromradiansarray([\n            -1.3194369277314022,\n            0.6988062530900625,\n            -1.3193955980204217,\n            0.6988091578771254,\n            -1.3193931220959367,\n            0.698743632490865,\n            -1.3194358224045408,\n            0.6987471965556998,\n          ])\n      ),\n      material: cesium.color.red.withalpha(0.5),\n      classificationtype: cesium.classificationtype.both,\n    },\n  });\n\n  const polyline = viewer.entities.add({\n    polyline: {\n      positions: cesium.cartesian3.fromdegreesarray([\n        -75.60217330403601,\n        40.04102882709425,\n        -75.59968252414251,\n        40.04093615560871,\n        -75.598020153828,\n        40.04079437042357,\n        -75.59674934074435,\n        40.040816173283304,\n        -75.59630042791713,\n        40.03986900370842,\n        -75.59563636849978,\n        40.03930996506271,\n        -75.59492397899098,\n        40.03873932846581,\n        -75.59457991226778,\n        40.038392701955786,\n        -75.59424838652453,\n        40.03775403572295,\n        -75.59387104290336,\n        40.03677022167725,\n        -75.59355000490342,\n        40.03588760913535,\n      ]),\n      width: 8,\n      material: new cesium.polylineoutlinematerialproperty({\n        color: cesium.color.yellow,\n        outlinewidth: 2,\n        outlinecolor: cesium.color.black,\n      }),\n      clamptoground: true,\n    },\n  });\n\n  const classificationoptions = [\n    {\n      text: "classify both",\n      onselect: function () {\n        polygon.polygon.classificationtype =\n            cesium.classificationtype.both;\n        polyline.polyline.classificationtype =\n            cesium.classificationtype.both;\n      },\n    },\n    {\n      text: "classify terrain",\n      onselect: function () {\n        polygon.polygon.classificationtype =\n            cesium.classificationtype.terrain;\n        polyline.polyline.classificationtype =\n            cesium.classificationtype.terrain;\n      },\n    },\n    {\n      text: "classify 3d tiles",\n      onselect: function () {\n        polygon.polygon.classificationtype =\n            cesium.classificationtype.cesium_3d_tile;\n        polyline.polyline.classificationtype =\n            cesium.classificationtype.cesium_3d_tile;\n      },\n    },\n  ];\n\n  const materialoptions = [\n    {\n      text: "red material",\n      onselect: function () {\n        polygon.polygon.material = cesium.color.red.withalpha(0.5);\n      },\n    },\n    {\n      text: "textured material",\n      onselect: function () {\n        if (\n            !cesium.entity.supportsmaterialsforentitiesonterrain(\n                viewer.scene\n            )\n        ) {\n          window.alert(\n              "terrain entity materials are not supported on this platform"\n          );\n        }\n        polygon.polygon.material = "../images/cesium_logo_color.jpg";\n      },\n    },\n  ];\n\n  sandcastle.addtoolbarmenu(classificationoptions);\n  sandcastle.addtoolbarmenu(materialoptions);\n//sandcastle_end\n  sandcastle.finishedloading();\n}\n\nexport default {\n  name: "map",\n  mounted() {\n    startup(cesium)\n  },\n  methods: {\n    init() {\n      const viewer = new cesium.viewer("cesiumcontainer", {\n        shouldanimate: true\n      });\n      const planeposition = cesium.cartesian3.fromdegrees(\n        -75.59777,\n        40.03883,\n        800.0\n      );\n      const particlesoffset = new cesium.cartesian3(\n        -8.950115473940969,\n        34.852766731753945,\n        -30.235411095432937\n      );\n      const cameralocation = cesium.cartesian3.add(\n        planeposition,\n        particlesoffset,\n        new cesium.cartesian3()\n      );\n      const resetcamera = function() {\n        viewer.camera.lookat(\n          cameralocation,\n          new cesium.cartesian3(-450, -300, 200)\n        );\n      };\n      resetcamera();\n\n      // draw particle image to a canvas\n      let particlecanvas;\n      function getimage() {\n        if (!cesium.defined(particlecanvas)) {\n          particlecanvas = document.createelement("canvas");\n          particlecanvas.width = 20;\n          particlecanvas.height = 20;\n          const context2d = particlecanvas.getcontext("2d");\n          context2d.beginpath();\n          context2d.arc(8, 8, 8, 0, cesium.math.two_pi, true);\n          context2d.closepath();\n          context2d.fillstyle = "rgb(255, 255, 255)";\n          context2d.fill();\n        }\n        return particlecanvas;\n      }\n\n      // add plane to scene\n      const hpr = new cesium.headingpitchroll(\n        0.0,\n        cesium.math.pi_over_two,\n        0.0\n      );\n      const orientation = cesium.transforms.headingpitchrollquaternion(\n        planeposition,\n        hpr\n      );\n      const entity = viewer.entities.add({\n        model: {\n          uri: "../sampledata/models/cesiumair/cesium_air.glb",\n          scale: 3.5\n        },\n        position: planeposition,\n        orientation: orientation\n      });\n\n      // creating particles model matrix\n      const translationoffset = cesium.matrix4.fromtranslation(\n        particlesoffset,\n        new cesium.matrix4()\n      );\n      const translationofplane = cesium.matrix4.fromtranslation(\n        planeposition,\n        new cesium.matrix4()\n      );\n      const particlesmodelmatrix = cesium.matrix4.multiplytransformation(\n        translationofplane,\n        translationoffset,\n        new cesium.matrix4()\n      );\n\n      // creating the particle systems\n      const rocketoptions = {\n        numberofsystems: 50.0,\n        iterationoffset: 0.1,\n        cartographicstep: 0.000001,\n        baseradius: 0.0005,\n\n        coloroptions: [\n          {\n            minimumred: 1.0,\n            green: 0.5,\n            minimumblue: 0.05,\n            alpha: 1.0\n          },\n          {\n            red: 0.9,\n            minimumgreen: 0.6,\n            minimumblue: 0.01,\n            alpha: 1.0\n          },\n          {\n            red: 0.8,\n            green: 0.05,\n            minimumblue: 0.09,\n            alpha: 1.0\n          },\n          {\n            minimumred: 1,\n            minimumgreen: 0.05,\n            blue: 0.09,\n            alpha: 1.0\n          }\n        ]\n      };\n\n      const cometoptions = {\n        numberofsystems: 100.0,\n        iterationoffset: 0.003,\n        cartographicstep: 0.0000001,\n        baseradius: 0.0005,\n\n        coloroptions: [\n          {\n            red: 0.6,\n            green: 0.6,\n            blue: 0.6,\n            alpha: 1.0\n          },\n          {\n            red: 0.6,\n            green: 0.6,\n            blue: 0.9,\n            alpha: 0.9\n          },\n          {\n            red: 0.5,\n            green: 0.5,\n            blue: 0.7,\n            alpha: 0.5\n          }\n        ]\n      };\n\n      let scratchcartesian3 = new cesium.cartesian3();\n      let scratchcartographic = new cesium.cartographic();\n      const forcefunction = function(options, iteration) {\n        return function(particle, dt) {\n          dt = cesium.math.clamp(dt, 0.0, 0.05);\n\n          scratchcartesian3 = cesium.cartesian3.normalize(\n            particle.position,\n            new cesium.cartesian3()\n          );\n          scratchcartesian3 = cesium.cartesian3.multiplybyscalar(\n            scratchcartesian3,\n            -40.0 * dt,\n            scratchcartesian3\n          );\n\n          scratchcartesian3 = cesium.cartesian3.add(\n            particle.position,\n            scratchcartesian3,\n            scratchcartesian3\n          );\n\n          scratchcartographic = cesium.cartographic.fromcartesian(\n            scratchcartesian3,\n            cesium.ellipsoid.wgs84,\n            scratchcartographic\n          );\n\n          const angle =\n            (cesium.math.pi * 2.0 * iteration) / options.numberofsystems;\n          iteration += options.iterationoffset;\n          scratchcartographic.longitude +=\n            math.cos(angle) * options.cartographicstep * 30.0 * dt;\n          scratchcartographic.latitude +=\n            math.sin(angle) * options.cartographicstep * 30.0 * dt;\n\n          particle.position = cesium.cartographic.tocartesian(\n            scratchcartographic\n          );\n        };\n      };\n\n      const matrix4scratch = new cesium.matrix4();\n      let scratchangleforoffset = 0.0;\n      const scratchoffset = new cesium.cartesian3();\n      const imagesize = new cesium.cartesian2(15.0, 15.0);\n      function createparticlesystems(options, systemsarray) {\n        const length = options.numberofsystems;\n        for (let i = 0; i < length; ++i) {\n          scratchangleforoffset = (math.pi * 2.0 * i) / options.numberofsystems;\n          scratchoffset.x +=\n            options.baseradius * math.cos(scratchangleforoffset);\n          scratchoffset.y +=\n            options.baseradius * math.sin(scratchangleforoffset);\n\n          const emittermodelmatrix = cesium.matrix4.fromtranslation(\n            scratchoffset,\n            matrix4scratch\n          );\n          const color = cesium.color.fromrandom(\n            options.coloroptions[i % options.coloroptions.length]\n          );\n          const force = forcefunction(options, i);\n\n          const item = viewer.scene.primitives.add(\n            new cesium.particlesystem({\n              image: getimage(),\n              startcolor: color,\n              endcolor: color.withalpha(0.0),\n              particlelife: 3.5,\n              speed: 0.00005,\n              imagesize: imagesize,\n              emissionrate: 30.0,\n              emitter: new cesium.circleemitter(0.1),\n              lifetime: 0.1,\n              updatecallback: force,\n              modelmatrix: particlesmodelmatrix,\n              emittermodelmatrix: emittermodelmatrix\n            })\n          );\n          systemsarray.push(item);\n        }\n      }\n\n      const rocketsystems = [];\n      const cometsystems = [];\n      createparticlesystems(rocketoptions, rocketsystems);\n      createparticlesystems(cometoptions, cometsystems);\n\n      // toolbar elements\n      function showall(systemsarray, show) {\n        const length = systemsarray.length;\n        for (let i = 0; i < length; ++i) {\n          systemsarray[i].show = show;\n        }\n      }\n\n      const options = [\n        {\n          text: "comet tail",\n          onselect: function() {\n            showall(rocketsystems, false);\n            showall(cometsystems, true);\n            resetcamera();\n          }\n        },\n        {\n          text: "rocket thruster",\n          onselect: function() {\n            showall(cometsystems, false);\n            showall(rocketsystems, true);\n            resetcamera();\n          }\n        }\n      ];\n      sandcastle.addtoolbarmenu(options);\n    }\n  }\n};\n<\/script>\n\n<style lang="scss">\n#cesiumcontainer {\n  width: 100vw;\n  height: 100vh;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.cesium-viewer-bottom {\n  display: none !important;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n',charsets:{cjk:!0},lastUpdated:"2022/03/30, 09:09:08",lastUpdatedTimestamp:1648631348e3},{title:"Cesium一般使用",frontmatter:{title:"Cesium一般使用",date:"2022-03-03T00:29:45.000Z",permalink:"/pages/8382fc/",titleTag:"原创",categories:["前端","3D地图相关"],tags:["Cesium 3D","javascript"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/26.3D%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%85%B3/02.Cesium%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8.html",relativePath:"01.前端/26.3D地图相关/02.Cesium一般使用.md",key:"v-7632d62e",path:"/pages/8382fc/",headers:[{level:2,title:"这篇文章将讲解cesium在项目中常用的api",slug:"这篇文章将讲解cesium在项目中常用的api",normalizedTitle:"这篇文章将讲解cesium在项目中常用的api",charIndex:2}],headersStr:"这篇文章将讲解cesium在项目中常用的api",content:"# 这篇文章将讲解cesium在项目中常用的api",normalizedContent:"# 这篇文章将讲解cesium在项目中常用的api",charsets:{cjk:!0},lastUpdated:"2022/03/02, 16:40:35",lastUpdatedTimestamp:1646239235e3},{title:"DevUI Design",frontmatter:{title:"DevUI Design",date:"2022-03-30T16:52:27.000Z",permalink:"/open/8599a5b876fc95e4",titleTag:"UI组件库",article:!1,sidebar:!1,sticky:1,categories:["开源"],tags:["vite","typescript","vue3"]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/00.DevUI.html",relativePath:"02.页面/00.DevUI.md",key:"v-34f679a5",path:"/open/8599a5b876fc95e4/",headers:[{level:2,title:"🔧 如何使用",slug:"🔧-如何使用",normalizedTitle:"🔧 如何使用",charIndex:189},{level:3,title:"1. 安装",slug:"_1-安装",normalizedTitle:"1. 安装",charIndex:201},{level:3,title:"2. 引入",slug:"_2-引入",normalizedTitle:"2. 引入",charIndex:233},{level:3,title:"3. 使用",slug:"_3-使用",normalizedTitle:"3. 使用",charIndex:472},{level:2,title:"🖥️ 本地开发",slug:"🖥️-本地开发",normalizedTitle:"🖥️ 本地开发",charIndex:570},{level:2,title:"🤝 参与贡献",slug:"🤝-参与贡献",normalizedTitle:"🤝 参与贡献",charIndex:706},{level:2,title:"✨ 贡献者",slug:"✨-贡献者",normalizedTitle:"✨ 贡献者",charIndex:903},{level:2,title:"开源许可",slug:"开源许可",normalizedTitle:"开源许可",charIndex:1456}],headersStr:"🔧 如何使用 1. 安装 2. 引入 3. 使用 🖥️ 本地开发 🤝 参与贡献 ✨ 贡献者 开源许可",content:"Vue DevUI\n\n一个基于 DevUI Design 的 Vue3 组件库。\n\n简体中文\n\n🌈 特性：\n\n * 📦 包含 40 个简洁、易用、灵活的高质量组件\n * 🔑 支持 TypeScript\n * ⛰️ 支持 Nuxt3\n * ⚡ 支持按需引入\n * 🌍 支持国际化\n * 🎨 支持主题定制，并内置 追光 / 蜜糖 / 紫罗兰 等 7 种漂亮的主题\n\n\n# 🔧 如何使用\n\n\n# 1. 安装\n\nnpm i vue-devui\n\n\n1\n\n\n\n# 2. 引入\n\n在main.ts文件中引入vue-devui。\n\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n// 引入 Vue DevUI 组件库及样式\nimport DevUI from 'vue-devui'\nimport 'vue-devui/style.css'\n\ncreateApp(App).use(DevUI).mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. 使用\n\n在App.vue文件中使用 Vue DevUI 组件。\n\n<template>\n  <d-button>确定</d-button>\n</template>\n\n\n1\n2\n3\n\n\n\n# 🖥️ 本地开发\n\ngit clone git@github.com:DevCloudFE/vue-devui.git\ncd vue-devui\npnpm i\npnpm dev\n\n\n1\n2\n3\n4\n\n\n打开浏览器访问：http://localhost:3000/\n\n\n# 🤝 参与贡献\n\n欢迎你参与到 Vue DevUI 项目的建设中来！🎉\n\n通过参与 Vue DevUI 项目，我们可以一起：\n\n * 🔥 学习最新的 Vite+Vue3+TypeScript+JSX 技术\n * 🎁 学习如何设计和开发组件\n * ⭐ 磨练编程技能，学习优秀的编程实践\n * 🎊 结识一群热爱学习、热爱开源的朋友\n\n如果你不知道从哪儿开始，可以阅读我们的贡献指南\n\n\n# ✨ 贡献者\n\n感谢以下 DevUI 的田主们 (emoji key):\n\nKagol        TinsFox     nif         Zcating   王凯      iel     chenxi24\n🚧 💻 📖     🚧 🚇       💻          🚧 💻     💻      🚧 💻   💻\n小九九          AlanLee     Echo        GaoNeng   行言      devin   无声\n💻           💻          💻          💻        💻      💻      💻\nsleep_fish   迷心whylost   X.Q. Chen   葉家男孩      lihai   纳撸多     ElsaOOo\n💻           💻          🚇 💻       💻        💻      💻      🚧 🚇 💻\n刘小迪          unfound     Roading\n💻           💻          💻\n\n该项目遵循 all-contributors 规范。欢迎任何形式的贡献！\n\n\n# 开源许可\n\nMIT",normalizedContent:"vue devui\n\n一个基于 devui design 的 vue3 组件库。\n\n简体中文\n\n🌈 特性：\n\n * 📦 包含 40 个简洁、易用、灵活的高质量组件\n * 🔑 支持 typescript\n * ⛰️ 支持 nuxt3\n * ⚡ 支持按需引入\n * 🌍 支持国际化\n * 🎨 支持主题定制，并内置 追光 / 蜜糖 / 紫罗兰 等 7 种漂亮的主题\n\n\n# 🔧 如何使用\n\n\n# 1. 安装\n\nnpm i vue-devui\n\n\n1\n\n\n\n# 2. 引入\n\n在main.ts文件中引入vue-devui。\n\nimport { createapp } from 'vue'\nimport app from './app.vue'\n\n// 引入 vue devui 组件库及样式\nimport devui from 'vue-devui'\nimport 'vue-devui/style.css'\n\ncreateapp(app).use(devui).mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. 使用\n\n在app.vue文件中使用 vue devui 组件。\n\n<template>\n  <d-button>确定</d-button>\n</template>\n\n\n1\n2\n3\n\n\n\n# 🖥️ 本地开发\n\ngit clone git@github.com:devcloudfe/vue-devui.git\ncd vue-devui\npnpm i\npnpm dev\n\n\n1\n2\n3\n4\n\n\n打开浏览器访问：http://localhost:3000/\n\n\n# 🤝 参与贡献\n\n欢迎你参与到 vue devui 项目的建设中来！🎉\n\n通过参与 vue devui 项目，我们可以一起：\n\n * 🔥 学习最新的 vite+vue3+typescript+jsx 技术\n * 🎁 学习如何设计和开发组件\n * ⭐ 磨练编程技能，学习优秀的编程实践\n * 🎊 结识一群热爱学习、热爱开源的朋友\n\n如果你不知道从哪儿开始，可以阅读我们的贡献指南\n\n\n# ✨ 贡献者\n\n感谢以下 devui 的田主们 (emoji key):\n\nkagol        tinsfox     nif         zcating   王凯      iel     chenxi24\n🚧 💻 📖     🚧 🚇       💻          🚧 💻     💻      🚧 💻   💻\n小九九          alanlee     echo        gaoneng   行言      devin   无声\n💻           💻          💻          💻        💻      💻      💻\nsleep_fish   迷心whylost   x.q. chen   葉家男孩      lihai   纳撸多     elsaooo\n💻           💻          🚇 💻       💻        💻      💻      🚧 🚇 💻\n刘小迪          unfound     roading\n💻           💻          💻\n\n该项目遵循 all-contributors 规范。欢迎任何形式的贡献！\n\n\n# 开源许可\n\nmit",charsets:{cjk:!0},lastUpdated:"2022/04/05, 06:55:19",lastUpdatedTimestamp:1649141719e3},{title:"vuecli template",frontmatter:{title:"vuecli template",date:"2022-03-30T16:52:13.000Z",permalink:"/open/8599a5b876fc95e3",titleTag:"原创",sticky:1,categories:["开源"],tags:["webpack","typescript","vue3"]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/01.enalPro.html",relativePath:"02.页面/01.enalPro.md",key:"v-613ea943",path:"/open/8599a5b876fc95e3/",headers:[{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:28},{level:2,title:"预配置",slug:"预配置",normalizedTitle:"预配置",charIndex:346},{level:3,title:"UI 框架",slug:"ui-框架",normalizedTitle:"ui 框架",charIndex:354},{level:3,title:"Icons",slug:"icons",normalizedTitle:"icons",charIndex:400},{level:3,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:467},{level:3,title:"编码风格",slug:"编码风格",normalizedTitle:"编码风格",charIndex:640},{level:3,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:742},{level:2,title:"Git 提交规范",slug:"git-提交规范",normalizedTitle:"git 提交规范",charIndex:996},{level:2,title:"当然，非常推荐大家使用vite",slug:"当然-非常推荐大家使用vite",normalizedTitle:"当然，非常推荐大家使用vite",charIndex:1271},{level:2,title:"现在可以试试!",slug:"现在可以试试",normalizedTitle:"现在可以试试!",charIndex:1454},{level:3,title:"克隆到本地",slug:"克隆到本地",normalizedTitle:"克隆到本地",charIndex:1493},{level:2,title:"清单",slug:"清单",normalizedTitle:"清单",charIndex:1636},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:99},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:742},{level:3,title:"构建",slug:"构建",normalizedTitle:"构建",charIndex:1887},{level:2,title:"相关仓库",slug:"相关仓库",normalizedTitle:"相关仓库",charIndex:1953}],headersStr:"特性 预配置 UI 框架 Icons 插件 编码风格 开发工具 Git 提交规范 当然，非常推荐大家使用vite 现在可以试试! 克隆到本地 清单 使用 开发 构建 相关仓库",content:"稳定地enalpro 创建 Web 应用\n\n\n\n\n\n# 特性\n\n * 🪐 Vue 3, wepack@5, pnpm,减小node_modules体积\n\n * 📦 组件自动化加载\n\n * 🍍 使用 Pinia 的状态管理\n\n * 🎨 UnoCSS - 高性能且极具灵活性的即时原子化 CSS 引擎\n\n * 😃 各种图标集为你所用\n\n * 🌍 I18n 国际化开箱即用\n\n * 🔥 使用 新的 <script setup> 语法\n\n * 📥 API 自动加载 - 直接使用 Composition API 无需引入\n\n * 🦔 可以自行引入 critters 的生成关键 CSS\n\n * 🦾 TypeScript, 当然\n\n * ☁️ 零配置部署 Netlify\n\n\n\n# 预配置\n\n\n# UI 框架\n\n * UnoCSS - 高性能且极具灵活性的即时原子化 CSS 引擎\n\n\n# Icons\n\n * Iconify - 使用任意的图标集，浏览：🔍Icônes\n * UnoCSS 的纯 CSS 图标方案\n\n\n# 插件\n\n * Vue Router\n   * vite-plugin-pages - 以文件系统为基础的路由\n   * vite-plugin-vue-layouts - 页面布局系统\n * Pinia - 直接的, 类型安全的, 使用 Composition api 的轻便灵活的 Vue 状态管理\n * Vue I18n - 国际化\n\n\n# 编码风格\n\n * 使用 Composition API 地 <script setup> SFC 语法\n * ESLint 配置为 @antfu/eslint-config, 单引号, 无分号.\n\n\n# 开发工具\n\n * TypeScript\n * Vitest - 基于 Vite 的单元测试框架\n * Cypress - E2E 测试\n * pnpm - 快, 节省磁盘空间的包管理器\n * Netlify - 零配置的部署\n * VS Code 扩展\n   * Volar - Vue 3 <script setup> IDE 支持\n   * Iconify IntelliSense - 图标内联显示和自动补全\n   * i18n Ally - 多合一的 I18n 支持\n   * ESLint\n\n\n# Git 提交规范\n\n * 参考 vue 规范 (Angular)\n   \n   * feat 增加新功能\n   * fix 修复问题/BUG\n   * style 代码风格相关无影响运行结果的\n   * perf 优化/性能提升\n   * refactor 重构\n   * revert 撤销修改\n   * test 测试相关\n   * docs 文档/注释\n   * chore 依赖更新/脚手架配置修改等\n   * workflow 工作流改进\n   * ci 持续集成\n   * types 类型定义文件更改\n   * wip 开发中\n\n\n# 当然，非常推荐大家使用vite\n\n由于这个模板的业务场景非常的局限，下面提供了一个精心策划的列表，列出了社区维护的具有不同偏好和功能集的衍生项目。也可以看看他们。当然也欢迎你 PR 提供自己的项目！\n\nvite - Awesome Vite.js\n\n> A curated list of awesome things related to Vite.js\n\n\n# 现在可以试试!\n\n> enalpro 需要 Node 版本 >=14\n\n\n# 克隆到本地\n\n如果您更喜欢使用更干净的 git 历史记录手动执行此操作\n\nnpx degit rwerplus/enalpro my-app\ncd my-app\npnpm i # 如果你没装过 pnpm, 可以先运行: npm install -g pnpm\n\n\n1\n2\n3\n\n\n\n# 清单\n\n使用此模板时，请尝试按照清单正确更新您自己的信息\n\n * 在 LICENSE 中改变作者名\n * 在 App.vue 中改变标题\n * 在 vue.config.ts 更改主机名\n * 在 public 目录下改变favicon\n * 移除 .github 文件夹中包含资助的信息\n * 整理 README 并删除路由\n\n紧接着, 享受吧 😃\n\n\n# 使用\n\n\n# 开发\n\n只需要执行以下命令就可以在 http://localhost:3333 中看到\n\npnpm dev\n\n\n1\n\n\n\n# 构建\n\n构建该应用只需要执行以下命令\n\npnpm build\n\n\n1\n\n\n然后你会看到用于发布的 dist 文件夹被生成。\n\n\n# 相关仓库",normalizedContent:"稳定地enalpro 创建 web 应用\n\n\n\n\n\n# 特性\n\n * 🪐 vue 3, wepack@5, pnpm,减小node_modules体积\n\n * 📦 组件自动化加载\n\n * 🍍 使用 pinia 的状态管理\n\n * 🎨 unocss - 高性能且极具灵活性的即时原子化 css 引擎\n\n * 😃 各种图标集为你所用\n\n * 🌍 i18n 国际化开箱即用\n\n * 🔥 使用 新的 <script setup> 语法\n\n * 📥 api 自动加载 - 直接使用 composition api 无需引入\n\n * 🦔 可以自行引入 critters 的生成关键 css\n\n * 🦾 typescript, 当然\n\n * ☁️ 零配置部署 netlify\n\n\n\n# 预配置\n\n\n# ui 框架\n\n * unocss - 高性能且极具灵活性的即时原子化 css 引擎\n\n\n# icons\n\n * iconify - 使用任意的图标集，浏览：🔍icones\n * unocss 的纯 css 图标方案\n\n\n# 插件\n\n * vue router\n   * vite-plugin-pages - 以文件系统为基础的路由\n   * vite-plugin-vue-layouts - 页面布局系统\n * pinia - 直接的, 类型安全的, 使用 composition api 的轻便灵活的 vue 状态管理\n * vue i18n - 国际化\n\n\n# 编码风格\n\n * 使用 composition api 地 <script setup> sfc 语法\n * eslint 配置为 @antfu/eslint-config, 单引号, 无分号.\n\n\n# 开发工具\n\n * typescript\n * vitest - 基于 vite 的单元测试框架\n * cypress - e2e 测试\n * pnpm - 快, 节省磁盘空间的包管理器\n * netlify - 零配置的部署\n * vs code 扩展\n   * volar - vue 3 <script setup> ide 支持\n   * iconify intellisense - 图标内联显示和自动补全\n   * i18n ally - 多合一的 i18n 支持\n   * eslint\n\n\n# git 提交规范\n\n * 参考 vue 规范 (angular)\n   \n   * feat 增加新功能\n   * fix 修复问题/bug\n   * style 代码风格相关无影响运行结果的\n   * perf 优化/性能提升\n   * refactor 重构\n   * revert 撤销修改\n   * test 测试相关\n   * docs 文档/注释\n   * chore 依赖更新/脚手架配置修改等\n   * workflow 工作流改进\n   * ci 持续集成\n   * types 类型定义文件更改\n   * wip 开发中\n\n\n# 当然，非常推荐大家使用vite\n\n由于这个模板的业务场景非常的局限，下面提供了一个精心策划的列表，列出了社区维护的具有不同偏好和功能集的衍生项目。也可以看看他们。当然也欢迎你 pr 提供自己的项目！\n\nvite - awesome vite.js\n\n> a curated list of awesome things related to vite.js\n\n\n# 现在可以试试!\n\n> enalpro 需要 node 版本 >=14\n\n\n# 克隆到本地\n\n如果您更喜欢使用更干净的 git 历史记录手动执行此操作\n\nnpx degit rwerplus/enalpro my-app\ncd my-app\npnpm i # 如果你没装过 pnpm, 可以先运行: npm install -g pnpm\n\n\n1\n2\n3\n\n\n\n# 清单\n\n使用此模板时，请尝试按照清单正确更新您自己的信息\n\n * 在 license 中改变作者名\n * 在 app.vue 中改变标题\n * 在 vue.config.ts 更改主机名\n * 在 public 目录下改变favicon\n * 移除 .github 文件夹中包含资助的信息\n * 整理 readme 并删除路由\n\n紧接着, 享受吧 😃\n\n\n# 使用\n\n\n# 开发\n\n只需要执行以下命令就可以在 http://localhost:3333 中看到\n\npnpm dev\n\n\n1\n\n\n\n# 构建\n\n构建该应用只需要执行以下命令\n\npnpm build\n\n\n1\n\n\n然后你会看到用于发布的 dist 文件夹被生成。\n\n\n# 相关仓库",charsets:{cjk:!0},lastUpdated:"2022/03/30, 09:21:17",lastUpdatedTimestamp:1648632077e3},{title:"Git使用手册",frontmatter:{title:"Git使用手册",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/9a7ee40fc232253e",categories:["技术","技术文档"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/01.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"03.技术/01.技术文档/01.Git使用手册.md",key:"v-444825c3",path:"/pages/9a7ee40fc232253e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:296},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:478},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:819},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1714},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2958},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3358},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:7029}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 版本管理 远程仓库 分支管理 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:花椒和邻居/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:花椒和邻居/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"Markdown使用教程",frontmatter:{title:"Markdown使用教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ad247c4332211551",categories:["技术","技术文档"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/02.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/02.Markdown使用教程.md",key:"v-9aeca196",path:"/pages/ad247c4332211551/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:578},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1196},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1214},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1226},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1284},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1296},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1306},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1316},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1327},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1338},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1350},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1361},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1369},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1381},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1393},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1405},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1417},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1431},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1441},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1495},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1507},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1517},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1529},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4938},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1562},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1572},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1584},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1596},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1619},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1630},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1647},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1662},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1681},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1691},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1703},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1713},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1724},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1735}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/%E8%8A%B1%E6%A4%92%E5%92%8C%E9%82%BB%E5%B1%85/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 三、设置目录 四、标题 二级标题 三级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-花椒和邻居-brightgreen.svg)](https://github.com/rwerplus)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n~~BAIDU.COM~~\n\n\n1\n2\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/rwerplus/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n1\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-花椒和邻居-brightgreen.svg)](https://github.com/rwerplus)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n~~baidu.com~~\n\n\n1\n2\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/rwerplus/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/花椒和邻居/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n1\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"npm常用命令",frontmatter:{title:"npm常用命令",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/61f2f95fd7da14fd",categories:["技术","技术文档"],tags:[null],author:{name:"rwerplus",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"03.技术/01.技术文档/03.npm常用命令.md",key:"v-2ce6653a",path:"/pages/61f2f95fd7da14fd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:14},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5},{level:2,title:"使用技巧",slug:"使用技巧",normalizedTitle:"使用技巧",charIndex:1761},{level:2,title:"npm发布包教程",slug:"npm发布包教程",normalizedTitle:"npm发布包教程",charIndex:1912},{level:2,title:"nrm的作用与使用",slug:"nrm的作用与使用",normalizedTitle:"nrm的作用与使用",charIndex:1935}],excerpt:'<h1 id="npm常用命令"><a class="header-anchor" href="#npm常用命令">#</a> npm常用命令</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\n<ul>\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\n</ul>\n',headersStr:"简介 常用命令 使用技巧 npm发布包教程 nrm的作用与使用",content:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <ModuleName>\n\n# 全局安装\nnpm i <ModuleName> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <ModuleName> --save\n\n# 安装包的同时，将信息写入到package.json中的 devDependencies 配置中\nnpm i <ModuleName> --save-dev\n\n# 安装多模块\nnpm i <ModuleName1> <ModuleName2>\n\n# 安装方式参数：\n-save # 简写-S，加入到生产依赖中\n-save-dev # 简写-D，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <ModuleName>\n\n# 查看包的依赖关系\nnpm view <ModuleName> dependencies\n\n# 查看包的源文件地址\nnpm view <ModuleName> repository.url\n\n# 查看包所依赖的node版本\nnpm view <ModuleName> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <ModuleName>\n\n# 更新全局模块\nnpm update -g <ModuleName> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <ModuleName>\n\n# 卸载全局模块\nnpm uninstall -g <ModuleName> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <ModuleName>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <ModuleName>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <ModuleName>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',normalizedContent:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <modulename>\n\n# 全局安装\nnpm i <modulename> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <modulename> --save\n\n# 安装包的同时，将信息写入到package.json中的 devdependencies 配置中\nnpm i <modulename> --save-dev\n\n# 安装多模块\nnpm i <modulename1> <modulename2>\n\n# 安装方式参数：\n-save # 简写-s，加入到生产依赖中\n-save-dev # 简写-d，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <modulename>\n\n# 查看包的依赖关系\nnpm view <modulename> dependencies\n\n# 查看包的源文件地址\nnpm view <modulename> repository.url\n\n# 查看包所依赖的node版本\nnpm view <modulename> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <modulename>\n\n# 更新全局模块\nnpm update -g <modulename> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <modulename>\n\n# 卸载全局模块\nnpm uninstall -g <modulename> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <modulename>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <modulename>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <modulename>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"面试问题集锦",frontmatter:{title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/aea6571b7a8bae86",categories:["更多","面试"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/00.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html",relativePath:"03.技术/00.面试/01.面试问题集锦.md",key:"v-ad5f0baa",path:"/pages/aea6571b7a8bae86/",headers:[{level:2,title:"请做一下自我介绍",slug:"请做一下自我介绍",normalizedTitle:"请做一下自我介绍",charIndex:13},{level:2,title:"你最大的优点是什么？",slug:"你最大的优点是什么",normalizedTitle:"你最大的优点是什么？",charIndex:166},{level:2,title:"说说你最大的缺点？",slug:"说说你最大的缺点",normalizedTitle:"说说你最大的缺点？",charIndex:252},{level:2,title:"说说你对加班的看法？",slug:"说说你对加班的看法",normalizedTitle:"说说你对加班的看法？",charIndex:378},{level:2,title:"说说你对薪资的要求？",slug:"说说你对薪资的要求",normalizedTitle:"说说你对薪资的要求？",charIndex:513},{level:2,title:"在五年内，你的职业规划？",slug:"在五年内-你的职业规划",normalizedTitle:"在五年内，你的职业规划？",charIndex:903},{level:2,title:"你朋友对你的评价?",slug:"你朋友对你的评价",normalizedTitle:"你朋友对你的评价?",charIndex:1081},{level:2,title:"你还有什么问题要问吗?",slug:"你还有什么问题要问吗",normalizedTitle:"你还有什么问题要问吗?",charIndex:1241},{level:2,title:"录用后发现不适合这个职位，怎么办?",slug:"录用后发现不适合这个职位-怎么办",normalizedTitle:"录用后发现不适合这个职位，怎么办?",charIndex:1424},{level:2,title:"工作时跟领导意见不同怎么办?",slug:"工作时跟领导意见不同怎么办",normalizedTitle:"工作时跟领导意见不同怎么办?",charIndex:1601},{level:2,title:"工作出现失误并造成损失，你会怎么做?",slug:"工作出现失误并造成损失-你会怎么做",normalizedTitle:"工作出现失误并造成损失，你会怎么做?",charIndex:1779},{level:2,title:"谈谈你对跳槽的看法?",slug:"谈谈你对跳槽的看法",normalizedTitle:"谈谈你对跳槽的看法?",charIndex:2028},{level:2,title:"和同事、上司难以相处，你怎么办?",slug:"和同事、上司难以相处-你怎么办",normalizedTitle:"和同事、上司难以相处，你怎么办?",charIndex:2098},{level:2,title:"上级领导抢了你的功劳怎么办?",slug:"上级领导抢了你的功劳怎么办",normalizedTitle:"上级领导抢了你的功劳怎么办?",charIndex:2311},{level:2,title:"同事孤立你，你怎么办?",slug:"同事孤立你-你怎么办",normalizedTitle:"同事孤立你，你怎么办?",charIndex:2485},{level:2,title:"你最近是否参加了培训课程?",slug:"你最近是否参加了培训课程",normalizedTitle:"你最近是否参加了培训课程?",charIndex:2582},{level:2,title:"你对于我们公司了解多少?",slug:"你对于我们公司了解多少",normalizedTitle:"你对于我们公司了解多少?",charIndex:2636},{level:2,title:"你最擅长的技术方向是什么?",slug:"你最擅长的技术方向是什么",normalizedTitle:"你最擅长的技术方向是什么?",charIndex:2727},{level:2,title:"请说出你选择这份工作的动机?",slug:"请说出你选择这份工作的动机",normalizedTitle:"请说出你选择这份工作的动机?",charIndex:2784},{level:2,title:"你能为我们公司带来什么呢?",slug:"你能为我们公司带来什么呢",normalizedTitle:"你能为我们公司带来什么呢?",charIndex:2912},{level:2,title:"最能概括你自己的三个词?",slug:"最能概括你自己的三个词",normalizedTitle:"最能概括你自己的三个词?",charIndex:3159},{level:2,title:"作为被面试者给我打一下分?",slug:"作为被面试者给我打一下分",normalizedTitle:"作为被面试者给我打一下分?",charIndex:3225},{level:2,title:"你怎么理解你应聘的职位?",slug:"你怎么理解你应聘的职位",normalizedTitle:"你怎么理解你应聘的职位?",charIndex:3302},{level:2,title:"喜欢这份工作的哪一点?",slug:"喜欢这份工作的哪一点",normalizedTitle:"喜欢这份工作的哪一点?",charIndex:3346},{level:2,title:"为什么要离职?",slug:"为什么要离职",normalizedTitle:"为什么要离职?",charIndex:3497},{level:2,title:"说说你对行业、技术发展趋势的看法?",slug:"说说你对行业、技术发展趋势的看法",normalizedTitle:"说说你对行业、技术发展趋势的看法?",charIndex:3739},{level:2,title:"对工作的期望与目标何在?",slug:"对工作的期望与目标何在",normalizedTitle:"对工作的期望与目标何在?",charIndex:3923},{level:2,title:"谈谈你的家庭?",slug:"谈谈你的家庭",normalizedTitle:"谈谈你的家庭?",charIndex:4183},{level:2,title:"你认为自己申请这个职位还欠缺什么?",slug:"你认为自己申请这个职位还欠缺什么",normalizedTitle:"你认为自己申请这个职位还欠缺什么?",charIndex:4413},{level:2,title:"你欣赏哪种性格的人?",slug:"你欣赏哪种性格的人",normalizedTitle:"你欣赏哪种性格的人?",charIndex:4580},{level:2,title:"你通常如何处理别人的批评?",slug:"你通常如何处理别人的批评",normalizedTitle:"你通常如何处理别人的批评?",charIndex:4633},{level:2,title:"怎样对待自己的失败?",slug:"怎样对待自己的失败",normalizedTitle:"怎样对待自己的失败?",charIndex:4705},{level:2,title:"什么会让你有成就感?",slug:"什么会让你有成就感",normalizedTitle:"什么会让你有成就感?",charIndex:4761},{level:2,title:"眼下你生活中最重要的是什么?",slug:"眼下你生活中最重要的是什么",normalizedTitle:"眼下你生活中最重要的是什么?",charIndex:4805},{level:2,title:"你为什么愿意到我们公司来工作?",slug:"你为什么愿意到我们公司来工作",normalizedTitle:"你为什么愿意到我们公司来工作?",charIndex:4867},{level:2,title:"你和别人发生过争执吗?",slug:"你和别人发生过争执吗",normalizedTitle:"你和别人发生过争执吗?",charIndex:5043},{level:2,title:"你做过的哪件事最令自己感到骄傲?",slug:"你做过的哪件事最令自己感到骄傲",normalizedTitle:"你做过的哪件事最令自己感到骄傲?",charIndex:5234},{level:2,title:"对这项工作，你有哪些可预见的困难?",slug:"对这项工作-你有哪些可预见的困难",normalizedTitle:"对这项工作，你有哪些可预见的困难?",charIndex:5366},{level:2,title:"录用后你将怎样开展工作?",slug:"录用后你将怎样开展工作",normalizedTitle:"录用后你将怎样开展工作?",charIndex:5512},{level:2,title:"你希望与什么样的上级共事?",slug:"你希望与什么样的上级共事",normalizedTitle:"你希望与什么样的上级共事?",charIndex:5657},{level:2,title:"你工作经验欠缺，如何能胜任这项工作?",slug:"你工作经验欠缺-如何能胜任这项工作",normalizedTitle:"你工作经验欠缺，如何能胜任这项工作?",charIndex:5813},{level:2,title:"你会怎样获得同事的帮助?",slug:"你会怎样获得同事的帮助",normalizedTitle:"你会怎样获得同事的帮助?",charIndex:6093},{level:2,title:"如果你没被录用，你怎么打算?",slug:"如果你没被录用-你怎么打算",normalizedTitle:"如果你没被录用，你怎么打算?",charIndex:6229},{level:2,title:"最令你沮丧的事情?",slug:"最令你沮丧的事情",normalizedTitle:"最令你沮丧的事情?",charIndex:6671},{level:2,title:"想过创业吗?",slug:"想过创业吗",normalizedTitle:"想过创业吗?",charIndex:6868},{level:2,title:"为什么我们要在众多的面试者中选择你?",slug:"为什么我们要在众多的面试者中选择你",normalizedTitle:"为什么我们要在众多的面试者中选择你?",charIndex:6941},{level:2,title:"除了本公司外，还应聘了哪些公司?",slug:"除了本公司外-还应聘了哪些公司",normalizedTitle:"除了本公司外，还应聘了哪些公司?",charIndex:7126},{level:2,title:"你并非毕业于名牌院校?",slug:"你并非毕业于名牌院校",normalizedTitle:"你并非毕业于名牌院校?",charIndex:7255},{level:2,title:"怎样看待学历和能力?",slug:"怎样看待学历和能力",normalizedTitle:"怎样看待学历和能力?",charIndex:7379},{level:2,title:"谈谈如何适应办公室工作的新环境?",slug:"谈谈如何适应办公室工作的新环境",normalizedTitle:"谈谈如何适应办公室工作的新环境?",charIndex:7605},{level:2,title:"谈谈对这个职务的期许?",slug:"谈谈对这个职务的期许",normalizedTitle:"谈谈对这个职务的期许?",charIndex:7742},{level:2,title:"何时可以到职?",slug:"何时可以到职",normalizedTitle:"何时可以到职?",charIndex:7882}],headersStr:"请做一下自我介绍 你最大的优点是什么？ 说说你最大的缺点？ 说说你对加班的看法？ 说说你对薪资的要求？ 在五年内，你的职业规划？ 你朋友对你的评价? 你还有什么问题要问吗? 录用后发现不适合这个职位，怎么办? 工作时跟领导意见不同怎么办? 工作出现失误并造成损失，你会怎么做? 谈谈你对跳槽的看法? 和同事、上司难以相处，你怎么办? 上级领导抢了你的功劳怎么办? 同事孤立你，你怎么办? 你最近是否参加了培训课程? 你对于我们公司了解多少? 你最擅长的技术方向是什么? 请说出你选择这份工作的动机? 你能为我们公司带来什么呢? 最能概括你自己的三个词? 作为被面试者给我打一下分? 你怎么理解你应聘的职位? 喜欢这份工作的哪一点? 为什么要离职? 说说你对行业、技术发展趋势的看法? 对工作的期望与目标何在? 谈谈你的家庭? 你认为自己申请这个职位还欠缺什么? 你欣赏哪种性格的人? 你通常如何处理别人的批评? 怎样对待自己的失败? 什么会让你有成就感? 眼下你生活中最重要的是什么? 你为什么愿意到我们公司来工作? 你和别人发生过争执吗? 你做过的哪件事最令自己感到骄傲? 对这项工作，你有哪些可预见的困难? 录用后你将怎样开展工作? 你希望与什么样的上级共事? 你工作经验欠缺，如何能胜任这项工作? 你会怎样获得同事的帮助? 如果你没被录用，你怎么打算? 最令你沮丧的事情? 想过创业吗? 为什么我们要在众多的面试者中选择你? 除了本公司外，还应聘了哪些公司? 你并非毕业于名牌院校? 怎样看待学历和能力? 谈谈如何适应办公室工作的新环境? 谈谈对这个职务的期许? 何时可以到职?",content:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",normalizedContent:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在xx经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是xx的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的oem合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过xx近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、eq上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了xx的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"记一次nvm安装失败的过程",frontmatter:{title:"记一次nvm安装失败的过程",date:"2022-03-03T11:41:15.000Z",permalink:"/pages/x123482",categories:["技术","技术文档"],tags:["nvm"],author:{name:"rwerplus",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/08.%E8%AE%B0%E4%B8%80%E6%AC%A1nvm%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%BF%87%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/08.记一次nvm安装失败的过程.md",key:"v-3f052c28",path:"/pages/x123482/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:79},{level:2,title:"nvm常用命令",slug:"nvm常用命令",normalizedTitle:"nvm常用命令",charIndex:628},{level:2,title:"遇到的问题解决",slug:"遇到的问题解决",normalizedTitle:"遇到的问题解决",charIndex:1134}],headersStr:"安装 nvm常用命令 遇到的问题解决",content:"# nvm介绍\n\n> Manage multiple installations of node.js on a Windows computer.\n\n\n# 安装\n\n可以在nvm官网中直接下载nvm-setup.zip,下载解压后直接执行nvm-setup.exe\n\n注意\n\n安装完成后可以打开安装所在目录，进入setting.txt中,添加如下可以提高下载速度,并可以解决nvm install 后出现的拒绝访问的错误\n\narch: 64\nproxy: none \nnode_mirror: http://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n3\n4\n\n\n> *** 使用nvm-windows 高版本时 需要单独另外安装npm，nvm只是用来管理node版本的，没有管理npm功能 ***\n\n提示\n\n注意安装路径中不能出现中文或者空格，且需要保证电脑中没有已安装的nodejs，\n\n官方原文： Please note, you need to uninstall any existing versions of node.js before installing NVM for Windows. Also delete any existing nodejs installation directories.\n\n\n# nvm常用命令\n\nnvm off                     // 禁用node.js版本管理(不卸载任何东西)\nnvm on                      // 启用node.js版本管理\nnvm install <version>       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0\nnvm uninstall <version>     // 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用\nnvm ls                      // 显示所有安装的node.js版本\nnvm list available          // 显示可以安装的所有node.js的版本\nnvm use <version>           // 切换到使用指定的nodejs版本\nnvm v                       // 显示nvm版本\nnvm install stable          // 安装最新稳定版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 遇到的问题解决\n\n1、windows 上安装 nvm 后选择 node 版本出现 exit status 1...\n\n把 nvm 安装到了有空格的路径上（D:\\Program Files），导致切换失败\n\n2、nvm 在 CMD 中不生效\n\n当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启 cmd 控制台后会生效。\n\n3. nvm在cmd中nvm use无法使用\n\n以管理员身份运行” CMD 后就可以生效\n\n4.npm Download failed\n\n使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）\n\n- name: 1、windows 上安装 nvm 后选择 node 版本出现 exit status 1...\n  desc: 把 nvm 安装到了有空格的路径上（D:\\Program Files），导致切换失败\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: 2、nvm 在 CMD 中不生效\n  desc: 当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启 cmd 控制台后会生效。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: 3. nvm在cmd中nvm use无法使用\n  desc: 以管理员身份运行” CMD 后就可以生效\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: 4.npm Download failed\n  desc: 使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）\n  bgColor: 'rgba(59, 130, 246, .5)'\n  textColor: '#000'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# nvm介绍\n\n> manage multiple installations of node.js on a windows computer.\n\n\n# 安装\n\n可以在nvm官网中直接下载nvm-setup.zip,下载解压后直接执行nvm-setup.exe\n\n注意\n\n安装完成后可以打开安装所在目录，进入setting.txt中,添加如下可以提高下载速度,并可以解决nvm install 后出现的拒绝访问的错误\n\narch: 64\nproxy: none \nnode_mirror: http://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n3\n4\n\n\n> *** 使用nvm-windows 高版本时 需要单独另外安装npm，nvm只是用来管理node版本的，没有管理npm功能 ***\n\n提示\n\n注意安装路径中不能出现中文或者空格，且需要保证电脑中没有已安装的nodejs，\n\n官方原文： please note, you need to uninstall any existing versions of node.js before installing nvm for windows. also delete any existing nodejs installation directories.\n\n\n# nvm常用命令\n\nnvm off                     // 禁用node.js版本管理(不卸载任何东西)\nnvm on                      // 启用node.js版本管理\nnvm install <version>       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0\nnvm uninstall <version>     // 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用\nnvm ls                      // 显示所有安装的node.js版本\nnvm list available          // 显示可以安装的所有node.js的版本\nnvm use <version>           // 切换到使用指定的nodejs版本\nnvm v                       // 显示nvm版本\nnvm install stable          // 安装最新稳定版\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 遇到的问题解决\n\n1、windows 上安装 nvm 后选择 node 版本出现 exit status 1...\n\n把 nvm 安装到了有空格的路径上（d:\\program files），导致切换失败\n\n2、nvm 在 cmd 中不生效\n\n当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启 cmd 控制台后会生效。\n\n3. nvm在cmd中nvm use无法使用\n\n以管理员身份运行” cmd 后就可以生效\n\n4.npm download failed\n\n使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）\n\n- name: 1、windows 上安装 nvm 后选择 node 版本出现 exit status 1...\n  desc: 把 nvm 安装到了有空格的路径上（d:\\program files），导致切换失败\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: 2、nvm 在 cmd 中不生效\n  desc: 当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启 cmd 控制台后会生效。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: 3. nvm在cmd中nvm use无法使用\n  desc: 以管理员身份运行” cmd 后就可以生效\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: 4.npm download failed\n  desc: 使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）\n  bgcolor: 'rgba(59, 130, 246, .5)'\n  textcolor: '#000'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"npm packageJson属性详解",frontmatter:{author:{name:"花椒和邻居",link:"https://github.com/rwerplus"},title:"npm packageJson属性详解",date:"2020-04-08T17:16:38.000Z",permalink:"/pages/dec4f3f00e71a312",categories:["技术","技术文档"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/10.npm%20packageJson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3.html",relativePath:"03.技术/01.技术文档/10.npm packageJson属性详解.md",key:"v-59f3b0d2",path:"/pages/dec4f3f00e71a312/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:86},{level:2,title:"name",slug:"name",normalizedTitle:"name",charIndex:160},{level:2,title:"version",slug:"version",normalizedTitle:"version",charIndex:191},{level:2,title:"description",slug:"description",normalizedTitle:"description",charIndex:1036},{level:2,title:"keywords",slug:"keywords",normalizedTitle:"keywords",charIndex:1081},{level:2,title:"homepage",slug:"homepage",normalizedTitle:"homepage",charIndex:1114},{level:2,title:"bugs",slug:"bugs",normalizedTitle:"bugs",charIndex:1266},{level:2,title:"license",slug:"license",normalizedTitle:"license",charIndex:1496},{level:2,title:"和用户相关的属性: author, contributors",slug:"和用户相关的属性-author-contributors",normalizedTitle:"和用户相关的属性: author, contributors",charIndex:1666},{level:2,title:"files",slug:"files",normalizedTitle:"files",charIndex:2037},{level:2,title:"main",slug:"main",normalizedTitle:"main",charIndex:2013},{level:2,title:"bin",slug:"bin",normalizedTitle:"bin",charIndex:2444},{level:2,title:"man",slug:"man",normalizedTitle:"man",charIndex:3180},{level:2,title:"directories",slug:"directories",normalizedTitle:"directories",charIndex:4055},{level:3,title:"directories.lib",slug:"directories-lib",normalizedTitle:"directories.lib",charIndex:4211},{level:3,title:"directories.bin",slug:"directories-bin",normalizedTitle:"directories.bin",charIndex:4282},{level:3,title:"directories.man",slug:"directories-man",normalizedTitle:"directories.man",charIndex:4383},{level:3,title:"directories.doc",slug:"directories-doc",normalizedTitle:"directories.doc",charIndex:4440},{level:3,title:"directories.example",slug:"directories-example",normalizedTitle:"directories.example",charIndex:4514},{level:2,title:"repository",slug:"repository",normalizedTitle:"repository",charIndex:4561},{level:2,title:"scripts",slug:"scripts",normalizedTitle:"scripts",charIndex:5066},{level:2,title:"config",slug:"config",normalizedTitle:"config",charIndex:146},{level:2,title:"dependencies",slug:"dependencies",normalizedTitle:"dependencies",charIndex:1017},{level:2,title:"URLs as Dependencies",slug:"urls-as-dependencies",normalizedTitle:"urls as dependencies",charIndex:6629},{level:2,title:"Git URLs as Dependencies",slug:"git-urls-as-dependencies",normalizedTitle:"git urls as dependencies",charIndex:6706},{level:2,title:"GitHub URLs",slug:"github-urls",normalizedTitle:"github urls",charIndex:7059},{level:2,title:"Local Paths",slug:"local-paths",normalizedTitle:"local paths",charIndex:7300},{level:2,title:"devDependencies",slug:"devdependencies",normalizedTitle:"devdependencies",charIndex:7631},{level:2,title:"peerDependencies",slug:"peerdependencies",normalizedTitle:"peerdependencies",charIndex:8354},{level:2,title:"bundledDependencies",slug:"bundleddependencies",normalizedTitle:"bundleddependencies",charIndex:8793},{level:2,title:"optionalDependencies",slug:"optionaldependencies",normalizedTitle:"optionaldependencies",charIndex:8870},{level:2,title:"engines",slug:"engines",normalizedTitle:"engines",charIndex:594},{level:2,title:"engineStrict",slug:"enginestrict",normalizedTitle:"enginestrict",charIndex:9646},{level:2,title:"os",slug:"os",normalizedTitle:"os",charIndex:1394},{level:2,title:"cpu",slug:"cpu",normalizedTitle:"cpu",charIndex:9846},{level:2,title:"preferGlobal",slug:"preferglobal",normalizedTitle:"preferglobal",charIndex:9962},{level:2,title:"private",slug:"private",normalizedTitle:"private",charIndex:10079},{level:2,title:"publishConfig",slug:"publishconfig",normalizedTitle:"publishconfig",charIndex:10172},{level:2,title:"DEFAULT VALUES",slug:"default-values",normalizedTitle:"default values",charIndex:10286},{level:2,title:"参考文档列表(https://docs.npmjs.com/)",slug:"参考文档列表-https-docs-npmjs-com",normalizedTitle:"参考文档列表(https://docs.npmjs.com/)",charIndex:10599}],excerpt:'<h1 id="npm-package-json属性详解"><a class="header-anchor" href="#npm-package-json属性详解">#</a> npm package.json属性详解</h1>\n<blockquote>\n<p>本文转自<a href="https://www.cnblogs.com/tzyy/p/5193811.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/tzyy/p/5193811.html<OutboundLink/></a>，作者：TZYY</p>\n</blockquote>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\n',headersStr:"概述 name version description keywords homepage bugs license 和用户相关的属性: author, contributors files main bin man directories directories.lib directories.bin directories.man directories.doc directories.example repository scripts config dependencies URLs as Dependencies Git URLs as Dependencies GitHub URLs Local Paths devDependencies peerDependencies bundledDependencies optionalDependencies engines engineStrict os cpu preferGlobal private publishConfig DEFAULT VALUES 参考文档列表(https://docs.npmjs.com/)",content:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：TZYY\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 It\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (See below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <ModuleName>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：\n\n{ "license" : "MIT" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "Barney Rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\nCommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createServer(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo See 见下面GitHub仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# URLs as Dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# Git URLs as Dependencies\n\nGit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# GitHub URLs\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Local Paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devDependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devDependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerDependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerDependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundledDependencies\n\n上面的单词少个d，写成bundleDependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionalDependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooVersion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notGoodFooVersion(fooVersion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.doFooThings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# engineStrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferGlobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。\n\n\n# publishConfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# DEFAULT VALUES\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',normalizedContent:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：tzyy\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 it\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (see below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <modulename>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用bsd-3-clause 或 mit之类的协议，如下：\n\n{ "license" : "mit" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "barney rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"barney rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到path路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在c:\\users\\username\\appdata\\roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\ncommonjs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在github, github gist, bitbucket, or gitlab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createserver(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo see 见下面github仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# urls as dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# git urls as dependencies\n\ngit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# github urls\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# local paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devdependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devdependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把coffeescript编译成javascript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devdependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devdependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerdependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerdependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerdependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundleddependencies\n\n上面的单词少个d，写成bundledependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionaldependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionaldependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooversion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notgoodfooversion(fooversion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.dofoothings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionaldependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# enginestrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferglobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishconfig中配置仓库参数。\n\n\n# publishconfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# default values\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有authors 文件，则npm会按name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"yaml语言教程",frontmatter:{title:"yaml语言教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4e8444e2d534d14f",categories:["技术","技术文档"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/15.yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/15.yaml语言教程.md",key:"v-5257dd59",path:"/pages/4e8444e2d534d14f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:326},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:422},{level:2,title:"YAML 对象",slug:"yaml-对象",normalizedTitle:"yaml 对象",charIndex:576},{level:2,title:"YAML 数组",slug:"yaml-数组",normalizedTitle:"yaml 数组",charIndex:1086},{level:2,title:"复合结构（对象和数组组合）",slug:"复合结构-对象和数组组合",normalizedTitle:"复合结构（对象和数组组合）",charIndex:1594},{level:2,title:"纯量",slug:"纯量",normalizedTitle:"纯量",charIndex:549},{level:2,title:"转换数据格式",slug:"转换数据格式",normalizedTitle:"转换数据格式",charIndex:3050},{level:2,title:"锚点引用",slug:"锚点引用",normalizedTitle:"锚点引用",charIndex:3157}],excerpt:'<h1 id="yaml语言教程"><a class="header-anchor" href="#yaml语言教程">#</a> yaml语言教程</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>YAML 是 &quot;YAML Ain\'t a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\n',headersStr:"简介 基本语法 数据类型 YAML 对象 YAML 数组 复合结构（对象和数组组合） 纯量 转换数据格式 锚点引用",content:"# yaml语言教程\n\n\n# 简介\n\nYAML 是 \"YAML Ain't a Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\n\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nYAML 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# YAML 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# YAML 数组\n\n以 - 开头的行表示构成一个数组：\n\n- A\n- B\n- C\n\n\n1\n2\n3\n\n\nYAML 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - A\n - B\n - C\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - Ruby\n  - Perl\n  - Python \nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'Ruby', 'Perl', 'Python'],\n  websites: {\n    YAML: 'yaml.org',\n    Ruby: 'ruby-lang.org',\n    Python: 'python.org',\n    Perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * Null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - TRUE  #true,True都可以\n    - FALSE  #false，False都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # Null\n    nodeName: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd\ndatetime: \n    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  Foo\n  Bar\nthat: >\n  Foo\n  Bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  Foo\n \ns2: |+\n  Foo\n \n \ns3: |-\n  Foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' }\n\n\n1\n\n\n字符串之中可以插入 HTML 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell Steve \n- Clark \n- Brian \n- Oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",normalizedContent:"# yaml语言教程\n\n\n# 简介\n\nyaml 是 \"yaml ain't a markup language\"（yaml 不是一种标记语言）的递归缩写。在开发的这种语言时，yaml 的意思其实是：\"yet another markup language\"（仍是一种标记语言）。\n\nyaml 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和yaml非常接近）。\n\nyaml 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nyaml 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# yaml 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# yaml 数组\n\n以 - 开头的行表示构成一个数组：\n\n- a\n- b\n- c\n\n\n1\n2\n3\n\n\nyaml 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - a\n - b\n - c\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200w\n    -\n        id: 2\n        name: company2\n        price: 500w\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200w},{id: 2,name: company2,price: 500w}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - ruby\n  - perl\n  - python \nwebsites:\n  yaml: yaml.org \n  ruby: ruby-lang.org \n  python: python.org \n  perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'ruby', 'perl', 'python'],\n  websites: {\n    yaml: 'yaml.org',\n    ruby: 'ruby-lang.org',\n    python: 'python.org',\n    perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - true  #true,true都可以\n    - false  #false，false都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # null\n    nodename: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用iso 8601格式，即yyyy-mm-dd\ndatetime: \n    -  2018-02-17t15:02:31+08:00    #时间使用iso 8601格式，时间和日期之间使用t连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  foo\n  bar\nthat: >\n  foo\n  bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'foo\\nbar\\n', that: 'foo bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  foo\n \ns2: |+\n  foo\n \n \ns3: |-\n  foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'foo\\n', s2: 'foo\\n\\n\\n', s3: 'foo' }\n\n\n1\n\n\n字符串之中可以插入 html 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell steve \n- clark \n- brian \n- oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'steve', 'clark', 'brian', 'oren', 'steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"GitHub高级搜索技巧",frontmatter:{title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4c778760be26d8b3",categories:["技术","GitHub技巧"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.md",key:"v-77b0cb36",path:"/pages/4c778760be26d8b3/",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"GitHub Actions 实现自动部署静态博客",frontmatter:{title:"GitHub Actions 实现自动部署静态博客",date:"2019-12-27T11:44:41.000Z",permalink:"/pages/6b9d359ec5aa5019",categories:["技术","GitHub技巧"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/02.GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html",relativePath:"03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md",key:"v-19e65b15",path:"/pages/6b9d359ec5aa5019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:32},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:17},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3425}],excerpt:'<h1 id="github-actions-实现自动部署静态博客"><a class="header-anchor" href="#github-actions-实现自动部署静态博客">#</a> GitHub Actions 实现自动部署静态博客</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>我使用vuepress搭建了一个静态博客，挂在了Github pages和<a href="https://dev.tencent.com/" target="_blank" rel="noopener noreferrer">Coding pages<OutboundLink/></a>上面。</p>\n<p>coding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。</p>\n',headersStr:"前言 实现 相关文章",content:'# GitHub Actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到Github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解GitHub Actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。GitHub Actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的Settings/Secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是ACCESS_TOKEN和CODING_TOKEN。\n\n\n\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: CI\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: Checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # toKen私密变量\n          CODING_TOKEN: ${{ secrets.CODING_TOKEN }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> ACCESS_TOKE 和 CODING_TOKEN 都是保存在github仓库的Settings/Secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.花椒和邻居.com\' > CNAME\nif [ -z "$GITHUB_TOKEN" ]; then\n  msg=\'deploy\'\n  githubUrl=git@github.com:花椒和邻居/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githubUrl=https://花椒和邻居:${GITHUB_TOKEN}@github.com/花椒和邻居/blog.git\n  git config --global user.name "花椒和邻居"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.花椒和邻居.com\\n花椒和邻居.com\' > CNAME  # 自定义域名\nif [ -z "$CODING_TOKEN" ]; then  # -z 字符串 长度为0则为true；$CODING_TOKEN来自于github仓库`Settings/Secrets`设置的私密环境变量\n  codingUrl=git@git.dev.tencent.com:花椒和邻居/花椒和邻居.git\nelse\n  codingUrl=https://花椒和邻居:${CODING_TOKEN}@git.dev.tencent.com/花椒和邻居/花椒和邻居.git\nfi\ngit add -A\ngit commit -m "${msg}"\ngit push -f $codingUrl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用Shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的CNAME文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是GitHub Actions自动触发的部署，此时使用的是可以通过toKen来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * Shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建CNAME文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由GitHub Actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的Actions这一项查看。\n\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》',normalizedContent:'# github actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了github pages和coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解github actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。github actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的settings/secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是access_token和coding_token。\n\n\n\ngithub actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 yaml 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。github 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: ci\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          github_token: ${{ secrets.access_token }} # token私密变量\n          coding_token: ${{ secrets.coding_token }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> access_toke 和 coding_token 都是保存在github仓库的settings/secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.花椒和邻居.com\' > cname\nif [ -z "$github_token" ]; then\n  msg=\'deploy\'\n  githuburl=git@github.com:花椒和邻居/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githuburl=https://花椒和邻居:${github_token}@github.com/花椒和邻居/blog.git\n  git config --global user.name "花椒和邻居"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.花椒和邻居.com\\n花椒和邻居.com\' > cname  # 自定义域名\nif [ -z "$coding_token" ]; then  # -z 字符串 长度为0则为true；$coding_token来自于github仓库`settings/secrets`设置的私密环境变量\n  codingurl=git@git.dev.tencent.com:花椒和邻居/花椒和邻居.git\nelse\n  codingurl=https://花椒和邻居:${coding_token}@git.dev.tencent.com/花椒和邻居/花椒和邻居.git\nfi\ngit add -a\ngit commit -m "${msg}"\ngit push -f $codingurl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的cname文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是github actions自动触发的部署，此时使用的是可以通过token来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建cname文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由github actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的actions这一项查看。\n\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",frontmatter:{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",date:"2019-12-30T21:23:00.000Z",permalink:"/pages/f44d2f9ad04ab8d3",categories:["技术","GitHub技巧"],tags:["github","博客"],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/03.GitHub%20Actions%20%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81.html",relativePath:"03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md",key:"v-206fe99b",path:"/pages/f44d2f9ad04ab8d3/",headers:[{level:2,title:"百度主动链接推送",slug:"百度主动链接推送",normalizedTitle:"百度主动链接推送",charIndex:246},{level:2,title:"自动生成urls.txt",slug:"自动生成urls-txt",normalizedTitle:"自动生成urls.txt",charIndex:601},{level:2,title:"GitHub Actions 定时运行代码",slug:"github-actions-定时运行代码",normalizedTitle:"github actions 定时运行代码",charIndex:2},{level:3,title:"配置 GitHub Actions",slug:"配置-github-actions",normalizedTitle:"配置 github actions",charIndex:2065},{level:3,title:"baiduPush命令在package.json配置",slug:"baidupush命令在package-json配置",normalizedTitle:"baidupush命令在package.json配置",charIndex:2818},{level:3,title:"baiduPush.sh执行百度推送命令",slug:"baidupush-sh执行百度推送命令",normalizedTitle:"baidupush.sh执行百度推送命令",charIndex:3167},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3649}],excerpt:'<h1 id="github-actions-定时运行代码-每天定时百度链接推送"><a class="header-anchor" href="#github-actions-定时运行代码-每天定时百度链接推送">#</a> GitHub Actions 定时运行代码：每天定时百度链接推送</h1>\n<p>博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。</p>\n<p>最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。</p>\n<p>GitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>\n',headersStr:"百度主动链接推送 自动生成urls.txt GitHub Actions 定时运行代码 配置 GitHub Actions baiduPush命令在package.json配置 baiduPush.sh执行百度推送命令 相关文章",content:"# GitHub Actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=花椒和邻居.com&token=T5PEAzhG*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baiduPush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorConsole();\nconst matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readFileList = require('./modules/readFileList');\nconst urlsRoot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst DOMAIN = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!DOMAIN) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://花椒和邻居.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writeFileSync(urlsRoot, DOMAIN)\n  const files = readFileList(); // 读取所有md文件数据\n\n  files.forEach( file => {\n    const { data } = matter(fs.readFileSync(file.filePath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${DOMAIN}${data.permalink}/`;\n      console.log(link)\n      fs.appendFileSync(urlsRoot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baiduPush.js https://花椒和邻居.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# GitHub Actions 定时运行代码\n\n今天的主角GitHub Actions 要登场了。（相关：GitHub Actions 入门教程、GitHub Actions 实现自动部署静态博客）\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 GitHub Actions\n\n触发 GitHub Actions 需要在项目仓库新建一个.github/workflows子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。\n\n配置文件的第一部分是触发条件。\n\n## baiduPush.yml\nname: 'baiduPush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的Ubuntu\n    steps:\n      - name: 'Checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'Run baiduPush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baiduPush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baiduPush命令。完整代码看 这里\n\n\n# baiduPush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baiduPush\": \"node utils/baiduPush.js https://花椒和邻居.com && bash baiduPush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baiduPush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baiduPush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baiduPush命令之所以没有放在baiduPush.yml的 run 里面是因为我想在本地也可以执行npm run baiduPush命令。\n\n\n# baiduPush.sh执行百度推送命令\n\nbaiduPush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://花椒和邻居.com&token=T5PEAzhGa*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baiduPush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 GitHub Actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在GitHub上的静态博客的问题》",normalizedContent:"# github actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到github actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=花椒和邻居.com&token=t5peazhg*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baidupush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorconsole();\nconst matter = require('gray-matter'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readfilelist = require('./modules/readfilelist');\nconst urlsroot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst domain = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!domain) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baidupush.js https://花椒和邻居.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writefilesync(urlsroot, domain)\n  const files = readfilelist(); // 读取所有md文件数据\n\n  files.foreach( file => {\n    const { data } = matter(fs.readfilesync(file.filepath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${domain}${data.permalink}/`;\n      console.log(link)\n      fs.appendfilesync(urlsroot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baidupush.js https://花椒和邻居.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# github actions 定时运行代码\n\n今天的主角github actions 要登场了。（相关：github actions 入门教程、github actions 实现自动部署静态博客）\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 github actions\n\n触发 github actions 需要在项目仓库新建一个.github/workflows子目录，里面是 yaml 格式配置文件，文件名可以随便取。github 只要发现配置文件，就会运行 actions。\n\n配置文件的第一部分是触发条件。\n\n## baidupush.yml\nname: 'baidupush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的ubuntu\n    steps:\n      - name: 'checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'run baidupush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baidupush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baidupush命令。完整代码看 这里\n\n\n# baidupush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baidupush\": \"node utils/baidupush.js https://花椒和邻居.com && bash baidupush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baidupush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baidupush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baidupush命令之所以没有放在baidupush.yml的 run 里面是因为我想在本地也可以执行npm run baidupush命令。\n\n\n# baidupush.sh执行百度推送命令\n\nbaidupush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://花椒和邻居.com&token=t5peazhga*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baidupush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用github actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 github actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在github上的静态博客的问题》",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"GitHub加速下载项目的方法",frontmatter:{title:"GitHub加速下载项目的方法",date:"2020-03-09T10:28:09.000Z",permalink:"/pages/95331c6a9613faf8",categories:["技术","GitHub技巧"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/10.GitHub%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.md",key:"v-08947a02",path:"/pages/95331c6a9613faf8/",headers:[{level:2,title:"利用码云来转接做下载加速",slug:"利用码云来转接做下载加速",normalizedTitle:"利用码云来转接做下载加速",charIndex:109}],excerpt:'<h1 id="github加速下载项目的方法"><a class="header-anchor" href="#github加速下载项目的方法">#</a> GitHub加速下载项目的方法</h1>\n<p>国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。</p>\n',headersStr:"利用码云来转接做下载加速",content:'# GitHub加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从GitHub/GitLab导入项目\n    \n    \n\n 3. 选择从URL导入，粘贴从GitHub复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',normalizedContent:'# github加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从github/gitlab导入项目\n    \n    \n\n 3. 选择从url导入，粘贴从github复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"nodejs递归读取所有文件",frontmatter:{title:"nodejs递归读取所有文件",date:"2019-12-26T15:57:32.000Z",permalink:"/pages/117708e0af7f0bd9",categories:["技术","Nodejs"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html",relativePath:"03.技术/03.Nodejs/01.nodejs递归读取所有文件.md",key:"v-065caaf0",path:"/pages/117708e0af7f0bd9/",headersStr:null,content:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readFileList(dir, filesList = []) {\n    const files = fs.readdirSync(dir);\n    console.log(files);\n    files.forEach((item, index) => {\n        var fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {      \n            readFileList(path.join(dir, item), filesList);  //递归读取文件\n        } else {                \n            filesList.push(fullPath);                     \n        }        \n    });\n    return filesList;\n}\n \nvar filesList = [];\nreadFileList(__dirname,filesList);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readfilelist(dir, fileslist = []) {\n    const files = fs.readdirsync(dir);\n    console.log(files);\n    files.foreach((item, index) => {\n        var fullpath = path.join(dir, item);\n        const stat = fs.statsync(fullpath);\n        if (stat.isdirectory()) {      \n            readfilelist(path.join(dir, item), fileslist);  //递归读取文件\n        } else {                \n            fileslist.push(fullpath);                     \n        }        \n    });\n    return fileslist;\n}\n \nvar fileslist = [];\nreadfilelist(__dirname,fileslist);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",frontmatter:{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/41f87d890d0a02af",categories:["技术","博客搭建"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md",key:"v-73ef0f20",path:"/pages/41f87d890d0a02af/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:74},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:172},{level:3,title:"如何知道百度有没有收录？",slug:"如何知道百度有没有收录",normalizedTitle:"如何知道百度有没有收录？",charIndex:1211},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:1274}],excerpt:'<h1 id="解决百度无法收录搭建在github上的静态博客的问题"><a class="header-anchor" href="#解决百度无法收录搭建在github上的静态博客的问题">#</a> 解决百度无法收录搭建在GitHub上的静态博客的问题</h1>\n<div class="custom-block warning"><p class="custom-block-title">注意</p>\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href="https://github.com/rwerplus/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer">README<OutboundLink/></a>。</p>\n</div>\n<h2 id="背景"><a class="header-anchor" href="#背景">#</a> 背景</h2>\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\n',headersStr:"背景 解决方案 如何知道百度有没有收录？ 相关文章",content:"# 解决百度无法收录搭建在GitHub上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n\n# 背景\n\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：Git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.花椒和邻居.com' > CNAME\ngit init\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@github.com:花椒和邻居/blog.git master:gh-pages # 发布到github\n\n# coding\necho '花椒和邻居.com' > CNAME\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:花椒和邻居/花椒和邻居.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了CNAME文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名DNS解析中添加CNAME记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建CNAME文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:花椒和邻居.com\n\n\n1\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》",normalizedContent:"# 解决百度无法收录搭建在github上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的readme。\n\n\n# 背景\n\n由于github禁止百度爬虫访问，造成托管在github pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到github pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.花椒和邻居.com' > cname\ngit init\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@github.com:花椒和邻居/blog.git master:gh-pages # 发布到github\n\n# coding\necho '花椒和邻居.com' > cname\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:花椒和邻居/花椒和邻居.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了cname文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名dns解析中添加cname记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建cname文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:花椒和邻居.com\n\n\n1\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"使用Gitalk实现静态博客无后台评论系统",frontmatter:{title:"使用Gitalk实现静态博客无后台评论系统",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/1da0bf9a988eafe5",categories:["技术","博客搭建"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.%E4%BD%BF%E7%94%A8Gitalk%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%90%8E%E5%8F%B0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html",relativePath:"03.技术/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md",key:"v-7f658b18",path:"/pages/1da0bf9a988eafe5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:28},{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:109},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:10},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:338},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:2},{level:3,title:"BUG修复",slug:"bug修复",normalizedTitle:"bug修复",charIndex:1599}],excerpt:'<h1 id="使用gitalk实现静态博客无后台评论系统"><a class="header-anchor" href="#使用gitalk实现静态博客无后台评论系统">#</a> 使用Gitalk实现静态博客无后台评论系统</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\n',headersStr:"前言 准备 实现 安装 使用 BUG修复",content:"# 使用Gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\nGitalk demo：https://gitalk.github.io/\n\nGitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和Gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'GitHub Application Client ID',\n          clientSecret: 'GitHub Application Client Secret',\n          repo: 'GitHub repo',\n          owner: 'GitHub repo owner',\n          admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 Client ID 和 Client Secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'a6e*******4709b88b',\n          clientSecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // GitHub 仓库\n          owner: '花椒和邻居', // GitHub仓库所有者\n          admin: ['花椒和邻居'], // 对仓库有写权限的人\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# BUG修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentWidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $MQNarrow)\n    padding 2rem\n  @media (max-width: $MQMobileNarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 Error: Validation Failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 EJS 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 EJS 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 使用gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\ngitalk，一个基于 github issue 和 preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\ngitalk demo：https://gitalk.github.io/\n\ngitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'github application client id',\n          clientsecret: 'github application client secret',\n          repo: 'github repo',\n          owner: 'github repo owner',\n          admin: ['github repo owner and collaborators, only these guys can initialize github issues'],\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 github application，如果没有 点击这里申请，authorization callback url 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 client id 和 client secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'a6e*******4709b88b',\n          clientsecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // github 仓库\n          owner: '花椒和邻居', // github仓库所有者\n          admin: ['花椒和邻居'], // 对仓库有写权限的人\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# bug修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentwidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $mqnarrow)\n    padding 2rem\n  @media (max-width: $mqmobilenarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 error: validation failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 ejs 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 ejs 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",frontmatter:{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",date:"2020-01-03T12:55:43.000Z",permalink:"/pages/a5f73af5185fdf0a",categories:["技术","博客搭建"],tags:[null],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/03.GitHub%20+%20jsDelivr%20+%20TinyPNG+%20PicGo%20%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E3%80%81%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A.html",relativePath:"03.技术/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md",key:"v-5cdd7466",path:"/pages/a5f73af5185fdf0a/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:55},{level:2,title:"图床打造",slug:"图床打造",normalizedTitle:"图床打造",charIndex:590}],excerpt:'<h1 id="github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床"><a class="header-anchor" href="#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床">#</a> GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\n',headersStr:"前言 图床打造",content:"# GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nQ：为什么要使用图床呢？什么是图床？\n\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nQ：图床的选择\n\nA：推荐使用GitHub作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsDelivr免费CDN加速。\n\nQ：jsDelivr是什么？\n\nA：jsDelivr是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建GitHub仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载PicGo，安装完成后打开，图床设置 选 GitHub图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * Token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，PicGo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsDelivr的CDN加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在PigGo的上传区上传你的图片，到相册一键复制刚刚上传的图片URL，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",normalizedContent:"# github + jsdelivr + tinypng+ picgo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nq：为什么要使用图床呢？什么是图床？\n\na：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的url，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nq：图床的选择\n\na：推荐使用github作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsdelivr免费cdn加速。\n\nq：jsdelivr是什么？\n\na：jsdelivr是国外的一家优秀的公共 cdn 服务提供商，该平台是首个「打通中国大陆与海外的免费cdn服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建github仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载picgo，安装完成后打开，图床设置 选 github图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，picgo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsdelivr的cdn加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在piggo的上传区上传你的图片，到相册一键复制刚刚上传的图片url，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"vdoing主题效果图",frontmatter:{title:"vdoing主题效果图",date:"2020-04-08T11:27:22.000Z",permalink:"/pages/d557b9a89a215d2e",article:!1,author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.vdoing%E4%B8%BB%E9%A2%98%E6%95%88%E6%9E%9C%E5%9B%BE.html",relativePath:"03.技术/04.博客搭建/10.vdoing主题效果图.md",key:"v-eb84e6ce",path:"/pages/d557b9a89a215d2e/",headers:[{level:2,title:"PC端",slug:"pc端",normalizedTitle:"pc端",charIndex:18},{level:2,title:"首页个性化大图",slug:"首页个性化大图",normalizedTitle:"首页个性化大图",charIndex:53},{level:2,title:"深色模式和阅读模式",slug:"深色模式和阅读模式",normalizedTitle:"深色模式和阅读模式",charIndex:76},{level:2,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:105}],headersStr:"PC端 首页个性化大图 深色模式和阅读模式 移动端",content:"# vdoing主题效果图\n\n\n# PC端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",normalizedContent:"# vdoing主题效果图\n\n\n# pc端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"java",frontmatter:{title:"java",date:"2022-04-11T13:24:25.000Z",permalink:"/pages/e58ecf/",categories:["技术","java"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.java/052.java.html",relativePath:"03.技术/05.java/052.java.md",key:"v-3320b556",path:"/pages/e58ecf/",headers:[{level:2,title:"java程序基础",slug:"java程序基础",normalizedTitle:"java程序基础",charIndex:15},{level:3,title:"JVM、JDK和JRE",slug:"jvm、jdk和jre",normalizedTitle:"jvm、jdk和jre",charIndex:28},{level:3,title:"基本数据类型",slug:"基本数据类型",normalizedTitle:"基本数据类型",charIndex:761},{level:3,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:1582},{level:3,title:"var关键字",slug:"var关键字",normalizedTitle:"var关键字",charIndex:1713},{level:3,title:"位运算",slug:"位运算",normalizedTitle:"位运算",charIndex:1953},{level:3,title:"运算优先级",slug:"运算优先级",normalizedTitle:"运算优先级",charIndex:2079},{level:3,title:"浮点数运算",slug:"浮点数运算",normalizedTitle:"浮点数运算",charIndex:2191},{level:2,title:"数组操作",slug:"数组操作",normalizedTitle:"数组操作",charIndex:2621},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2621},{level:2,title:"面向对象基础",slug:"面向对象基础",normalizedTitle:"面向对象基础",charIndex:2706},{level:3,title:"可变参数",slug:"可变参数",normalizedTitle:"可变参数",charIndex:2717},{level:3,title:"方法重载",slug:"方法重载",normalizedTitle:"方法重载",charIndex:3114},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:3180},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:4708},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:1598},{level:3,title:"transient",slug:"transient",normalizedTitle:"transient",charIndex:5444},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:5985},{level:3,title:"面向抽象编程",slug:"面向抽象编程",normalizedTitle:"面向抽象编程",charIndex:6451},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:5480},{level:3,title:"静态字段和静态方法",slug:"静态字段和静态方法",normalizedTitle:"静态字段和静态方法",charIndex:10075},{level:3,title:"包",slug:"包",normalizedTitle:"包",charIndex:361},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:11241},{level:3,title:"classpath和jar",slug:"classpath和jar",normalizedTitle:"classpath和jar",charIndex:13480},{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:13906},{level:2,title:"Java核心类",slug:"java核心类",normalizedTitle:"java核心类",charIndex:14703},{level:3,title:"字符串和编码",slug:"字符串和编码",normalizedTitle:"字符串和编码",charIndex:14715},{level:3,title:"StringBuilder",slug:"stringbuilder",normalizedTitle:"stringbuilder",charIndex:1757},{level:3,title:"包装类型",slug:"包装类型",normalizedTitle:"包装类型",charIndex:19088},{level:3,title:"JavaBean",slug:"javabean",normalizedTitle:"javabean",charIndex:21403},{level:3,title:"枚举类",slug:"枚举类",normalizedTitle:"枚举类",charIndex:22540},{level:3,title:"BigInteger",slug:"biginteger",normalizedTitle:"biginteger",charIndex:23205},{level:3,title:"BigDecimal",slug:"bigdecimal",normalizedTitle:"bigdecimal",charIndex:23800},{level:3,title:"Object类",slug:"object类",normalizedTitle:"object类",charIndex:25272},{level:3,title:"int和Integer的区别",slug:"int和integer的区别",normalizedTitle:"int和integer的区别",charIndex:25825},{level:3,title:"Java String、StringBuffer 和 StringBuilder 的区别",slug:"java-string、stringbuffer-和-stringbuilder-的区别",normalizedTitle:"java string、stringbuffer 和 stringbuilder 的区别",charIndex:27589},{level:3,title:"常用工具类",slug:"常用工具类",normalizedTitle:"常用工具类",charIndex:31440},{level:2,title:"Java的异常",slug:"java的异常",normalizedTitle:"java的异常",charIndex:33092},{level:2,title:"捕获异常",slug:"捕获异常",normalizedTitle:"捕获异常",charIndex:35042},{level:2,title:"抛出异常",slug:"抛出异常",normalizedTitle:"抛出异常",charIndex:35059},{level:2,title:"断言",slug:"断言",normalizedTitle:"断言",charIndex:35981},{level:2,title:"Class类",slug:"class类",normalizedTitle:"class类",charIndex:36354},{level:3,title:"动态加载",slug:"动态加载",normalizedTitle:"动态加载",charIndex:36607},{level:2,title:"访问字段",slug:"访问字段",normalizedTitle:"访问字段",charIndex:10047},{level:2,title:"调用方法",slug:"调用方法",normalizedTitle:"调用方法",charIndex:34743},{level:3,title:"调用方法",slug:"调用方法-2",normalizedTitle:"调用方法",charIndex:34743},{level:3,title:"调用静态方法",slug:"调用静态方法",normalizedTitle:"调用静态方法",charIndex:40393},{level:2,title:"调用构造方法",slug:"调用构造方法",normalizedTitle:"调用构造方法",charIndex:40895},{level:2,title:"获取继承关系",slug:"获取继承关系",normalizedTitle:"获取继承关系",charIndex:41934},{level:2,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:42264},{level:2,title:"使用注解",slug:"使用注解",normalizedTitle:"使用注解",charIndex:44740},{level:2,title:"定义注解",slug:"定义注解",normalizedTitle:"定义注解",charIndex:45313},{level:3,title:"元注解",slug:"元注解",normalizedTitle:"元注解",charIndex:45504},{level:2,title:"处理注解",slug:"处理注解",normalizedTitle:"处理注解",charIndex:47045},{level:3,title:"使用注解",slug:"使用注解-2",normalizedTitle:"使用注解",charIndex:44740},{level:2,title:"擦拭法",slug:"擦拭法",normalizedTitle:"擦拭法",charIndex:49015},{level:2,title:"extends通配符",slug:"extends通配符",normalizedTitle:"extends通配符",charIndex:49720},{level:2,title:"super通配符",slug:"super通配符",normalizedTitle:"super通配符",charIndex:50931},{level:3,title:"PESC原则",slug:"pesc原则",normalizedTitle:"pesc原则",charIndex:51327},{level:3,title:"无限定通配符",slug:"无限定通配符",normalizedTitle:"无限定通配符",charIndex:51491},{level:2,title:"泛型和反射",slug:"泛型和反射",normalizedTitle:"泛型和反射",charIndex:52051},{level:2,title:"Java集合简介",slug:"java集合简介",normalizedTitle:"java集合简介",charIndex:52207},{level:2,title:"List",slug:"list",normalizedTitle:"list",charIndex:8534},{level:3,title:"List和Array互转",slug:"list和array互转",normalizedTitle:"list和array互转",charIndex:52800},{level:2,title:"HashMap（基于jdk 1.8和jdk 1.7）",slug:"hashmap-基于jdk-1-8和jdk-1-7",normalizedTitle:"hashmap（基于jdk 1.8和jdk 1.7）",charIndex:53222},{level:2,title:"IO简介",slug:"io简介",normalizedTitle:"io简介",charIndex:53334},{level:3,title:"InputStream / OutputStream",slug:"inputstream-outputstream",normalizedTitle:"inputstream / outputstream",charIndex:53478},{level:3,title:"Reader / Writer",slug:"reader-writer",normalizedTitle:"reader / writer",charIndex:53597},{level:3,title:"同步和异步",slug:"同步和异步",normalizedTitle:"同步和异步",charIndex:54080},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:54374},{level:2,title:"File对象",slug:"file对象",normalizedTitle:"file对象",charIndex:54579},{level:2,title:"InputStream",slug:"inputstream",normalizedTitle:"inputstream",charIndex:53478},{level:3,title:"缓冲",slug:"缓冲",normalizedTitle:"缓冲",charIndex:18140},{level:3,title:"阻塞",slug:"阻塞",normalizedTitle:"阻塞",charIndex:56624},{level:3,title:"小结",slug:"小结-2",normalizedTitle:"小结",charIndex:54374},{level:2,title:"OutputStream",slug:"outputstream",normalizedTitle:"outputstream",charIndex:53492},{level:3,title:"FileOutputStream",slug:"fileoutputstream",normalizedTitle:"fileoutputstream",charIndex:54330},{level:3,title:"阻塞",slug:"阻塞-2",normalizedTitle:"阻塞",charIndex:56624},{level:3,title:"OutputStream实现类",slug:"outputstream实现类",normalizedTitle:"outputstream实现类",charIndex:59252},{level:3,title:"小结",slug:"小结-3",normalizedTitle:"小结",charIndex:54374},{level:2,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:5491},{level:3,title:"序列化",slug:"序列化-2",normalizedTitle:"序列化",charIndex:5491},{level:3,title:"反序列化",slug:"反序列化",normalizedTitle:"反序列化",charIndex:60263},{level:3,title:"安全性",slug:"安全性",normalizedTitle:"安全性",charIndex:32933},{level:3,title:"小结",slug:"小结-4",normalizedTitle:"小结",charIndex:54374},{level:2,title:"Reader",slug:"reader",normalizedTitle:"reader",charIndex:53597},{level:3,title:"FileReader",slug:"filereader",normalizedTitle:"filereader",charIndex:54347},{level:3,title:"CharArrayReader",slug:"chararrayreader",normalizedTitle:"chararrayreader",charIndex:64661},{level:3,title:"StringReader",slug:"stringreader",normalizedTitle:"stringreader",charIndex:64849},{level:3,title:"InputStreamReader",slug:"inputstreamreader",normalizedTitle:"inputstreamreader",charIndex:64979},{level:3,title:"小结",slug:"小结-5",normalizedTitle:"小结",charIndex:54374},{level:2,title:"Writer",slug:"writer",normalizedTitle:"writer",charIndex:53606},{level:3,title:"FileWriter",slug:"filewriter",normalizedTitle:"filewriter",charIndex:54358},{level:3,title:"CharArrayWriter",slug:"chararraywriter",normalizedTitle:"chararraywriter",charIndex:66947},{level:3,title:"StringWriter",slug:"stringwriter",normalizedTitle:"stringwriter",charIndex:67270},{level:3,title:"OutputStreamWriter",slug:"outputstreamwriter",normalizedTitle:"outputstreamwriter",charIndex:67389},{level:3,title:"小结",slug:"小结-6",normalizedTitle:"小结",charIndex:54374},{level:2,title:"Files",slug:"files",normalizedTitle:"files",charIndex:54918},{level:3,title:"小结",slug:"小结-7",normalizedTitle:"小结",charIndex:54374},{level:2,title:"工厂方法",slug:"工厂方法",normalizedTitle:"工厂方法",charIndex:20613},{level:2,title:"原型",slug:"原型",normalizedTitle:"原型",charIndex:69431},{level:2,title:"单例",slug:"单例",normalizedTitle:"单例",charIndex:69516},{level:2,title:"装饰器模式",slug:"装饰器模式",normalizedTitle:"装饰器模式",charIndex:69898},{level:2,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:70190},{level:2,title:"策略模式",slug:"策略模式",normalizedTitle:"策略模式",charIndex:70317},{level:2,title:"模板方法",slug:"模板方法",normalizedTitle:"模板方法",charIndex:70393}],headersStr:"java程序基础 JVM、JDK和JRE 基本数据类型 常量 var关键字 位运算 运算优先级 浮点数运算 数组操作 数组 面向对象基础 可变参数 方法重载 继承 多态 final transient 抽象类 面向抽象编程 接口 静态字段和静态方法 包 作用域 classpath和jar 模块 Java核心类 字符串和编码 StringBuilder 包装类型 JavaBean 枚举类 BigInteger BigDecimal Object类 int和Integer的区别 Java String、StringBuffer 和 StringBuilder 的区别 常用工具类 Java的异常 捕获异常 抛出异常 断言 Class类 动态加载 访问字段 调用方法 调用方法 调用静态方法 调用构造方法 获取继承关系 动态代理 使用注解 定义注解 元注解 处理注解 使用注解 擦拭法 extends通配符 super通配符 PESC原则 无限定通配符 泛型和反射 Java集合简介 List List和Array互转 HashMap（基于jdk 1.8和jdk 1.7） IO简介 InputStream / OutputStream Reader / Writer 同步和异步 小结 File对象 InputStream 缓冲 阻塞 小结 OutputStream FileOutputStream 阻塞 OutputStream实现类 小结 序列化 序列化 反序列化 安全性 小结 Reader FileReader CharArrayReader StringReader InputStreamReader 小结 Writer FileWriter CharArrayWriter StringWriter OutputStreamWriter 小结 Files 小结 工厂方法 原型 单例 装饰器模式 代理模式 策略模式 模板方法",content:'# Java快速入门\n\n\n# java程序基础\n\n\n# JVM、JDK和JRE\n\n * JVM：Java Virtual Machine\n * JDK：Java Development Kit\n * JRE：Java Runtime Environment\n\nJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。\n\nJDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。\n\nJRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。\n\n\n\n我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。\n\n\n# 基本数据类型\n\n * 整数类型：byte，short，int，long\n * 浮点数类型：float，double\n * 字符类型：char\n * 布尔类型：boolean\n\n计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。\n\nJava基本数据类型占用的字节数：\n\nBoolean 占1个字节\n\n       ┌───┐\n  byte │   │\n       └───┘\n       ┌───┬───┐\n short │   │   │\n       └───┴───┘\n       ┌───┬───┬───┬───┐\n   int │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\n  long │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┬───┬───┐\n float │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\ndouble │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┐\n  char │   │   │\n       └───┴───┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 常量\n\n定义变量的时候，如果加上final修饰符，这个变量就变成了常量：\n\nfinal double PI = 3.14; // PI是一个常量\n\n\n1\n\n\n常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写。\n\n\n# var关键字\n\n如果想省略变量类型，可以使用var关键字：\n\nvar sb = new StringBuilder();\n\n\n1\n\n\n编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句：\n\nvar sb = new StringBuilder();\n\n\n1\n\n\n实际上会自动变成：\n\nStringBuilder sb = new StringBuilder();\n\n\n1\n\n\n因此，使用var定义变量，仅仅是少写了变量类型而已。\n\n\n# 位运算\n\n位运算是按位进行与、或、非和异或的运算。\n\n与运算的规则是，必须两个数同时为1，结果才为1。\n\n或运算的规则是，只要任意一个为1，结果就为1。\n\n非运算的规则是，0和1互换。\n\n异或运算的规则是，如果两个数不同，结果为1，否则为0。\n\n\n# 运算优先级\n\n在Java的计算表达式中，运算优先级从高到低依次是：\n\n * ()\n * ! ~ ++ --\n * * / %\n * + -\n * << >> >>>\n * &\n * |\n * += -= *= /=\n\n\n# 浮点数运算\n\n浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。\n\n由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：\n\n// 比较x和y是否相等，先计算其差的绝对值:\ndouble r = Math.abs(x - y);\n// 再判断绝对值是否足够小:\nif (r < 0.00001) {\n    // 可以认为相等\n} else {\n    // 不相等\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：\n\n * NaN表示Not a Number\n * Infinity表示无穷大\n * -Infinity表示负无穷大\n\n可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。\n\n\n# 数组操作\n\n\n# 数组\n\n数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；\n\n数组一旦创建后，大小就不可改变。\n\n\n# 面向对象编程\n\n\n# 面向对象基础\n\n\n# 可变参数\n\n可变参数用类型...定义，可变参数相当于数组类型：\n\nclass Group {\n    private String[] names;\n\n    public void setNames(String... names) {\n        this.names = names;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nGroup g = new Group();\ng.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun"); // 传入3个String\ng.setNames("Xiao Ming", "Xiao Hong"); // 传入2个String\ng.setNames("Xiao Ming"); // 传入1个String\ng.setNames(); // 传入0个String\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法重载\n\n方法名相同，但各自的参数不同，称为方法重载（Overload）。\n\n注意：方法重载的返回值类型通常都是相同的。\n\n\n# 继承\n\n# super\n\nsuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如：\n\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n\nclass Student extends Person {\n    public String hello() {\n        return "Hello, " + super.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 向上转型\n\n如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例：\n\nStudent s = new Student();\n\n\n1\n\n\n如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例：\n\nPerson p = new Person();\n\n\n1\n\n\n现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？\n\nPerson p = new Student(); // ???\n\n\n1\n\n\n测试一下就可以发现，这种指向是允许的！\n\n这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！\n\n这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。\n\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型：\n\nStudent s = new Student();\nPerson p = s; // upcasting, ok\nObject o1 = p; // upcasting, ok\nObject o2 = s; // upcasting, ok\n\n\n1\n2\n3\n4\n\n\n注意到继承树是Student > Person > Object，所以，可以把Student类型转型为Person，或者更高层次的Object。\n\n# 向下转型\n\n和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：\n\nPerson p1 = new Student(); // upcasting, ok\nPerson p2 = new Person();\nStudent s1 = (Student) p1; // ok\nStudent s2 = (Student) p2; // runtime error! ClassCastException!\n\n\n1\n2\n3\n4\n\n\n如果测试上面的代码，可以发现：\n\nPerson类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。\n\n向下转型时最好先用instanceof判断一下，避免转型失败。\n\n\n# 多态\n\n在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。\n\nOverride和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。\n\n多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：\n\nPerson p = new Student();\np.run(); // 无法确定运行时究竟调用哪个run()方法\n\n\n1\n2\n\n\n有童鞋会问，从上面的代码一看就明白，肯定调用的是Student的run()方法啊。\n\n但是，假设我们编写这样一个方法：\n\npublic void runTwice(Person p) {\n    p.run();\n    p.run();\n}\n\n\n1\n2\n3\n4\n\n\n它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。\n\n多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。\n\n\n# final\n\n继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override。\n\n如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承。\n\n对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。\n\n\n# transient\n\n我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。\n\n然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。\n\n * 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。\n\n * transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。\n\n * 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。\n\n\n# 抽象类\n\n如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：\n\nclass Person {\n    public abstract void run();\n}\n\n\n1\n2\n3\n\n\n把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。\n\n必须把Person类本身也声明为abstract，才能正确编译它：\n\nabstract class Person {\n    public abstract void run();\n}\n\n\n1\n2\n3\n\n\n使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类。\n\n无法实例化的抽象类有什么用？\n\n因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。\n\n\n# 面向抽象编程\n\n当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例：\n\nPerson s = new Student();\nPerson t = new Teacher();\n\n\n1\n2\n\n\n这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：\n\n// 不关心Person变量的具体子类型:\ns.run();\nt.run();\n\n\n1\n2\n3\n\n\n同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：\n\n// 同样不关心新的子类是如何实现run()方法的：\nPerson e = new Employee();\ne.run();\n\n\n1\n2\n3\n\n\n这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。\n\n面向抽象编程的本质就是：\n\n * 上层代码只定义规范（例如：abstract class Person）；\n * 不需要子类就可以实现业务逻辑（正常编译）；\n * 具体的业务逻辑由不同的子类实现，调用者并不关心。\n\n\n# 接口\n\n在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。\n\n如果一个抽象类没有字段，所有方法全部都是抽象方法：\n\nabstract class Person {\n    public abstract void run();\n    public abstract String getName();\n}\n\n\n1\n2\n3\n4\n\n\n就可以把该抽象类改写为接口：interface。\n\n在Java中，使用interface可以声明一个接口：\n\ninterface Person {\n    void run();\n    String getName();\n}\n\n\n1\n2\n3\n4\n\n\n所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。\n\n当一个具体的class去实现一个interface时，需要使用implements关键字。\n\n我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。\n\n抽象类和接口的对比如下：\n\n        ABSTRACT CLASS     INTERFACE\n继承      只能extends一个class   可以implements多个interface\n字段      可以定义实例字段           不能定义实例字段\n抽象方法    可以定义抽象方法           可以定义抽象方法\n非抽象方法   可以定义非抽象方法          可以定义default方法\n\n# 接口继承\n\n一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如：\n\ninterface Hello {\n    void hello();\n}\n\ninterface Person extends Hello {\n    void run();\n    String getName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。\n\n# 继承关系\n\n合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：\n\n┌───────────────┐\n│   Iterable    │\t\t\n└───────────────┘\n        ▲                ┌───────────────────┐\n        │                │      Object       │\n┌───────────────┐        └───────────────────┘\n│  Collection   │                  ▲\n└───────────────┘                  │\n        ▲     ▲          ┌───────────────────┐\n        │     └──────────│AbstractCollection │\n┌───────────────┐        └───────────────────┘\n│     List      │                  ▲\n└───────────────┘                  │\n              ▲          ┌───────────────────┐\n              └──────────│   AbstractList    │\n                         └───────────────────┘\n                                ▲     ▲\n                                │     │\n                                │     │\n                     ┌────────────┐ ┌────────────┐\n                     │ ArrayList  │ │ LinkedList │\n                     └────────────┘ └────────────┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：\n\nList list = new ArrayList(); // 用List接口引用具体子类的实例\nCollection coll = list; // 向上转型为Collection接口\nIterable it = coll; // 向上转型为Iterable接口\n\n\n1\n2\n3\n\n\n# default方法\n\n接口可以定义default方法（JDK>=1.8）。\n\n在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法：\n\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Student("Xiao Ming");\n        p.run();\n    }\n}\n\ninterface Person {\n    String getName();\n    default void run() {\n        System.out.println(getName() + " run");\n    }\n}\n\nclass Student implements Person {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。\n\ndefault方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。\n\n\n# 静态字段和静态方法\n\n# 静态字段\n\n在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。\n\n还有一种字段，是用static修饰的字段，称为静态字段：static field。\n\n静态字段只有一个共享“空间”，所有实例都会共享该字段。\n\n虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。\n\n因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。\n\n推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。\n\n# 静态方法\n\n用static修饰的方法称为静态方法。\n\n因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。\n\n静态方法经常用于工具类。例如：\n\n * Arrays.sort()\n * Math.random()\n\n# 接口的静态字段\n\n因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型：\n\npublic interface Person {\n    public static final int MALE = 1;\n    public static final int FEMALE = 2;\n}\n\n\n1\n2\n3\n4\n\n\n实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：\n\npublic interface Person {\n    // 编译器会自动加上public statc final:\n    int MALE = 1;\n    int FEMALE = 2;\n}\n\n\n1\n2\n3\n4\n5\n\n\n编译器会自动把该字段变为public static final类型。\n\n\n# 包\n\n# 包的定义\n\n在现实中，如果小明写了一个Person类，小红也写了一个Person类，现在，小白既想用小明的Person，也想用小红的Person，怎么办？\n\n在Java中，我们使用package来解决名字冲突。\n\nJava定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。\n\n包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。\n\n# 包作用域\n\n位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面：\n\npackage hello;\n\npublic class Person {\n    // 包作用域:\n    void hello() {\n        System.out.println("Hello!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nMain类也定义在hello包下面：\n\npackage hello;\n\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        p.hello(); // 可以调用，因为Main和Person在同一个包\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法：\n\npackage main;\n\n// 导入System类的所有静态字段和静态方法:\nimport static java.lang.System.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 相当于调用System.out.println(…)\n        out.println("Hello, world!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\nJava编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：\n\n * 如果是完整类名，就直接根据完整类名查找这个class；\n * 如果是简单类名，按下面的顺序依次查找：\n   * 查找当前package是否存在这个class；\n   * 查找import的包是否包含这个class；\n   * 查找java.lang包是否包含这个class。\n\n编写class的时候，编译器会自动帮我们做两个import动作：\n\n * 默认自动import当前package的其他class；\n * 默认自动import java.lang.*。\n\n*在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）。\n\n\n# 作用域\n\npublic、protected、private这些修饰符可以用来限定访问作用域。\n\n# public\n\n定义为public的class、interface可以被其他任何类访问。\n\n定义为public的field、method可以被其他类访问，前提是首先有访问class的权限。\n\n# private\n\n定义为private的field、method无法被其他类访问。\n\n实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。\n\n定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。\n\n由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问该类private的权限。\n\n# protected\n\nprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类。\n\n# package\n\n包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。\n\n只要在同一个包，就可以访问package权限的class、field和method。\n\n注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。\n\n# 局部变量\n\n在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。\n\n使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。\n\n# final\n\nJava还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。\n\n * 用final修饰class可以阻止被继承；\n * 用final修饰method可以阻止被子类覆写；\n * 用final修饰field可以阻止被重新赋值；\n * 用final修饰局部变量可以阻止被重新赋值。\n\n# 最佳实践\n\n如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。\n\n把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。\n\n一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。\n\n\n# classpath和jar\n\n# classpath\n\nclasspath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。\n\n因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。\n\n# jar包\n\n如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。\n\njar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。\n\njar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath。\n\n\n# 模块\n\n从Java 9开始，JDK又引入了模块（Module）。\n\nJar只是用于存放class的容器，它并不关心class之间的依赖。\n\n从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。\n\n# 打包jre\n\n过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？\n\n现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。\n\n# 访问权限\n\n前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。\n\n确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。\n\n举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出：\n\nmodule java.xml {\n    exports java.xml;\n    exports javax.xml.catalog;\n    exports javax.xml.datatype;\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有它声明的导出的包，外部代码才被允许访问。因此，模块进一步隔离了代码的访问权限。\n\n廖雪峰关于模块的讲解\n\n\n# Java核心类\n\n\n# 字符串和编码\n\n# String\n\n在Java中，String是一个引用类型，它本身也是一个class。\n\n实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：\n\nString s2 = new String(new char[] {\'H\', \'e\', \'l\', \'l\', \'o\', \'!\'});\n\n\n1\n\n\nJava字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。\n\n# 字符串比较\n\n当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。\n\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = "hello";\n        String s2 = "HELLO".toLowerCase();\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。\n\n两个字符串比较，必须总是使用equals()方法。\n\n要忽略大小写比较，使用equalsIgnoreCase()方法。\n\nString类常用的方法：\n\n// 是否包含子串:\n"Hello".contains("ll"); // true\n"Hello".indexOf("l"); // 2\n"Hello".lastIndexOf("l"); // 3\n"Hello".startsWith("He"); // true\n"Hello".endsWith("lo"); // true\n"Hello".substring(2); // "llo"\n"Hello".substring(2, 4); "ll"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n：\n\n"  \\tHello\\r\\n ".trim(); // "Hello"\n\n\n1\n\n\n注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。\n\n另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除：\n\n"\\u3000Hello\\u3000".strip(); // "Hello"\n" Hello ".stripLeading(); // "Hello "\n" Hello ".stripTrailing(); // " Hello"\n\n\n1\n2\n3\n\n\nString还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串：\n\n"".isEmpty(); // true，因为字符串长度为0\n"  ".isEmpty(); // false，因为字符串长度不为0\n"  \\n".isBlank(); // true，因为只包含空白字符\n" Hello ".isBlank(); // false，因为包含非空白字符\n\nString s = "hello";\ns.replace(\'l\', \'w\'); // "hewwo"，所有字符\'l\'被替换为\'w\'\ns.replace("ll", "~~"); // "he~~o"，所有子串"ll"被替换为"~~"\n\nString s = "A,,B;C ,D";\ns.replaceAll("[\\\\,\\\\;\\\\s]+", ","); // "A,B,C,D"\n\nString s = "A,B,C,D";\nString[] ss = s.split("\\\\,"); // {"A", "B", "C", "D"}\n\nString[] arr = {"A", "B", "C"};\nString s = String.join("***", arr); // "A***B***C"\n\nString.valueOf(123); // "123"\nString.valueOf(45.67); // "45.67"\nString.valueOf(true); // "true"\n\nInteger.getInteger("java.version"); // 版本号，11\n\nchar[] cs = "Hello".toCharArray(); // String -> char[]\nString s = new String(cs); // char[] -> String\n//通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 字符编码\n\n在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。\n\n为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。\n\n那我们经常使用的UTF-8又是什么编码呢？因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。\n\nUTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。\n\n在Java中，char类型实际上就是两个字节的Unicode编码。\n\nJava的String和char在内存中总是以Unicode编码表示。\n\n# 延伸阅读\n\n对于不同版本的JDK，String类在内存中有不同的优化方式。具体来说，早期JDK版本的String总是以char[]存储，它的定义如下：\n\npublic final class String {\n    private final char[] value;\n    private final int offset;\n    private final int count;\n}\n\n\n1\n2\n3\n4\n5\n\n\n而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符：\n\npublic final class String {\n    private final byte[] value;\n    private final byte coder; // 0 = LATIN1, 1 = UTF16\n\n\n1\n2\n3\n\n\n对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。\n\n\n# StringBuilder\n\nJava编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。\n\n虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。\n\n为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。\n\n你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。\n\nStringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。\n\n# StringJoiner\n\n要高效拼接字符串，应该使用StringBuilder。\n\nimport java.util.StringJoiner;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {"Bob", "Alice", "Grace"};\n      \t//结果用,分割，第二个参数是开头，第三个参数是结尾\n        var sj = new StringJoiner(", ", "Hello ", "!");\n        for (String name : names) {\n            sj.add(name);\n        }\n        System.out.println(sj.toString());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n那么StringJoiner内部是如何拼接字符串的呢？如果查看源码，可以发现，StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。\n\n# String.join()\n\nString还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便：\n\nString[] names = {"Bob", "Alice", "Grace"};\nvar s = String.join(", ", names);\n\n\n1\n2\n\n\n\n# 包装类型\n\n我们已经知道，Java的数据类型分两种：\n\n * 基本类型：byte，short，int，long，boolean，float，double，char\n * 引用类型：所有class和interface类型\n\n注：String就是一个class。\n\n那么，如何把一个基本类型视为对象（引用类型）？\n\n比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：\n\npublic class Integer {\n    private int value;\n\n    public Integer(int value) {\n        this.value = value;\n    }\n\n    public int intValue() {\n        return this.value;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：\n\n基本类型      对应的引用类型\nboolean   java.lang.Boolean\nbyte      java.lang.Byte\nshort     java.lang.Short\nint       java.lang.Integer\nlong      java.lang.Long\nfloat     java.lang.Float\ndouble    java.lang.Double\nchar      java.lang.Character\n\n我们可以直接使用这些基本类型的包装类。\n\n# 自动装箱和自动拆箱\n\nInteger n = 100; // 编译器自动使用Integer.valueOf(int)\nint x = n; // 编译器自动使用Integer.intValue()\n\n\n1\n2\n\n\n这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。\n\n注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。\n\n装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException。\n\n# 不变类\n\n所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：\n\npublic final class Integer {\n    private final int value;\n}\n\n\n1\n2\n3\n\n\n因此，一旦创建了Integer对象，该对象就是不变的。\n\n对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较。\n\n因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：\n\n * 方法1：Integer n = new Integer(100);\n * 方法2：Integer n = Integer.valueOf(100);\n\n方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。\n\n我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。\n\n# 进制转换\n\nInteger类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：\n\nint x1 = Integer.parseInt("100"); // 100\nint x2 = Integer.parseInt("100", 16); // 256,因为按16进制解析\n\nSystem.out.println(Integer.toHexString(100)); // "64",表示为16进制\nSystem.out.println(Integer.toOctalString(100)); // "144",表示为8进制\nSystem.out.println(Integer.toBinaryString(100)); // "1100100",表示为2进制\n\n\n1\n2\n3\n4\n5\n6\n\n\nJava的包装类型还定义了一些有用的静态变量\n\n// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:\nBoolean t = Boolean.TRUE;\nBoolean f = Boolean.FALSE;\n// int可表示的最大/最小值:\nint max = Integer.MAX_VALUE; // 2147483647\nint min = Integer.MIN_VALUE; // -2147483648\n// long类型占用的bit和byte数量:\nint sizeOfLong = Long.SIZE; // 64 (bits)\nint bytesOfLong = Long.BYTES; // 8 (bytes)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# JavaBean\n\n如果读写方法符合以下这种命名规范：\n\n// 读方法:\npublic Type getXyz()\n// 写方法:\npublic void setXyz(Type value)\n\n\n1\n2\n3\n4\n\n\n那么这种class被称为JavaBean。\n\n# JavaBean的作用\n\nJavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。\n\n# 枚举JavaBean属性\n\n要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector。\n\nimport java.beans.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BeanInfo info = Introspector.getBeanInfo(Person.class);\n        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {\n            System.out.println(pd.getName());\n            System.out.println("  " + pd.getReadMethod());\n            System.out.println("  " + pd.getWriteMethod());\n        }\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 枚举类\n\nenum Weekday {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n\n\n\n1\n2\n3\n4\n\n\n注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。\n\n首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。\n\n其次，不可能引用到非枚举的值，因为无法通过编译。\n\n引用类型比较，要始终使用equals()方法，但enum类型可以例外。\n\n这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较。\n\n----------------------------------------\n\n通过enum定义的枚举类，和其他的class有什么区别？\n\n答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点：\n\n * 定义的enum类型总是继承自java.lang.Enum，且无法被继承；\n * 只能定义出enum的实例，而无法通过new操作符创建enum的实例；\n * 定义的每个实例都是引用类型的唯一实例；\n * 可以将enum类型用于switch语句。\n\n通过name()获取常量定义的字符串，注意不要使用toString()；\n\n通过ordinal()返回常量定义的顺序（无实质意义）；\n\n可以为enum编写构造方法、字段和方法\n\nenum的构造方法要声明为private，字段强烈建议声明为final；\n\nenum适合用在switch语句中。\n\n\n# BigInteger\n\n在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。\n\n如果我们使用的整数范围超过了long型怎么办？java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数。\n\n对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：\n\nBigInteger i1 = new BigInteger("1234567890");\nBigInteger i2 = new BigInteger("12345678901234567890");\nBigInteger sum = i1.add(i2); // 12345678902469135780\n\n\n1\n2\n3\n\n\nBigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法：\n\n * 转换为byte：byteValue()\n * 转换为short：shortValue()\n * 转换为int：intValue()\n * 转换为long：longValue()\n * 转换为float：floatValue()\n * 转换为double：doubleValue()\n\n\n# BigDecimal\n\n和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。\n\nBigDecimal bd = new BigDecimal("123.4567");\nSystem.out.println(bd.multiply(bd)); // 15241.55677489\n\n\n1\n2\n\n\nBigDecimal用scale()表示小数位数，例如：\n\nBigDecimal d1 = new BigDecimal("123.45");\nBigDecimal d2 = new BigDecimal("123.4500");\nBigDecimal d3 = new BigDecimal("1234500");\nSystem.out.println(d1.scale()); // 2,两位小数\nSystem.out.println(d2.scale()); // 4\nSystem.out.println(d3.scale()); // 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal。\n\n如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。\n\n可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal d1 = new BigDecimal("123.456789");\n        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568\n        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567\n        System.out.println(d2);\n        System.out.println(d3);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断。\n\n还可以对BigDecimal做除法的同时求余数。\n\n# 比较BigDecimal\n\n在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等。\n\n必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。\n\n如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数。\n\nBigDecimal也是从Number继承的，也是不可变对象。\n\n\n# Object类\n\nobject类中包含的方法：\n\npublic final native Class<?> getClass();\npublic native int hashCode();\npublic boolean equals(Object obj) {\n\treturn (this == obj);\n}\nprotected native Object clone() throws CloneNotSupportedException;\npublic String toString() {\n\treturn getClass().getName() + "@" + Integer.toHexString(hashCode());\n}\npublic final native void notify();\npublic final native void notifyAll();\npublic final native void wait(long timeout) throws InterruptedException;\nprotected void finalize() throws Throwable { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# int和Integer的区别\n\n1、Integer是int的包装类，int则是java的一种基本数据类型 2、Integer变量必须实例化后才能使用，而int变量不需要 3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 4、Integer的默认值是null，int的默认值是0\n\n延伸： 关于Integer和int的比较 1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\n\nInteger i = new Integer(100);\nInteger j = new Integer(100);\nSystem.out.print(i == j); //false\n\n\n1\n2\n3\n\n\n2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）\n\nInteger i = new Integer(100);\nint j = 100；\nSystem.out.print(i == j); //true\n\n\n1\n2\n3\n\n\n3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128~127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128~127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）\n\nInteger i = new Integer(100);\nInteger j = 100;\nSystem.out.print(i == j); //false\n\n\n1\n2\n3\n\n\n4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\n\nInteger i = 100;\nInteger j = 100;\nSystem.out.print(i == j); //true\nInteger i = 128;\nInteger j = 128;\nSystem.out.print(i == j); //false\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：\n\npublic static Integer valueOf(int i){\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high){\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    }\n    return new Integer(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\njava对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了\n\n如果有错误的地方，还请指正。\n\n参考： http://blog.csdn.net/you23hai45/article/details/50734274 http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html\n\n\n# Java String、StringBuffer 和 StringBuilder 的区别\n\n# String\n\nString：字符串常量，字符串长度不可变。Java 中 String 是 immutable（不可变）的。\n\nString 类的包含如下定义：\n\n/** The value is used for character storage. */\nprivate final char value[];\n\n/** The offset is the first index of the storage that is used. */\nprivate final int offset;\n\n/** The count is the number of characters in the String. */\nprivate final int count;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用于存放字符的数组被声明为 final 的，因此只能赋值一次，不可再更改。\n\n# StringBuffer（JDK1.0）\n\nStringBuffer：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。\n\nJava.lang.StringBuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。\n\nStringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。\n\n * append 方法始终将这些字符添加到缓冲区的末端；\n * insert 方法则在指定的点添加字符。\n\n例如，如果 z 引用一个当前内容是 start 的字符串缓冲区对象，则此方法调用 z.append("le") 会使字符串缓冲区包含 startle ，而 z.insert(4, "le") 将更改字符串缓冲区，使之包含 starlet 。\n\n# StringBuilder（JDK5.0）\n\nStringBuilder：字符串变量（非线程安全）。在内部，StringBuilder 对象被当作是一个包含字符序列的变长数组。\n\njava.lang.StringBuilder 是一个可变的字符序列，是 JDK5.0 新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n\n其构造方法如下：\n\n构造方法                              描述\nStringBuilder()                   创建一个容量为16的StringBuilder对象（16个空元素）\nStringBuilder(CharSequence cs)    创建一个包含cs的StringBuilder对象，末尾附加16个空元素\nStringBuilder(int initCapacity)   创建一个容量为initCapacity的StringBuilder对象\nStringBuilder(String s)           创建一个包含s的StringBuilder对象，末尾附加16个空元素\n\n在大部分情况下，StringBuilder > StringBuffer。这主要是由于前者不需要考虑线程安全。\n\n# 三者区别\n\nString 类型和 StringBuffer 的主要性能区别：String 是不可变的对象, 因此在每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。\n\n使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。\n\n在某些特别情况下， String 对象的字符串拼接其实是被 Java Compiler 编译成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，例如：\n\nString s1 = “This is only a” + “ simple” + “ test”;\nStringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);\n\n\n1\n2\n\n\n生成 String s1 对象的速度并不比 StringBuffer 慢。其实在 Java Compiler 里，自动做了如下转换：\n\nJava Compiler直接把上述第一条语句编译为：\n\nString s1 = “This is only a simple test”;  \n\n\n1\n\n\n所以速度很快。但要注意的是，如果拼接的字符串来自另外的 String 对象的话，Java Compiler 就不会自动转换了，速度也就没那么快了，例如：\n\nString s2 = “This is only a”;  \nString s3 = “ simple”;  \nString s4 = “ test”;  \nString s1 = s2 + s3 + s4;  \n\n\n1\n2\n3\n4\n\n\n这时候，Java Compiler 会规规矩矩的按照原来的方式去做，String 的 concatenation（即+）操作利用了 StringBuilder（或StringBuffer）的append 方法实现，此时，对于上述情况，若 s2，s3，s4 采用 String 定义，拼接时需要额外创建一个 StringBuffer（或StringBuilder），之后将StringBuffer 转换为 String，若采用 StringBuffer（或StringBuilder），则不需额外创建 StringBuffer。\n\n# 使用策略\n\n * （1）基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。\n\n * （2）不要使用String类的"+"来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。例如：\n   \n   String result = "";\n   for (String s : hugeArray) {\n       result = result + s;\n   }\n   \n   // 使用StringBuilder\n   StringBuilder sb = new StringBuilder();\n   for (String s : hugeArray) {\n       sb.append(s);\n   }\n   String result = sb.toString();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会创建一个String result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）。\n\n * （3）为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。\n\n * （4）StringBuilder 一般使用在方法内部来完成类似 + 功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer 主要用在全局变量中。\n\n * （5）相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用 StringBuilder；否则还是用 StringBuffer。\n\n\n# 常用工具类\n\n# Math\n\n顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：\n\n求绝对值：\n\nMath.abs(-100); // 100\nMath.abs(-7.8); // 7.8\n\n\n1\n2\n\n\n取最大或最小值：\n\nMath.max(100, 99); // 100\nMath.min(1.2, 2.3); // 1.2\n\n\n1\n2\n\n\n计算xy次方：\n\nMath.pow(2, 10); // 2的10次方=1024\n\n\n1\n\n\n计算√x：\n\nMath.sqrt(2); // 1.414...\n\n\n1\n\n\n计算ex次方：\n\nMath.exp(2); // 7.389...\n\n\n1\n\n\n计算以e为底的对数：\n\nMath.log(4); // 1.386...\n\n\n1\n\n\n计算以10为底的对数：\n\nMath.log10(100); // 2\n\n\n1\n\n\n三角函数：\n\nMath.sin(3.14); // 0.00159...\nMath.cos(3.14); // -0.9999...\nMath.tan(3.14); // -0.0015...\nMath.asin(1.0); // 1.57079...\nMath.acos(1.0); // 0.0\n\n\n1\n2\n3\n4\n5\n\n\nMath还提供了几个数学常量：\n\ndouble pi = Math.PI; // 3.14159...\ndouble e = Math.E; // 2.7182818...\nMath.sin(Math.PI / 6); // sin(π/6) = 0.5\n\n\n1\n2\n3\n\n\n生成一个随机数x，x的范围是0 <= x < 1：\n\nMath.random(); // 0.53907... 每次都不一样\n\n\n1\n\n\n# Random\n\nRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。\n\n要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：\n\nRandom r = new Random();\nr.nextInt(); // 2071575453,每次都不一样\nr.nextInt(10); // 5,生成一个[0,10)之间的int\nr.nextLong(); // 8811649292570369305,每次都不一样\nr.nextFloat(); // 0.54335...生成一个[0,1)之间的float\nr.nextDouble(); // 0.3716...生成一个[0,1)之间的double\n\n\n1\n2\n3\n4\n5\n6\n\n\n有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。\n\n这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。\n\n如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列。\n\n# SecureRandom\n\n有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：\n\nSecureRandom sr = new SecureRandom();\nSystem.out.println(sr.nextInt(100));\n\n\n1\n2\n\n\nSecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。\n\n在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。\n\n\n# 异常处理\n\n\n# Java的异常\n\n因为Java的异常是class，它的继承关系如下：\n\n                     ┌───────────┐\n                     │  Object   │\n                     └───────────┘\n                           ▲\n                           │\n                     ┌───────────┐\n                     │ Throwable │\n                     └───────────┘\n                           ▲\n                 ┌─────────┴─────────┐\n                 │                   │\n           ┌───────────┐       ┌───────────┐\n           │   Error   │       │ Exception │\n           └───────────┘       └───────────┘\n                 ▲                   ▲\n         ┌───────┘              ┌────┴──────────┐\n         │                      │               │\n┌─────────────────┐    ┌─────────────────┐┌───────────┐\n│OutOfMemoryError │... │RuntimeException ││IOException│...\n└─────────────────┘    └─────────────────┘└───────────┘\n                                ▲\n                    ┌───────────┴─────────────┐\n                    │                         │\n         ┌─────────────────────┐ ┌─────────────────────────┐\n         │NullPointerException │ │IllegalArgumentException │...\n         └─────────────────────┘ └─────────────────────────┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如：\n\n * OutOfMemoryError：内存耗尽\n * NoClassDefFoundError：无法加载某个Class\n * StackOverflowError：栈溢出\n\n而Exception则是运行时的错误，它可以被捕获并处理。\n\n某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：\n\n * NumberFormatException：数值类型的格式错误\n * FileNotFoundException：未找到文件\n * SocketException：读取网络失败\n\n还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：\n\n * NullPointerException：对某个null的对象调用方法或字段\n * IndexOutOfBoundsException：数组索引越界\n\nException又分为两大类：\n\n 1. RuntimeException以及它的子类；\n 2. 非RuntimeException（包括IOException、ReflectiveOperationException等等）\n\nJava规定：\n\n * 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。\n * 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。\n\n\n# 捕获异常\n\n在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { ... }中，然后使用catch捕获对应的Exception及其子类。\n\n可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。\n\n存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。\n\n注意finally有几个特点：\n\n 1. finally语句不是必须的，可写可不写；\n 2. finally总是最后执行。\n\n\n# 抛出异常\n\n通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过Throwable.getSuppressed()获取所有添加的Suppressed Exception。\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Exception origin = null;\n        try {\n            System.out.println(Integer.parseInt("abc"));\n        } catch (Exception e) {\n            origin = e;\n            throw e;\n        } finally {\n            Exception e = new IllegalArgumentException();\n            if (origin != null) {\n                e.addSuppressed(origin);\n            }\n            throw e;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 断言\n\n断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。\n\npublic static void main(String[] args) {\n    double x = Math.abs(-123.45);\n    assert x >= 0;\n    System.out.println(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\n语句assert x >= 0;即为断言，断言条件x >= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。\n\nJVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。\n\n要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。\n\n\n# 反射\n\n\n# Class类\n\n反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。\n\n反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。\n\nclass（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值：\n\nNumber n = new Double(123.456); // OK\nString s = new Double(123.456); // compile error!\n\n\n1\n2\n\n\n而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。\n\n每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样：\n\npublic final class Class {\n    private Class() {}\n}\n\n\n1\n2\n3\n\n\n以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来：\n\nClass cls = new Class(String);\n\n\n1\n\n\n这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。\n\n----------------------------------------\n\n由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。\n\n这种通过Class实例获取class信息的方法称为反射（Reflection）。\n\n如何获取一个class的Class实例？有三个方法：\n\n方法一：直接通过一个class的静态变量class获取：\n\nClass cls = String.class;\n\n\n1\n\n\n方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：\n\nString s = "Hello";\nClass cls = s.getClass();\n\n\n1\n2\n\n\n方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：\n\nClass cls = Class.forName("java.lang.String");\n\n\n1\n\n\n因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。\n\n注意一下Class实例比较和instanceof的差别：\n\nInteger n = new Integer(123);\n\nboolean b1 = n instanceof Integer; // true，因为n是Integer类型\nboolean b2 = n instanceof Number; // true，因为n是Number类型的子类\n\nboolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class\nboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。\n\n通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。\n\n如果获取到了一个Class实例，我们就可以通过该Class实例来创建对应类型的实例：\n\n// 获取String的Class实例:\nClass cls = String.class;\n// 创建一个String实例:\nString s = (String) cls.newInstance();\n\n\n1\n2\n3\n4\n\n\n上述代码相当于new String()。通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用\n\n\n# 动态加载\n\nJVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：\n\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            create(args[0]);\n        }\n    }\n\n    static void create(String name) {\n        Person p = new Person(name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。\n\n\n# 访问字段\n\n对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。\n\n我们先看看如何通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段：\n\n * Field getField(name)：根据字段名获取某个public的field（包括父类）\n * Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\n * Field[] getFields()：获取所有public的field（包括父类）\n * Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n一个Field对象包含了一个字段的所有信息：\n\n * getName()：返回字段名称，例如，"name"；\n * getType()：返回字段类型，也是一个Class实例，例如，String.class；\n * getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。\n\n通过反射可以获取字段值和设置字段值。\n\n\n# 调用方法\n\n我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method：\n\n * Method getMethod(name, Class...)：获取某个public的Method（包括父类）\n * Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\n * Method[] getMethods()：获取所有public的Method（包括父类）\n * Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）\n\n一个Method对象包含一个方法的所有信息：\n\n * getName()：返回方法名称，例如："getScore"；\n * getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；\n * getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；\n * getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。\n\n\n# 调用方法\n\n// reflection\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // String对象:\n        String s = "Hello world";\n        // 获取String substring(int)方法，参数为int:\n        Method m = String.class.getMethod("substring", int.class);\n        // 在s对象上调用该方法并获取结果:\n        String r = (String) m.invoke(s, 6);\n        // 打印调用结果:\n        System.out.println(r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 调用静态方法\n\nimport java.lang.reflect.Method;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取Integer.parseInt(String)方法，参数为String:\n        Method m = Integer.class.getMethod("parseInt", String.class);\n        // 调用该静态方法并获取结果:\n        Integer n = (Integer) m.invoke(null, "12345");\n        // 打印调用结果:\n        System.out.println(n);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。\n\n通过设置setAccessible(true)来访问非public方法；(可能会设置失败)\n\n\n# 调用构造方法\n\n如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：\n\nPerson p = Person.class.newInstance();\n\n\n1\n\n\n调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。\n\n为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。\n\nimport java.lang.reflect.Constructor;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取构造方法Integer(int):\n        Constructor cons1 = Integer.class.getConstructor(int.class);\n        // 调用构造方法:\n        Integer n1 = (Integer) cons1.newInstance(123);\n        System.out.println(n1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过Class实例获取Constructor的方法如下：\n\n * getConstructor(Class...)：获取某个public的Constructor；\n * getDeclaredConstructor(Class...)：获取某个Constructor；\n * getConstructors()：获取所有public的Constructor；\n * getDeclaredConstructors()：获取所有Constructor。\n\n注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。\n\n调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。\n\n\n# 获取继承关系\n\n通过Class对象可以获取继承关系：\n\n * Class getSuperclass()：获取父类类型；\n * Class[] getInterfaces()：获取当前类实现的所有接口。\n\n要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。\n\n此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()。\n\n如果一个类没有实现任何interface，那么getInterfaces()返回空数组。\n\n通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。\n\n\n# 动态代理\n\n我们来比较Java的class和interface的区别：\n\n * 可以实例化class（非abstract）；\n * 不能实例化interface。\n\n所有interface类型的变量总是通过向上转型并指向某个实例的。\n\nJava标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。\n\n什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：\n\n定义接口：\n\npublic interface Hello {\n    void morning(String name);\n}\n\n\n1\n2\n3\n\n\n编写实现类：\n\npublic class HelloWorld implements Hello {\n    public void morning(String name) {\n        System.out.println("Good morning, " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n创建实例，转型为接口并调用：\n\nHello hello = new HelloWorld();\nhello.morning("Bob");\n\n\n1\n2\n\n\n这种方式就是我们通常编写代码的方式。\n\n还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\npublic class Main {\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals("morning")) {\n                    System.out.println("Good morning, " + args[0]);\n                }\n                return null;\n            }\n        };\n        Hello hello = (Hello) Proxy.newProxyInstance(\n            Hello.class.getClassLoader(), // 传入ClassLoader\n            new Class[] { Hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的InvocationHandler\n        hello.morning("Bob");\n    }\n}\n\ninterface Hello {\n    void morning(String name);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在运行期动态创建一个interface实例的方法如下：\n\n 1. 定义一个InvocationHandler实例，它负责实现接口的方法调用；\n 2. 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：\n    1. 使用的ClassLoader，通常就是接口类的ClassLoader；\n    2. 需要实现的接口数组，至少需要传入一个接口进去；\n    3. 用来处理接口方法调用的InvocationHandler实例。\n 3. 将返回的Object强制转型为接口。\n\n动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：\n\npublic class HelloDynamicProxy implements Hello {\n    InvocationHandler handler;\n    public HelloDynamicProxy(InvocationHandler handler) {\n        this.handler = handler;\n    }\n    public void morning(String name) {\n        handler.invoke(\n           this,\n           Hello.class.getMethod("morning"),\n           new Object[] { name });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。\n\n\n# 注解\n\n\n# 使用注解\n\n什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。\n\n注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。\n\n从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。\n\nJava的注解可以分为三类：\n\n第一类是由编译器使用的注解，例如：\n\n * @Override：让编译器检查该方法是否正确地实现了覆写；\n * @SuppressWarnings：告诉编译器忽略此处代码产生的警告。\n\n这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。\n\n第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。\n\n第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。\n\n注解可以配置参数，没有指定配置的参数使用默认值；\n\n\n# 定义注解\n\nJava语言使用@interface语法来定义注解（Annotation），它的格式如下：\n\npublic @interface Report {\n    int type() default 0;\n    String level() default "info";\n    String value() default "";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 元注解\n\n有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。\n\n# @Target\n\n最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：\n\n * 类或接口：ElementType.TYPE；\n * 字段：ElementType.FIELD；\n * 方法：ElementType.METHOD；\n * 构造方法：ElementType.CONSTRUCTOR；\n * 方法参数：ElementType.PARAMETER。\n\n例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：\n\n@Target(ElementType.METHOD)\npublic @interface Report {\n    int type() default 0;\n    String level() default "info";\n    String value() default "";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @Retention\n\n另一个重要的元注解@Retention定义了Annotation的生命周期：\n\n * 仅编译期：RetentionPolicy.SOURCE；\n * 仅class文件：RetentionPolicy.CLASS；\n * 运行期：RetentionPolicy.RUNTIME。\n\n如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解。\n\n# @Repeatable\n\n使用@Repeatable这个元注解可以定义Annotation是否可重复。\n\n经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：\n\n@Repeatable(Reports.class)\n@Target(ElementType.TYPE)\npublic @interface Report {\n    int type() default 0;\n    String level() default "info";\n    String value() default "";\n}\n\n@Target(ElementType.TYPE)\npublic @interface Reports {\n    Report[] value();\n}\n\n//重复使用这个注解\n@Report(type=1, level="debug")\n@Report(type=2, level="warning")\npublic class Hello {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# @Inherited\n\n使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效。\n\n其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。\n\n\n# 处理注解\n\nJava的注解本身对代码逻辑没有任何影响。根据@Retention的配置：\n\n * SOURCE类型的注解在编译期就被丢掉了；\n * CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；\n * RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。\n\n如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。\n\n因此，我们只讨论如何读取RUNTIME类型的注解。\n\n因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。\n\n\n# 使用注解\n\n注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。\n\n我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Range {\n    int min() default 0;\n    int max() default 255;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在某个JavaBean中，我们可以使用该注解：\n\npublic class Person {\n    @Range(min=1, max=20)\n    public String name;\n\n    @Range(max=10)\n    public String city;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：\n\nvoid check(Person person) throws IllegalArgumentException, ReflectiveOperationException {\n    // 遍历所有Field:\n    for (Field field : person.getClass().getFields()) {\n        // 获取Field定义的@Range:\n        Range range = field.getAnnotation(Range.class);\n        // 如果@Range存在:\n        if (range != null) {\n            // 获取Field的值:\n            Object value = field.get(person);\n            // 如果值是String:\n            if (value instanceof String) {\n                String s = (String) value;\n                // 判断值是否满足@Range的min/max:\n                if (s.length() < range.min() || s.length() > range.max()) {\n                    throw new IllegalArgumentException("Invalid field: " + field.getName());\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。\n\n\n# 泛型\n\n泛型就是定义一种模板，例如ArrayList，然后在代码中为用到的类创建对应的ArrayList<类型>：\n\nArrayList<String> strList = new ArrayList<String>();\n\n\n1\n\n\n要特别注意：不能把ArrayList向上转型为ArrayList或List。\n\n\n# 擦拭法\n\nJava语言的泛型实现方式是擦拭法（Type Erasure）。\n\n所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。\n\nJava使用擦拭法实现泛型，导致了：\n\n * 编译器把类型<T>视为Object；\n * 编译器根据<T>实现安全的强制转型。\n\n使用泛型的时候，我们编写的代码也是编译器看到的代码：\n\nPair<String> p = new Pair<>("Hello", "world");\nString first = p.getFirst();\nString last = p.getLast();\n\n\n1\n2\n3\n\n\n而虚拟机执行的代码并没有泛型：\n\nPair p = new Pair("Hello", "world");\nString first = (String) p.getFirst();\nString last = (String) p.getLast();\n\n\n1\n2\n3\n\n\n所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。\n\n擦拭法决定了泛型<T>：\n\n * 不能是基本类型，例如：int；\n * 不能获取带泛型类型的Class，例如：Pair.class；\n * 不能判断带泛型类型的类型，例如：x instanceof Pair；\n * 不能实例化T类型，例如：new T()。\n\n泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；\n\n子类可以获取父类的泛型类型<T>。\n\n\n# extends通配符\n\npublic class Main {  \n\tpublic static void main(String[] args) {\n    Pair<Integer> p = new Pair<>(123, 456);\n    int n = add(p);\n    System.out.println(n);\n  }\n\n  static int add(Pair<? extends Number> p) { // 设置extends通配符，Pari<Integer>类型可传入Pair<Number>\n    Number first = p.getFirst();\n    Number last = p.getLast();\n    return first.intValue() + last.intValue();\n  }\n}\nclass Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这样一来，给方法传入Pair<Integer>类型时，它符合参数Pair<? extends Number>类型。这种使用<? extends Number>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。\n\n除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，因为Double和BigDecimal都是Number的子类。\n\n使用类似Pair<? extends Number>通配符作为方法参数时表示：\n\n * 方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();；\n * 方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。\n\n即一句话总结：使用extends通配符表示可以读，不能写。\n\n使用类似<T extends Number>定义泛型类时表示：\n\n * 泛型类型限定为Number以及Number的子类。\n\n\n# super通配符\n\nvoid set(Pair<? super Integer> p, Integer first, Integer last) {\n    p.setFirst(first);\n    p.setLast(last);\n}\n\n\n1\n2\n3\n4\n\n\n注意到Pair<? super Integer>表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。\n\n使用Pair<? super Integer>通配符表示：\n\n * 允许调用set(? super Integer)方法传入Integer的引用；\n * 不允许调用get()方法获得Integer的引用。\n\n唯一例外是可以获取Object的引用：Object o = p.getFirst()。\n\n换句话说，使用super通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。\n\n\n# PESC原则\n\n何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。\n\n即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。\n\n\n# 无限定通配符\n\n我们已经讨论了<? extends T>和<? super T>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?：\n\nvoid sample(Pair<?> p) {\n}\n\n\n1\n2\n\n\n因为<?>通配符既没有extends，也没有super，因此：\n\n * 不允许调用set(T)方法并传入引用（null除外）；\n * 不允许调用T get()方法并获取T引用（只能获取Object引用）。\n\n换句话说，既不能读，也不能写，那只能做一些null判断：\n\nstatic boolean isNull(Pair<?> p) {\n    return p.getFirst() == null || p.getLast() == null;\n}\n\n\n1\n2\n3\n\n\n大多数情况下，可以引入泛型参数<T>消除<?>通配符：\n\nstatic <T> boolean isNull(Pair<T> p) {\n    return p.getFirst() == null || p.getLast() == null;\n}\n\n\n1\n2\n3\n\n\n<?>通配符有一个独特的特点，就是：Pair<?>是所有Pair<T>的超类。\n\n\n# 泛型和反射\n\n部分反射API是泛型，例如：Class，Constructor；\n\n可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；\n\n可以通过Array.newInstance(Class, int)创建T[]数组，需要强制转型；\n\n同时使用泛型和可变参数时需要特别小心。\n\n\n# 集合\n\n\n# Java集合简介\n\n在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。\n\nJava标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：\n\n * List：一种有序列表的集合，例如，按索引排列的Student的List；\n * Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；\n * Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。\n\n\n\n\n最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。\n\n由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：\n\n * Hashtable：一种线程安全的Map实现；\n * Vector：一种线程安全的List实现；\n * Stack：基于Vector实现的LIFO的栈。\n\n还有一小部分接口是遗留接口，也不应该继续使用：\n\n * Enumeration：已被Iterator取代。\n\n\n# List\n\n\n# List和Array互转\n\nimport java.util.List;\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = List.of(12, 34, 56);\n      \t//list转array\n        Number[] array = list.toArray(new Number[list.size()]);\n      \t//array转list\n      \tList<Number> list = List.of(array);\n        for (Number n : array) {\n            System.out.println(n);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# HashMap（基于jdk 1.8和jdk 1.7）\n\nHashMap这个笔记有点多，我专门整理成一个专题，可以去看hashmap详解专题\n\n\n# Java多线程与高并发\n\n详细内容见多线程和高并发。\n\n\n# IO\n\n\n# IO简介\n\nIO是指Input/Output，即输入和输出。以内存为中心：\n\n * Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。\n * Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。\n\n\n# InputStream / OutputStream\n\nIO流以byte（字节）为最小单位，因此也称为字节流。\n\n在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流。\n\n\n# Reader / Writer\n\n如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。\n\nJava提供了Reader和Writer表示字符流，字符流传输的最小数据单位是char。\n\n例如，我们把char[]数组Hi你好这4个字符用Writer字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符H和i各占一个字节，中文字符你好各占3个字节。\n\n使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。\n\n\n# 同步和异步\n\n同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。\n\n而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。\n\nJava标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。\n\n\n# 小结\n\nIO流是一种流式的数据输入/输出模型：\n\n * 二进制数据以byte为最小单位在InputStream/OutputStream中单向流动；\n * 字符数据以char为最小单位在Reader/Writer中单向流动。\n\nJava标准库的java.io包提供了同步IO功能：\n\n * 字节流接口：InputStream/OutputStream；\n * 字符流接口：Reader/Writer。\n\n\n# File对象\n\n在计算机系统中，文件是非常重要的存储方式。Java的标准库java.io提供了File对象来操作文件和目录。\n\nFile对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。\n\nJava标准库的java.io.File对象表示一个文件或者目录：\n\n * 创建File对象本身不涉及IO操作；\n * 可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()；\n * 可以获取目录的文件和子目录：list()/listFiles()；\n * 可以创建或删除文件和目录。\n\n\n# InputStream\n\nInputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。\n\n要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：\n\npublic abstract int read() throws IOException;\n\n\n1\n\n\n这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。\n\nFileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。下面的代码演示了如何完整地读取一个FileInputStream的所有字节：\n\npublic void readFile() throws IOException {\n    // 创建一个FileInputStream对象:\n    InputStream input = new FileInputStream("src/readme.txt");\n    for (;;) {\n        int n = input.read(); // 反复调用read()方法，直到返回-1\n        if (n == -1) {\n            break;\n        }\n        System.out.println(n); // 打印byte的值\n    }\n    input.close(); // 关闭流\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。\n\nInputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。\n\n\n# 缓冲\n\n在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节：\n\n * int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数\n * int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数\n\n利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。\n\n利用缓冲区一次读取多个字节的代码如下：\n\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream("src/readme.txt")) {\n        // 定义1000个字节大小的缓冲区:\n        byte[] buffer = new byte[1000];\n        int n;\n        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区\n            System.out.println("read " + n + " bytes.");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 阻塞\n\n在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的。它的意思是，对于下面的代码：\n\nint n;\nn = input.read(); // 必须等待read()方法返回才能执行下一行代码\nint m = n;\n\n\n1\n2\n3\n\n\n执行到第二行代码时，必须等read()方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。\n\n\n# 小结\n\nJava标准库的java.io.InputStream定义了所有输入流的超类：\n\n * FileInputStream实现了文件流输入；\n * ByteArrayInputStream在内存中模拟一个字节流输入。\n\n总是使用try(resource)来保证InputStream正确关闭。\n\n\n# OutputStream\n\n和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。\n\n和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：\n\npublic abstract void write(int b) throws IOException;\n\n\n1\n\n\n这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b & 0xff）。\n\n和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。\n\n为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。\n\n通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。\n\n但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：\n\n小明正在开发一款在线聊天软件，当用户输入一句话后，就通过OutputStream的write()方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？\n\n原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。\n\n解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。\n\n实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。\n\n\n# FileOutputStream\n\n我们以FileOutputStream为例，演示如何将若干个字节写入文件流：\n\npublic void writeFile() throws IOException {\n    OutputStream output = new FileOutputStream("out/readme.txt");\n    output.write(72); // H\n    output.write(101); // e\n    output.write(108); // l\n    output.write(108); // l\n    output.write(111); // o\n    output.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用OutputStream提供的重载方法void write(byte[])来实现：\n\npublic void writeFile() throws IOException {\n    OutputStream output = new FileOutputStream("out/readme.txt");\n    output.write("Hello".getBytes("UTF-8")); // Hello\n    output.close();\n}\n\n\n1\n2\n3\n4\n5\n\n\n和InputStream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证OutputStream在无论是否发生IO错误的时候都能够正确地关闭：\n\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream("out/readme.txt")) {\n        output.write("Hello".getBytes("UTF-8")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 阻塞\n\n和InputStream一样，OutputStream的write()方法也是阻塞的。\n\n\n# OutputStream实现类\n\n用FileOutputStream可以从文件获取输出流，这是OutputStream常用的一个实现类。此外，ByteArrayOutputStream可以在内存中模拟一个OutputStream：\n\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data;\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            output.write("Hello ".getBytes("UTF-8"));\n            output.write("world!".getBytes("UTF-8"));\n            data = output.toByteArray();\n        }\n        System.out.println(new String(data, "UTF-8"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个OutputStream。\n\n\n# 小结\n\nJava标准库的java.io.OutputStream定义了所有输出流的超类：\n\n * FileOutputStream实现了文件流输出；\n * ByteArrayOutputStream在内存中模拟一个字节流输出。\n\n某些情况下需要手动调用OutputStream的flush()方法来强制输出缓冲区。\n\n总是使用try(resource)来保证OutputStream正确关闭。\n\n\n# 序列化\n\n序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。\n\n为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。\n\n有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。\n\n我们来看看如何把一个Java对象序列化。\n\n一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下：\n\npublic interface Serializable {\n}\n\n\n1\n2\n\n\nSerializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。\n\n\n# 序列化\n\n把一个Java对象变为byte[]数组，需要使用ObjectOutputStream。它负责把一个Java对象写入一个字节流：\n\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {\n            // 写入int:\n            output.writeInt(12345);\n            // 写入String:\n            output.writeUTF("Hello");\n            // 写入Object:\n            output.writeObject(Double.valueOf(123.456));\n        }\n        System.out.println(Arrays.toString(buffer.toByteArray()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nObjectOutputStream既可以写入基本类型，如int，boolean，也可以写入String（以UTF-8编码），还可以写入实现了Serializable接口的Object。\n\n因为写入Object时需要大量的类型信息，所以写入的内容很大。\n\n\n# 反序列化\n\n和ObjectOutputStream相反，ObjectInputStream负责从一个字节流读取Java对象：\n\ntry (ObjectInputStream input = new ObjectInputStream(...)) {\n    int n = input.readInt();\n    String s = input.readUTF();\n    Double d = (Double) input.readObject();\n}\n\n\n1\n2\n3\n4\n5\n\n\n除了能读取基本类型和String类型外，调用readObject()可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。\n\nreadObject()可能抛出的异常有：\n\n * ClassNotFoundException：没有找到对应的Class；\n * InvalidClassException：Class不匹配。\n\n对于ClassNotFoundException，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。\n\n对于InvalidClassException，这种情况常见于序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。\n\n为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本：\n\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 2709425275741743919L;\n}\n\n\n1\n2\n3\n\n\n要特别注意反序列化的几个重要特点：\n\n反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。\n\n\n# 安全性\n\n因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。\n\n实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。\n\n\n# 小结\n\n可序列化的Java对象必须实现java.io.Serializable接口，类似Serializable这样的空接口被称为“标记接口”（Marker Interface）；\n\n反序列化时不调用构造方法，可设置serialVersionUID作为版本号（非必需）；\n\nJava的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。\n\n\n# Reader\n\nReader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取：\n\nINPUTSTREAM                 READER\n字节流，以byte为单位                字符流，以char为单位\n读取字节（-1，0~255）：int read()   读取字符（-1，0~65535）：int read()\n读到字节数组：int read(byte[] b)   读到字符数组：int read(char[] c)\n\njava.io.Reader是所有字符输入流的超类，它最主要的方法是：\n\npublic int read() throws IOException;\n\n\n1\n\n\n这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。\n\n\n# FileReader\n\nFileReader是Reader的一个子类，它可以打开文件并获取Reader。下面的代码演示了如何完整地读取一个FileReader的所有字符：\n\npublic void readFile() throws IOException {\n    // 创建一个FileReader对象:\n    Reader reader = new FileReader("src/readme.txt"); // 字符编码是???\n    for (;;) {\n        int n = reader.read(); // 反复调用read()方法，直到返回-1\n        if (n == -1) {\n            break;\n        }\n        System.out.println((char)n); // 打印char\n    }\n    reader.close(); // 关闭流\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为FileReader默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。\n\n要避免乱码问题，我们需要在创建FileReader时指定编码：\n\nReader reader = new FileReader("src/readme.txt", StandardCharsets.UTF_8);\n\n\n1\n\n\n和InputStream类似，Reader也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用try (resource)来保证Reader在无论有没有IO错误的时候都能够正确地关闭：\n\ntry (Reader reader = new FileReader("src/readme.txt", StandardCharsets.UTF_8) {\n    // TODO\n}\n\n\n1\n2\n3\n\n\nReader还提供了一次性读取若干字符并填充到char[]数组的方法：\n\npublic int read(char[] c) throws IOException\n\n\n1\n\n\n它返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。\n\n利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：\n\npublic void readFile() throws IOException {\n    try (Reader reader = new FileReader("src/readme.txt", StandardCharsets.UTF_8)) {\n        char[] buffer = new char[1000];\n        int n;\n        while ((n = reader.read(buffer)) != -1) {\n            System.out.println("read " + n + " chars.");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# CharArrayReader\n\nCharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader，这和ByteArrayInputStream非常类似：\n\ntry (Reader reader = new CharArrayReader("Hello".toCharArray())) {\n}\n\n\n1\n2\n\n\n\n# StringReader\n\nStringReader可以直接把String作为数据源，它和CharArrayReader几乎一样：\n\ntry (Reader reader = new StringReader("Hello")) {\n}\n\n\n1\n2\n\n\n\n# InputStreamReader\n\nReader和InputStream有什么关系？\n\n除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的，因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看FileReader的源码，它在内部实际上持有一个FileInputStream。\n\n既然Reader本质上是一个基于InputStream的byte到char的转换器，那么，如果我们已经有一个InputStream，想把它转换为Reader，是完全可行的。InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。示例代码如下：\n\n// 持有InputStream:\nInputStream input = new FileInputStream("src/readme.txt");\n// 变换为Reader:\nReader reader = new InputStreamReader(input, "UTF-8");\n\n\n1\n2\n3\n4\n\n\n构造InputStreamReader时，我们需要传入InputStream，还需要指定编码，就可以得到一个Reader对象。上述代码可以通过try (resource)更简洁地改写如下：\n\ntry (Reader reader = new InputStreamReader(new FileInputStream("src/readme.txt"), "UTF-8")) {\n    // TODO:\n}\n\n\n1\n2\n3\n\n\n上述代码实际上就是FileReader的一种实现方式。\n\n使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可。\n\n> 使用InputStreamReader，可以把一个InputStream转换成一个Reader。\n\n\n# 小结\n\nReader定义了所有字符输入流的超类：\n\n * FileReader实现了文件字符流输入，使用时需要指定编码；\n * CharArrayReader和StringReader可以在内存中模拟一个字符流输入。\n\nReader是基于InputStream构造的：可以通过InputStreamReader在指定编码的同时将任何InputStream转换为Reader。\n\n总是使用try (resource)保证Reader正确关闭。\n\n\n# Writer\n\nReader是带编码转换器的InputStream，它把byte转换为char，而Writer就是带编码转换器的OutputStream，它把char转换为byte并输出。\n\nWriter和OutputStream的区别如下：\n\nOUTPUTSTREAM                    WRITER\n字节流，以byte为单位                    字符流，以char为单位\n写入字节（0~255）：void write(int b)   写入字符（0~65535）：void write(int c)\n写入字节数组：void write(byte[] b)     写入字符数组：void write(char[] c)\n无对应方法                           写入String：void write(String s)\n\nWriter是所有字符输出流的超类，它提供的方法主要有：\n\n * 写入一个字符（0~65535）：void write(int c)；\n * 写入字符数组的所有字符：void write(char[] c)；\n * 写入String表示的所有字符：void write(String s)。\n\n\n# FileWriter\n\nFileWriter就是向文件中写入字符流的Writer。它的使用方法和FileReader类似：\n\ntry (Writer writer = new FileWriter("readme.txt", StandardCharsets.UTF_8)) {\n    writer.write(\'H\'); // 写入单个字符\n    writer.write("Hello".toCharArray()); // 写入char[]\n    writer.write("Hello"); // 写入String\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# CharArrayWriter\n\nCharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，这和ByteArrayOutputStream非常类似：\n\ntry (CharArrayWriter writer = new CharArrayWriter()) {\n    writer.write(65);\n    writer.write(66);\n    writer.write(67);\n    char[] data = writer.toCharArray(); // { \'A\', \'B\', \'C\' }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# StringWriter\n\nStringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口。\n\n\n# OutputStreamWriter\n\n除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器：\n\ntry (Writer writer = new OutputStreamWriter(new FileOutputStream("readme.txt"), "UTF-8")) {\n    // TODO:\n}\n\n\n1\n2\n3\n\n\n上述代码实际上就是FileWriter的一种实现方式。这和上一节的InputStreamReader是一样的。\n\n\n# 小结\n\nWriter定义了所有字符输出流的超类：\n\n * FileWriter实现了文件字符流输出；\n * CharArrayWriter和StringWriter在内存中模拟一个字符流输出。\n\n使用try (resource)保证Writer正确关闭。\n\nWriter是基于OutputStream构造的，可以通过OutputStreamWriter将OutputStream转换为Writer，转换时需要指定编码。\n\n\n# Files\n\n从Java 7开始，提供了Files和Paths这两个工具类，能极大地方便我们读写文件。\n\n虽然Files和Paths是java.nio包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个byte[]，可以这么写：\n\nbyte[] data = Files.readAllBytes(Paths.get("/path/to/file.txt"));\n\n\n1\n\n\n如果是文本文件，可以把一个文件的全部内容读取为String：\n\n// 默认使用UTF-8编码读取:\nString content1 = Files.readString(Paths.get("/path/to/file.txt"));\n// 可指定编码:\nString content2 = Files.readString(Paths.get("/path/to/file.txt"), StandardCharsets.ISO_8859_1);\n// 按行读取并返回每行内容:\nList<String> lines = Files.readAllLines(Paths.get("/path/to/file.txt"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n写入文件也非常方便：\n\n// 写入二进制文件:\nbyte[] data = ...\nFiles.write(Paths.get("/path/to/file.txt"), data);\n// 写入文本并指定编码:\nFiles.writeString(Paths.get("/path/to/file.txt"), "文本内容...", StandardCharsets.ISO_8859_1);\n// 按行写入文本:\nList<String> lines = ...\nFiles.write(Paths.get("/path/to/file.txt"), lines);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，Files工具类还有copy()、delete()、exists()、move()等快捷方法操作文件和目录。\n\n最后需要特别注意的是，Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。\n\n\n# 小结\n\n对于简单的小文件读写操作，可以使用Files工具类简化代码。\n\n\n# 加密与安全\n\n在计算机系统中，什么是加密与安全呢？\n\n我们举个栗子：假设Bob要给Alice发一封邮件，在邮件传送的过程中，黑客可能会窃取到邮件的内容，所以需要防窃听。黑客还可能会篡改邮件的内容，Alice必须有能力识别出邮件有没有被篡改。最后，黑客可能假冒Bob给Alice发邮件，Alice必须有能力识别出伪造的邮件。\n\n所以，应对潜在的安全威胁，需要做到三防：\n\n * 防窃听\n * 防篡改\n * 防伪造\n\n\n# 常用设计模式\n\n详细设计模式见Notes\n\n\n# 工厂方法\n\n> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。\n\n工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。\n\n实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。\n\n调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。\n\n\n# 原型\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\n原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。\n\n\n# 单例\n\n> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。\n\npublic class Singleton {\n    // 静态字段引用唯一实例:\n    private static final Singleton INSTANCE = new Singleton();\n\n    // 通过静态方法返回实例:\n    public static Singleton getInstance() {\n        return INSTANCE;\n    }\n\n    // private构造方法保证外部无法实例化:\n    private Singleton() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 装饰器模式\n\n> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。\n\n装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。\n\n我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。\n\n顶层接口TextNode，写一个它的实现类SpanNode，实现TextNode的一个抽象类NodeDecorator，并在抽象类中定义一个TextNode字段，再去实现这个NodeDecorator类，就是装饰者模式。\n\n\n# 代理模式\n\n代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。\n\n使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。\n\n\n# 策略模式\n\n策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。\n\n通过扩展策略，不必修改主逻辑，即可获得新策略的结果。\n\n\n# 模板方法\n\n> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。',normalizedContent:'# java快速入门\n\n\n# java程序基础\n\n\n# jvm、jdk和jre\n\n * jvm：java virtual machine\n * jdk：java development kit\n * jre：java runtime environment\n\njava虚拟机（jvm）是运行 java 字节码的虚拟机。jvm有针对不同系统的特定实现（windows，linux，macos），目的是使用相同的字节码，它们都会给出相同的结果。\n\njdk是java development kit，它是功能齐全的java sdk。它拥有jre所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。\n\njre 是 java运行时环境。它是运行已编译 java 程序所需的所有内容的集合，包括 java虚拟机（jvm），java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n简单地说，jre就是运行java字节码的虚拟机。但是，如果只有java源码，要编译成java字节码，就需要jdk，因为jdk除了包含jre，还提供了编译器、调试器等开发工具。\n\n\n\n我们需要格外注意的是 .class->机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 jit 编译器，而jit 属于运行时编译。当 jit 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 java 解释器的。这也解释了我们为什么经常会说 java 是编译与解释共存的语言。\n\n\n# 基本数据类型\n\n * 整数类型：byte，short，int，long\n * 浮点数类型：float，double\n * 字符类型：char\n * 布尔类型：boolean\n\n计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。\n\njava基本数据类型占用的字节数：\n\nboolean 占1个字节\n\n       ┌───┐\n  byte │   │\n       └───┘\n       ┌───┬───┐\n short │   │   │\n       └───┴───┘\n       ┌───┬───┬───┬───┐\n   int │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\n  long │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┬───┬───┐\n float │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\ndouble │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┐\n  char │   │   │\n       └───┴───┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 常量\n\n定义变量的时候，如果加上final修饰符，这个变量就变成了常量：\n\nfinal double pi = 3.14; // pi是一个常量\n\n\n1\n\n\n常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写。\n\n\n# var关键字\n\n如果想省略变量类型，可以使用var关键字：\n\nvar sb = new stringbuilder();\n\n\n1\n\n\n编译器会根据赋值语句自动推断出变量sb的类型是stringbuilder。对编译器来说，语句：\n\nvar sb = new stringbuilder();\n\n\n1\n\n\n实际上会自动变成：\n\nstringbuilder sb = new stringbuilder();\n\n\n1\n\n\n因此，使用var定义变量，仅仅是少写了变量类型而已。\n\n\n# 位运算\n\n位运算是按位进行与、或、非和异或的运算。\n\n与运算的规则是，必须两个数同时为1，结果才为1。\n\n或运算的规则是，只要任意一个为1，结果就为1。\n\n非运算的规则是，0和1互换。\n\n异或运算的规则是，如果两个数不同，结果为1，否则为0。\n\n\n# 运算优先级\n\n在java的计算表达式中，运算优先级从高到低依次是：\n\n * ()\n * ! ~ ++ --\n * * / %\n * + -\n * << >> >>>\n * &\n * |\n * += -= *= /=\n\n\n# 浮点数运算\n\n浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。\n\n由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：\n\n// 比较x和y是否相等，先计算其差的绝对值:\ndouble r = math.abs(x - y);\n// 再判断绝对值是否足够小:\nif (r < 0.00001) {\n    // 可以认为相等\n} else {\n    // 不相等\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：\n\n * nan表示not a number\n * infinity表示无穷大\n * -infinity表示负无穷大\n\n可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。\n\n\n# 数组操作\n\n\n# 数组\n\n数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；\n\n数组一旦创建后，大小就不可改变。\n\n\n# 面向对象编程\n\n\n# 面向对象基础\n\n\n# 可变参数\n\n可变参数用类型...定义，可变参数相当于数组类型：\n\nclass group {\n    private string[] names;\n\n    public void setnames(string... names) {\n        this.names = names;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngroup g = new group();\ng.setnames("xiao ming", "xiao hong", "xiao jun"); // 传入3个string\ng.setnames("xiao ming", "xiao hong"); // 传入2个string\ng.setnames("xiao ming"); // 传入1个string\ng.setnames(); // 传入0个string\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法重载\n\n方法名相同，但各自的参数不同，称为方法重载（overload）。\n\n注意：方法重载的返回值类型通常都是相同的。\n\n\n# 继承\n\n# super\n\nsuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldname。例如：\n\nclass person {\n    private string name;\n    private int age;\n\n    public string getname() {...}\n    public void setname(string name) {...}\n    public int getage() {...}\n    public void setage(int age) {...}\n}\n\nclass student extends person {\n    public string hello() {\n        return "hello, " + super.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 向上转型\n\n如果一个引用变量的类型是student，那么它可以指向一个student类型的实例：\n\nstudent s = new student();\n\n\n1\n\n\n如果一个引用类型的变量是person，那么它可以指向一个person类型的实例：\n\nperson p = new person();\n\n\n1\n\n\n现在问题来了：如果student是从person继承下来的，那么，一个引用类型为person的变量，能否指向student类型的实例？\n\nperson p = new student(); // ???\n\n\n1\n\n\n测试一下就可以发现，这种指向是允许的！\n\n这是因为student继承自person，因此，它拥有person的全部功能。person类型的变量，如果指向student类型的实例，对它进行操作，是没有问题的！\n\n这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。\n\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型：\n\nstudent s = new student();\nperson p = s; // upcasting, ok\nobject o1 = p; // upcasting, ok\nobject o2 = s; // upcasting, ok\n\n\n1\n2\n3\n4\n\n\n注意到继承树是student > person > object，所以，可以把student类型转型为person，或者更高层次的object。\n\n# 向下转型\n\n和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：\n\nperson p1 = new student(); // upcasting, ok\nperson p2 = new person();\nstudent s1 = (student) p1; // ok\nstudent s2 = (student) p2; // runtime error! classcastexception!\n\n\n1\n2\n3\n4\n\n\n如果测试上面的代码，可以发现：\n\nperson类型p1实际指向student实例，person类型变量p2实际指向person实例。在向下转型的时候，把p1转型为student会成功，因为p1确实指向student实例，把p2转型为student会失败，因为p2的实际类型是person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。\n\n向下转型时最好先用instanceof判断一下，避免转型失败。\n\n\n# 多态\n\n在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（override）。\n\noverride和overload不同的是，如果方法签名如果不同，就是overload，overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是override。\n\n多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：\n\nperson p = new student();\np.run(); // 无法确定运行时究竟调用哪个run()方法\n\n\n1\n2\n\n\n有童鞋会问，从上面的代码一看就明白，肯定调用的是student的run()方法啊。\n\n但是，假设我们编写这样一个方法：\n\npublic void runtwice(person p) {\n    p.run();\n    p.run();\n}\n\n\n1\n2\n3\n4\n\n\n它传入的参数类型是person，我们是无法知道传入的参数实际类型究竟是person，还是student，还是person的其他子类，因此，也无法确定调用的是不是person类定义的run()方法。\n\n多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。\n\n\n# final\n\n继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被override。\n\n如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承。\n\n对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。\n\n\n# transient\n\n我们都知道一个对象只要实现了serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了serilizable接口，这个类的所有属性和方法都会自动序列化。\n\n然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。\n\n * 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。\n\n * transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现serializable接口。\n\n * 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。\n\n\n# 抽象类\n\n如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：\n\nclass person {\n    public abstract void run();\n}\n\n\n1\n2\n3\n\n\n把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，person类也无法被实例化。编译器会告诉我们，无法编译person类，因为它包含抽象方法。\n\n必须把person类本身也声明为abstract，才能正确编译它：\n\nabstract class person {\n    public abstract void run();\n}\n\n\n1\n2\n3\n\n\n使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类。\n\n无法实例化的抽象类有什么用？\n\n因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。\n\n\n# 面向抽象编程\n\n当我们定义了抽象类person，以及具体的student、teacher子类的时候，我们可以通过抽象类person类型去引用具体的子类的实例：\n\nperson s = new student();\nperson t = new teacher();\n\n\n1\n2\n\n\n这种引用抽象类的好处在于，我们对其进行方法调用，并不关心person类型变量的具体子类型：\n\n// 不关心person变量的具体子类型:\ns.run();\nt.run();\n\n\n1\n2\n3\n\n\n同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：\n\n// 同样不关心新的子类是如何实现run()方法的：\nperson e = new employee();\ne.run();\n\n\n1\n2\n3\n\n\n这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。\n\n面向抽象编程的本质就是：\n\n * 上层代码只定义规范（例如：abstract class person）；\n * 不需要子类就可以实现业务逻辑（正常编译）；\n * 具体的业务逻辑由不同的子类实现，调用者并不关心。\n\n\n# 接口\n\n在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。\n\n如果一个抽象类没有字段，所有方法全部都是抽象方法：\n\nabstract class person {\n    public abstract void run();\n    public abstract string getname();\n}\n\n\n1\n2\n3\n4\n\n\n就可以把该抽象类改写为接口：interface。\n\n在java中，使用interface可以声明一个接口：\n\ninterface person {\n    void run();\n    string getname();\n}\n\n\n1\n2\n3\n4\n\n\n所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。\n\n当一个具体的class去实现一个interface时，需要使用implements关键字。\n\n我们知道，在java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。\n\n抽象类和接口的对比如下：\n\n        abstract class     interface\n继承      只能extends一个class   可以implements多个interface\n字段      可以定义实例字段           不能定义实例字段\n抽象方法    可以定义抽象方法           可以定义抽象方法\n非抽象方法   可以定义非抽象方法          可以定义default方法\n\n# 接口继承\n\n一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如：\n\ninterface hello {\n    void hello();\n}\n\ninterface person extends hello {\n    void run();\n    string getname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此时，person接口继承自hello接口，因此，person接口现在实际上有3个抽象方法签名，其中一个来自继承的hello接口。\n\n# 继承关系\n\n合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考java的集合类定义的一组接口、抽象类以及具体子类的继承关系：\n\n┌───────────────┐\n│   iterable    │\t\t\n└───────────────┘\n        ▲                ┌───────────────────┐\n        │                │      object       │\n┌───────────────┐        └───────────────────┘\n│  collection   │                  ▲\n└───────────────┘                  │\n        ▲     ▲          ┌───────────────────┐\n        │     └──────────│abstractcollection │\n┌───────────────┐        └───────────────────┘\n│     list      │                  ▲\n└───────────────┘                  │\n              ▲          ┌───────────────────┐\n              └──────────│   abstractlist    │\n                         └───────────────────┘\n                                ▲     ▲\n                                │     │\n                                │     │\n                     ┌────────────┐ ┌────────────┐\n                     │ arraylist  │ │ linkedlist │\n                     └────────────┘ └────────────┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：\n\nlist list = new arraylist(); // 用list接口引用具体子类的实例\ncollection coll = list; // 向上转型为collection接口\niterable it = coll; // 向上转型为iterable接口\n\n\n1\n2\n3\n\n\n# default方法\n\n接口可以定义default方法（jdk>=1.8）。\n\n在接口中，可以定义default方法。例如，把person接口的run()方法改为default方法：\n\npublic class main {\n    public static void main(string[] args) {\n        person p = new student("xiao ming");\n        p.run();\n    }\n}\n\ninterface person {\n    string getname();\n    default void run() {\n        system.out.println(getname() + " run");\n    }\n}\n\nclass student implements person {\n    private string name;\n\n    public student(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。\n\ndefault方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。\n\n\n# 静态字段和静态方法\n\n# 静态字段\n\n在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。\n\n还有一种字段，是用static修饰的字段，称为静态字段：static field。\n\n静态字段只有一个共享“空间”，所有实例都会共享该字段。\n\n虽然实例可以访问静态字段，但是它们指向的其实都是person class的静态字段。所以，所有实例共享一个静态字段。\n\n因此，不推荐用实例变量.静态字段去访问静态字段，因为在java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。\n\n推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。\n\n# 静态方法\n\n用static修饰的方法称为静态方法。\n\n因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。\n\n静态方法经常用于工具类。例如：\n\n * arrays.sort()\n * math.random()\n\n# 接口的静态字段\n\n因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型：\n\npublic interface person {\n    public static final int male = 1;\n    public static final int female = 2;\n}\n\n\n1\n2\n3\n4\n\n\n实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：\n\npublic interface person {\n    // 编译器会自动加上public statc final:\n    int male = 1;\n    int female = 2;\n}\n\n\n1\n2\n3\n4\n5\n\n\n编译器会自动把该字段变为public static final类型。\n\n\n# 包\n\n# 包的定义\n\n在现实中，如果小明写了一个person类，小红也写了一个person类，现在，小白既想用小明的person，也想用小红的person，怎么办？\n\n在java中，我们使用package来解决名字冲突。\n\njava定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如person）只是一个简写，真正的完整类名是包名.类名。\n\n包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。\n\n# 包作用域\n\n位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，person类定义在hello包下面：\n\npackage hello;\n\npublic class person {\n    // 包作用域:\n    void hello() {\n        system.out.println("hello!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nmain类也定义在hello包下面：\n\npackage hello;\n\npublic class main {\n    public static void main(string[] args) {\n        person p = new person();\n        p.hello(); // 可以调用，因为main和person在同一个包\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法：\n\npackage main;\n\n// 导入system类的所有静态字段和静态方法:\nimport static java.lang.system.*;\n\npublic class main {\n    public static void main(string[] args) {\n        // 相当于调用system.out.println(…)\n        out.println("hello, world!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\njava编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：\n\n * 如果是完整类名，就直接根据完整类名查找这个class；\n * 如果是简单类名，按下面的顺序依次查找：\n   * 查找当前package是否存在这个class；\n   * 查找import的包是否包含这个class；\n   * 查找java.lang包是否包含这个class。\n\n编写class的时候，编译器会自动帮我们做两个import动作：\n\n * 默认自动import当前package的其他class；\n * 默认自动import java.lang.*。\n\n*在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）。\n\n\n# 作用域\n\npublic、protected、private这些修饰符可以用来限定访问作用域。\n\n# public\n\n定义为public的class、interface可以被其他任何类访问。\n\n定义为public的field、method可以被其他类访问，前提是首先有访问class的权限。\n\n# private\n\n定义为private的field、method无法被其他类访问。\n\n实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。\n\n定义在一个class内部的class称为嵌套类（nested class），java支持好几种嵌套类。\n\n由于java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问该类private的权限。\n\n# protected\n\nprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类。\n\n# package\n\n包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。\n\n只要在同一个包，就可以访问package权限的class、field和method。\n\n注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。\n\n# 局部变量\n\n在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。\n\n使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。\n\n# final\n\njava还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。\n\n * 用final修饰class可以阻止被继承；\n * 用final修饰method可以阻止被子类覆写；\n * 用final修饰field可以阻止被重新赋值；\n * 用final修饰局部变量可以阻止被重新赋值。\n\n# 最佳实践\n\n如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。\n\n把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。\n\n一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。\n\n\n# classpath和jar\n\n# classpath\n\nclasspath是jvm用到的一个环境变量，它用来指示jvm如何搜索class。\n\n因为java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被jvm执行的字节码。因此，jvm需要知道，如果要加载一个abc.xyz.hello的类，应该去哪搜索对应的hello.class文件。\n\n# jar包\n\n如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。\n\njar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。\n\njar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath。\n\n\n# 模块\n\n从java 9开始，jdk又引入了模块（module）。\n\njar只是用于存放class的容器，它并不关心class之间的依赖。\n\n从java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。\n\n# 打包jre\n\n过去发布一个java应用程序，要运行它，必须下载一个完整的jre，再运行jar包。而完整的jre块头很大，有100多m。怎么给jre瘦身呢？\n\n现在，jre自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。\n\n# 访问权限\n\n前面我们讲过，java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。\n\n确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。\n\n举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.xmlconstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出：\n\nmodule java.xml {\n    exports java.xml;\n    exports javax.xml.catalog;\n    exports javax.xml.datatype;\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有它声明的导出的包，外部代码才被允许访问。因此，模块进一步隔离了代码的访问权限。\n\n廖雪峰关于模块的讲解\n\n\n# java核心类\n\n\n# 字符串和编码\n\n# string\n\n在java中，string是一个引用类型，它本身也是一个class。\n\n实际上字符串在string内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：\n\nstring s2 = new string(new char[] {\'h\', \'e\', \'l\', \'l\', \'o\', \'!\'});\n\n\n1\n\n\njava字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。\n\n# 字符串比较\n\n当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。\n\npublic class main {\n    public static void main(string[] args) {\n        string s1 = "hello";\n        string s2 = "hello".tolowercase();\n        system.out.println(s1 == s2);\n        system.out.println(s1.equals(s2));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。\n\n两个字符串比较，必须总是使用equals()方法。\n\n要忽略大小写比较，使用equalsignorecase()方法。\n\nstring类常用的方法：\n\n// 是否包含子串:\n"hello".contains("ll"); // true\n"hello".indexof("l"); // 2\n"hello".lastindexof("l"); // 3\n"hello".startswith("he"); // true\n"hello".endswith("lo"); // true\n"hello".substring(2); // "llo"\n"hello".substring(2, 4); "ll"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n：\n\n"  \\thello\\r\\n ".trim(); // "hello"\n\n\n1\n\n\n注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。\n\n另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除：\n\n"\\u3000hello\\u3000".strip(); // "hello"\n" hello ".stripleading(); // "hello "\n" hello ".striptrailing(); // " hello"\n\n\n1\n2\n3\n\n\nstring还提供了isempty()和isblank()来判断字符串是否为空和空白字符串：\n\n"".isempty(); // true，因为字符串长度为0\n"  ".isempty(); // false，因为字符串长度不为0\n"  \\n".isblank(); // true，因为只包含空白字符\n" hello ".isblank(); // false，因为包含非空白字符\n\nstring s = "hello";\ns.replace(\'l\', \'w\'); // "hewwo"，所有字符\'l\'被替换为\'w\'\ns.replace("ll", "~~"); // "he~~o"，所有子串"ll"被替换为"~~"\n\nstring s = "a,,b;c ,d";\ns.replaceall("[\\\\,\\\\;\\\\s]+", ","); // "a,b,c,d"\n\nstring s = "a,b,c,d";\nstring[] ss = s.split("\\\\,"); // {"a", "b", "c", "d"}\n\nstring[] arr = {"a", "b", "c"};\nstring s = string.join("***", arr); // "a***b***c"\n\nstring.valueof(123); // "123"\nstring.valueof(45.67); // "45.67"\nstring.valueof(true); // "true"\n\ninteger.getinteger("java.version"); // 版本号，11\n\nchar[] cs = "hello".tochararray(); // string -> char[]\nstring s = new string(cs); // char[] -> string\n//通过new string(char[])创建新的string实例时，它并不会直接引用传入的char[]数组，而是会复制一份\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 字符编码\n\n在早期的计算机系统中，为了给字符编码，美国国家标准学会（american national standard institute：ansi）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ascii编码。\n\n为了统一全球所有语言的编码，全球统一码联盟发布了unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。\n\n那我们经常使用的utf-8又是什么编码呢？因为英文字符的unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了utf-8编码，它是一种变长编码，用来把固定长度的unicode编码变成1～4字节的变长编码。\n\nutf-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为utf-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。\n\n在java中，char类型实际上就是两个字节的unicode编码。\n\njava的string和char在内存中总是以unicode编码表示。\n\n# 延伸阅读\n\n对于不同版本的jdk，string类在内存中有不同的优化方式。具体来说，早期jdk版本的string总是以char[]存储，它的定义如下：\n\npublic final class string {\n    private final char[] value;\n    private final int offset;\n    private final int count;\n}\n\n\n1\n2\n3\n4\n5\n\n\n而较新的jdk版本的string则以byte[]存储：如果string仅包含ascii字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的string通常仅包含ascii字符：\n\npublic final class string {\n    private final byte[] value;\n    private final byte coder; // 0 = latin1, 1 = utf16\n\n\n1\n2\n3\n\n\n对于使用者来说，string内部的优化不影响任何已有代码，因为它的public方法签名是不变的。\n\n\n# stringbuilder\n\njava编译器对string做了特殊处理，使得我们可以直接用+拼接字符串。\n\n虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响gc效率。\n\n为了能高效拼接字符串，java标准库提供了stringbuilder，它是一个可变对象，可以预分配缓冲区，这样，往stringbuilder中新增字符时，不会创建新的临时对象。\n\n你可能还听说过stringbuffer，这是java早期的一个stringbuilder的线程安全版本，它通过同步来保证多个线程操作stringbuffer也是安全的，但是同步会带来执行速度的下降。\n\nstringbuilder和stringbuffer接口完全相同，现在完全没有必要使用stringbuffer。\n\n# stringjoiner\n\n要高效拼接字符串，应该使用stringbuilder。\n\nimport java.util.stringjoiner;\n\npublic class main {\n    public static void main(string[] args) {\n        string[] names = {"bob", "alice", "grace"};\n      \t//结果用,分割，第二个参数是开头，第三个参数是结尾\n        var sj = new stringjoiner(", ", "hello ", "!");\n        for (string name : names) {\n            sj.add(name);\n        }\n        system.out.println(sj.tostring());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n那么stringjoiner内部是如何拼接字符串的呢？如果查看源码，可以发现，stringjoiner内部实际上就是使用了stringbuilder，所以拼接效率和stringbuilder几乎是一模一样的。\n\n# string.join()\n\nstring还提供了一个静态方法join()，这个方法在内部使用了stringjoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用string.join()更方便：\n\nstring[] names = {"bob", "alice", "grace"};\nvar s = string.join(", ", names);\n\n\n1\n2\n\n\n\n# 包装类型\n\n我们已经知道，java的数据类型分两种：\n\n * 基本类型：byte，short，int，long，boolean，float，double，char\n * 引用类型：所有class和interface类型\n\n注：string就是一个class。\n\n那么，如何把一个基本类型视为对象（引用类型）？\n\n比如，想要把int基本类型变成一个引用类型，我们可以定义一个integer类，它只包含一个实例字段int，这样，integer类就可以视为int的包装类（wrapper class）：\n\npublic class integer {\n    private int value;\n\n    public integer(int value) {\n        this.value = value;\n    }\n\n    public int intvalue() {\n        return this.value;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n实际上，因为包装类型非常有用，java核心库为每种基本类型都提供了对应的包装类型：\n\n基本类型      对应的引用类型\nboolean   java.lang.boolean\nbyte      java.lang.byte\nshort     java.lang.short\nint       java.lang.integer\nlong      java.lang.long\nfloat     java.lang.float\ndouble    java.lang.double\nchar      java.lang.character\n\n我们可以直接使用这些基本类型的包装类。\n\n# 自动装箱和自动拆箱\n\ninteger n = 100; // 编译器自动使用integer.valueof(int)\nint x = n; // 编译器自动使用integer.intvalue()\n\n\n1\n2\n\n\n这种直接把int变为integer的赋值写法，称为自动装箱（auto boxing），反过来，把integer变为int的赋值写法，称为自动拆箱（auto unboxing）。\n\n注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。\n\n装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报nullpointerexception。\n\n# 不变类\n\n所有的包装类型都是不变类。我们查看integer的源码可知，它的核心代码如下：\n\npublic final class integer {\n    private final int value;\n}\n\n\n1\n2\n3\n\n\n因此，一旦创建了integer对象，该对象就是不变的。\n\n对两个integer实例进行比较要特别注意：绝对不能用==比较，因为integer是引用类型，必须使用equals()比较。\n\n因为integer.valueof()可能始终返回同一个integer实例，因此，在我们自己创建integer的时候，以下两种方法：\n\n * 方法1：integer n = new integer(100);\n * 方法2：integer n = integer.valueof(100);\n\n方法2更好，因为方法1总是创建新的integer实例，方法2把内部优化留给integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。\n\n我们把能创建“新”对象的静态方法称为静态工厂方法。integer.valueof()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。\n\n# 进制转换\n\ninteger类本身还提供了大量方法，例如，最常用的静态方法parseint()可以把字符串解析成一个整数：\n\nint x1 = integer.parseint("100"); // 100\nint x2 = integer.parseint("100", 16); // 256,因为按16进制解析\n\nsystem.out.println(integer.tohexstring(100)); // "64",表示为16进制\nsystem.out.println(integer.tooctalstring(100)); // "144",表示为8进制\nsystem.out.println(integer.tobinarystring(100)); // "1100100",表示为2进制\n\n\n1\n2\n3\n4\n5\n6\n\n\njava的包装类型还定义了一些有用的静态变量\n\n// boolean只有两个值true/false，其包装类型只需要引用boolean提供的静态字段:\nboolean t = boolean.true;\nboolean f = boolean.false;\n// int可表示的最大/最小值:\nint max = integer.max_value; // 2147483647\nint min = integer.min_value; // -2147483648\n// long类型占用的bit和byte数量:\nint sizeoflong = long.size; // 64 (bits)\nint bytesoflong = long.bytes; // 8 (bytes)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# javabean\n\n如果读写方法符合以下这种命名规范：\n\n// 读方法:\npublic type getxyz()\n// 写方法:\npublic void setxyz(type value)\n\n\n1\n2\n3\n4\n\n\n那么这种class被称为javabean。\n\n# javabean的作用\n\njavabean主要用来传递数据，即把一组数据组合成一个javabean便于传输。此外，javabean可以方便地被ide工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。\n\n# 枚举javabean属性\n\n要枚举一个javabean的所有属性，可以直接使用java核心库提供的introspector。\n\nimport java.beans.*;\npublic class main {\n    public static void main(string[] args) throws exception {\n        beaninfo info = introspector.getbeaninfo(person.class);\n        for (propertydescriptor pd : info.getpropertydescriptors()) {\n            system.out.println(pd.getname());\n            system.out.println("  " + pd.getreadmethod());\n            system.out.println("  " + pd.getwritemethod());\n        }\n    }\n}\n\nclass person {\n    private string name;\n    private int age;\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 枚举类\n\nenum weekday {\n    sun, mon, tue, wed, thu, fri, sat;\n}\n\n\n\n1\n2\n3\n4\n\n\n注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。\n\n首先，enum常量本身带有类型信息，即weekday.sun类型是weekday，编译器会自动检查出类型错误。\n\n其次，不可能引用到非枚举的值，因为无法通过编译。\n\n引用类型比较，要始终使用equals()方法，但enum类型可以例外。\n\n这是因为enum类型的每个常量在jvm中只有一个唯一实例，所以可以直接用==比较。\n\n----------------------------------------\n\n通过enum定义的枚举类，和其他的class有什么区别？\n\n答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点：\n\n * 定义的enum类型总是继承自java.lang.enum，且无法被继承；\n * 只能定义出enum的实例，而无法通过new操作符创建enum的实例；\n * 定义的每个实例都是引用类型的唯一实例；\n * 可以将enum类型用于switch语句。\n\n通过name()获取常量定义的字符串，注意不要使用tostring()；\n\n通过ordinal()返回常量定义的顺序（无实质意义）；\n\n可以为enum编写构造方法、字段和方法\n\nenum的构造方法要声明为private，字段强烈建议声明为final；\n\nenum适合用在switch语句中。\n\n\n# biginteger\n\n在java中，由cpu原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过cpu指令进行计算，速度非常快。\n\n如果我们使用的整数范围超过了long型怎么办？java.math.biginteger就是用来表示任意大小的整数。biginteger内部用一个int[]数组来模拟一个非常大的整数。\n\n对biginteger做运算的时候，只能使用实例方法，例如，加法运算：\n\nbiginteger i1 = new biginteger("1234567890");\nbiginteger i2 = new biginteger("12345678901234567890");\nbiginteger sum = i1.add(i2); // 12345678902469135780\n\n\n1\n2\n3\n\n\nbiginteger和integer、long一样，也是不可变类，并且也继承自number类。因为number定义了转换为基本类型的几个方法：\n\n * 转换为byte：bytevalue()\n * 转换为short：shortvalue()\n * 转换为int：intvalue()\n * 转换为long：longvalue()\n * 转换为float：floatvalue()\n * 转换为double：doublevalue()\n\n\n# bigdecimal\n\n和biginteger类似，bigdecimal可以表示一个任意大小且精度完全准确的浮点数。\n\nbigdecimal bd = new bigdecimal("123.4567");\nsystem.out.println(bd.multiply(bd)); // 15241.55677489\n\n\n1\n2\n\n\nbigdecimal用scale()表示小数位数，例如：\n\nbigdecimal d1 = new bigdecimal("123.45");\nbigdecimal d2 = new bigdecimal("123.4500");\nbigdecimal d3 = new bigdecimal("1234500");\nsystem.out.println(d1.scale()); // 2,两位小数\nsystem.out.println(d2.scale()); // 4\nsystem.out.println(d3.scale()); // 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过bigdecimal的striptrailingzeros()方法，可以将一个bigdecimal格式化为一个相等的，但去掉了末尾0的bigdecimal。\n\n如果一个bigdecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。\n\n可以对一个bigdecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：\n\nimport java.math.bigdecimal;\nimport java.math.roundingmode;\n\npublic class main {\n    public static void main(string[] args) {\n        bigdecimal d1 = new bigdecimal("123.456789");\n        bigdecimal d2 = d1.setscale(4, roundingmode.half_up); // 四舍五入，123.4568\n        bigdecimal d3 = d1.setscale(4, roundingmode.down); // 直接截断，123.4567\n        system.out.println(d2);\n        system.out.println(d3);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对bigdecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断。\n\n还可以对bigdecimal做除法的同时求余数。\n\n# 比较bigdecimal\n\n在比较两个bigdecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个bigdecimal的值相等，还要求它们的scale()相等。\n\n必须使用compareto()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。\n\n如果查看bigdecimal的源码，可以发现，实际上一个bigdecimal是通过一个biginteger和一个scale来表示的，即biginteger表示一个完整的整数，而scale表示小数位数。\n\nbigdecimal也是从number继承的，也是不可变对象。\n\n\n# object类\n\nobject类中包含的方法：\n\npublic final native class<?> getclass();\npublic native int hashcode();\npublic boolean equals(object obj) {\n\treturn (this == obj);\n}\nprotected native object clone() throws clonenotsupportedexception;\npublic string tostring() {\n\treturn getclass().getname() + "@" + integer.tohexstring(hashcode());\n}\npublic final native void notify();\npublic final native void notifyall();\npublic final native void wait(long timeout) throws interruptedexception;\nprotected void finalize() throws throwable { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# int和integer的区别\n\n1、integer是int的包装类，int则是java的一种基本数据类型 2、integer变量必须实例化后才能使用，而int变量不需要 3、integer实际是对象的引用，当new一个integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 4、integer的默认值是null，int的默认值是0\n\n延伸： 关于integer和int的比较 1、由于integer变量实际上是对一个integer对象的引用，所以两个通过new生成的integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\n\ninteger i = new integer(100);\ninteger j = new integer(100);\nsystem.out.print(i == j); //false\n\n\n1\n2\n3\n\n\n2、integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）\n\ninteger i = new integer(100);\nint j = 100；\nsystem.out.print(i == j); //true\n\n\n1\n2\n3\n\n\n3、非new生成的integer变量和new integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128~127之间时，非new生成的integer变量指向的是java常量池中的对象，而new integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128~127之间时，非new生成integer变量时，java api中最终会按照new integer(i)进行处理（参考下面第4条），最终两个interger的地址同样是不相同的）\n\ninteger i = new integer(100);\ninteger j = 100;\nsystem.out.print(i == j); //false\n\n\n1\n2\n3\n\n\n4、对于两个非new生成的integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\n\ninteger i = 100;\ninteger j = 100;\nsystem.out.print(i == j); //true\ninteger i = 128;\ninteger j = 128;\nsystem.out.print(i == j); //false\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于第4条的原因： java在编译integer i = 100 ;时，会翻译成为integer i = integer.valueof(100)；，而java api中对integer类型的valueof的定义如下：\n\npublic static integer valueof(int i){\n    assert integercache.high >= 127;\n    if (i >= integercache.low && i <= integercache.high){\n        return integercache.cache[i + (-integercache.low)];\n    }\n    return new integer(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\njava对于-128到127之间的数，会进行缓存，integer i = 127时，会将127进行缓存，下次再写integer j = 127时，就会直接从缓存中取，就不会new了\n\n如果有错误的地方，还请指正。\n\n参考： http://blog.csdn.net/you23hai45/article/details/50734274 http://www.cnblogs.com/liuling/archive/2013/05/05/intandinteger.html\n\n\n# java string、stringbuffer 和 stringbuilder 的区别\n\n# string\n\nstring：字符串常量，字符串长度不可变。java 中 string 是 immutable（不可变）的。\n\nstring 类的包含如下定义：\n\n/** the value is used for character storage. */\nprivate final char value[];\n\n/** the offset is the first index of the storage that is used. */\nprivate final int offset;\n\n/** the count is the number of characters in the string. */\nprivate final int count;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用于存放字符的数组被声明为 final 的，因此只能赋值一次，不可再更改。\n\n# stringbuffer（jdk1.0）\n\nstringbuffer：字符串变量（synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 stringbuffer，如果想转成 string 类型，可以调用 stringbuffer 的 tostring() 方法。\n\njava.lang.stringbuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。\n\nstringbuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。\n\n * append 方法始终将这些字符添加到缓冲区的末端；\n * insert 方法则在指定的点添加字符。\n\n例如，如果 z 引用一个当前内容是 start 的字符串缓冲区对象，则此方法调用 z.append("le") 会使字符串缓冲区包含 startle ，而 z.insert(4, "le") 将更改字符串缓冲区，使之包含 starlet 。\n\n# stringbuilder（jdk5.0）\n\nstringbuilder：字符串变量（非线程安全）。在内部，stringbuilder 对象被当作是一个包含字符序列的变长数组。\n\njava.lang.stringbuilder 是一个可变的字符序列，是 jdk5.0 新增的。此类提供一个与 stringbuffer 兼容的 api，但不保证同步。该类被设计用作 stringbuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n\n其构造方法如下：\n\n构造方法                              描述\nstringbuilder()                   创建一个容量为16的stringbuilder对象（16个空元素）\nstringbuilder(charsequence cs)    创建一个包含cs的stringbuilder对象，末尾附加16个空元素\nstringbuilder(int initcapacity)   创建一个容量为initcapacity的stringbuilder对象\nstringbuilder(string s)           创建一个包含s的stringbuilder对象，末尾附加16个空元素\n\n在大部分情况下，stringbuilder > stringbuffer。这主要是由于前者不需要考虑线程安全。\n\n# 三者区别\n\nstring 类型和 stringbuffer 的主要性能区别：string 是不可变的对象, 因此在每次对 string 类型进行改变的时候，都会生成一个新的 string 对象，然后将指针指向新的 string 对象，所以经常改变内容的字符串最好不要用 string ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， jvm 的 gc 就会开始工作，性能就会降低。\n\n使用 stringbuffer 类时，每次都会对 stringbuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 stringbuffer ，特别是字符串对象经常改变的情况下。\n\n在某些特别情况下， string 对象的字符串拼接其实是被 java compiler 编译成了 stringbuffer 对象的拼接，所以这些时候 string 对象的速度并不会比 stringbuffer 对象慢，例如：\n\nstring s1 = “this is only a” + “ simple” + “ test”;\nstringbuffer sb = new stringbuilder(“this is only a”).append(“ simple”).append(“ test”);\n\n\n1\n2\n\n\n生成 string s1 对象的速度并不比 stringbuffer 慢。其实在 java compiler 里，自动做了如下转换：\n\njava compiler直接把上述第一条语句编译为：\n\nstring s1 = “this is only a simple test”;  \n\n\n1\n\n\n所以速度很快。但要注意的是，如果拼接的字符串来自另外的 string 对象的话，java compiler 就不会自动转换了，速度也就没那么快了，例如：\n\nstring s2 = “this is only a”;  \nstring s3 = “ simple”;  \nstring s4 = “ test”;  \nstring s1 = s2 + s3 + s4;  \n\n\n1\n2\n3\n4\n\n\n这时候，java compiler 会规规矩矩的按照原来的方式去做，string 的 concatenation（即+）操作利用了 stringbuilder（或stringbuffer）的append 方法实现，此时，对于上述情况，若 s2，s3，s4 采用 string 定义，拼接时需要额外创建一个 stringbuffer（或stringbuilder），之后将stringbuffer 转换为 string，若采用 stringbuffer（或stringbuilder），则不需额外创建 stringbuffer。\n\n# 使用策略\n\n * （1）基本原则：如果要操作少量的数据，用string ；单线程操作大量数据，用stringbuilder ；多线程操作大量数据，用stringbuffer。\n\n * （2）不要使用string类的"+"来进行频繁的拼接，因为那样的性能极差的，应该使用stringbuffer或stringbuilder类，这在java的优化上是一条比较重要的原则。例如：\n   \n   string result = "";\n   for (string s : hugearray) {\n       result = result + s;\n   }\n   \n   // 使用stringbuilder\n   stringbuilder sb = new stringbuilder();\n   for (string s : hugearray) {\n       sb.append(s);\n   }\n   string result = sb.tostring();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会创建一个string result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）。\n\n * （3）为了获得更好的性能，在构造 stringbuffer 或 stringbuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。\n\n * （4）stringbuilder 一般使用在方法内部来完成类似 + 功能，因为是线程不安全的，所以用完以后可以丢弃。stringbuffer 主要用在全局变量中。\n\n * （5）相同情况下使用 stringbuilder 相比使用 stringbuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 stringbuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用 stringbuilder；否则还是用 stringbuffer。\n\n\n# 常用工具类\n\n# math\n\n顾名思义，math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：\n\n求绝对值：\n\nmath.abs(-100); // 100\nmath.abs(-7.8); // 7.8\n\n\n1\n2\n\n\n取最大或最小值：\n\nmath.max(100, 99); // 100\nmath.min(1.2, 2.3); // 1.2\n\n\n1\n2\n\n\n计算xy次方：\n\nmath.pow(2, 10); // 2的10次方=1024\n\n\n1\n\n\n计算√x：\n\nmath.sqrt(2); // 1.414...\n\n\n1\n\n\n计算ex次方：\n\nmath.exp(2); // 7.389...\n\n\n1\n\n\n计算以e为底的对数：\n\nmath.log(4); // 1.386...\n\n\n1\n\n\n计算以10为底的对数：\n\nmath.log10(100); // 2\n\n\n1\n\n\n三角函数：\n\nmath.sin(3.14); // 0.00159...\nmath.cos(3.14); // -0.9999...\nmath.tan(3.14); // -0.0015...\nmath.asin(1.0); // 1.57079...\nmath.acos(1.0); // 0.0\n\n\n1\n2\n3\n4\n5\n\n\nmath还提供了几个数学常量：\n\ndouble pi = math.pi; // 3.14159...\ndouble e = math.e; // 2.7182818...\nmath.sin(math.pi / 6); // sin(π/6) = 0.5\n\n\n1\n2\n3\n\n\n生成一个随机数x，x的范围是0 <= x < 1：\n\nmath.random(); // 0.53907... 每次都不一样\n\n\n1\n\n\n# random\n\nrandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。\n\n要生成一个随机数，可以使用nextint()、nextlong()、nextfloat()、nextdouble()：\n\nrandom r = new random();\nr.nextint(); // 2071575453,每次都不一样\nr.nextint(10); // 5,生成一个[0,10)之间的int\nr.nextlong(); // 8811649292570369305,每次都不一样\nr.nextfloat(); // 0.54335...生成一个[0,1)之间的float\nr.nextdouble(); // 0.3716...生成一个[0,1)之间的double\n\n\n1\n2\n3\n4\n5\n6\n\n\n有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。\n\n这是因为我们创建random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。\n\n如果我们在创建random实例时指定一个种子，就会得到完全确定的随机数序列。\n\n# securerandom\n\n有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，securerandom就是用来创建安全的随机数的：\n\nsecurerandom sr = new securerandom();\nsystem.out.println(sr.nextint(100));\n\n\n1\n2\n\n\nsecurerandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过cpu的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。\n\n在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用securerandom来产生安全的随机数。\n\n\n# 异常处理\n\n\n# java的异常\n\n因为java的异常是class，它的继承关系如下：\n\n                     ┌───────────┐\n                     │  object   │\n                     └───────────┘\n                           ▲\n                           │\n                     ┌───────────┐\n                     │ throwable │\n                     └───────────┘\n                           ▲\n                 ┌─────────┴─────────┐\n                 │                   │\n           ┌───────────┐       ┌───────────┐\n           │   error   │       │ exception │\n           └───────────┘       └───────────┘\n                 ▲                   ▲\n         ┌───────┘              ┌────┴──────────┐\n         │                      │               │\n┌─────────────────┐    ┌─────────────────┐┌───────────┐\n│outofmemoryerror │... │runtimeexception ││ioexception│...\n└─────────────────┘    └─────────────────┘└───────────┘\n                                ▲\n                    ┌───────────┴─────────────┐\n                    │                         │\n         ┌─────────────────────┐ ┌─────────────────────────┐\n         │nullpointerexception │ │illegalargumentexception │...\n         └─────────────────────┘ └─────────────────────────┘\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n从继承关系可知：throwable是异常体系的根，它继承自object。throwable有两个体系：error和exception，error表示严重的错误，程序对此一般无能为力，例如：\n\n * outofmemoryerror：内存耗尽\n * noclassdeffounderror：无法加载某个class\n * stackoverflowerror：栈溢出\n\n而exception则是运行时的错误，它可以被捕获并处理。\n\n某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：\n\n * numberformatexception：数值类型的格式错误\n * filenotfoundexception：未找到文件\n * socketexception：读取网络失败\n\n还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：\n\n * nullpointerexception：对某个null的对象调用方法或字段\n * indexoutofboundsexception：数组索引越界\n\nexception又分为两大类：\n\n 1. runtimeexception以及它的子类；\n 2. 非runtimeexception（包括ioexception、reflectiveoperationexception等等）\n\njava规定：\n\n * 必须捕获的异常，包括exception及其子类，但不包括runtimeexception及其子类，这种类型的异常称为checked exception。\n * 不需要捕获的异常，包括error及其子类，runtimeexception及其子类。\n\n\n# 捕获异常\n\n在java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { ... }中，然后使用catch捕获对应的exception及其子类。\n\n可以使用多个catch语句，每个catch分别捕获对应的exception及其子类。jvm在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。\n\n存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。\n\n注意finally有几个特点：\n\n 1. finally语句不是必须的，可写可不写；\n 2. finally总是最后执行。\n\n\n# 抛出异常\n\n通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过throwable.getsuppressed()获取所有添加的suppressed exception。\n\npublic class main {\n    public static void main(string[] args) throws exception {\n        exception origin = null;\n        try {\n            system.out.println(integer.parseint("abc"));\n        } catch (exception e) {\n            origin = e;\n            throw e;\n        } finally {\n            exception e = new illegalargumentexception();\n            if (origin != null) {\n                e.addsuppressed(origin);\n            }\n            throw e;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 断言\n\n断言（assertion）是一种调试程序的方式。在java中，使用assert关键字来实现断言。\n\npublic static void main(string[] args) {\n    double x = math.abs(-123.45);\n    assert x >= 0;\n    system.out.println(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\n语句assert x >= 0;即为断言，断言条件x >= 0预期为true。如果计算结果为false，则断言失败，抛出assertionerror。\n\njvm默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。\n\n要执行assert语句，必须给java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。\n\n\n# 反射\n\n\n# class类\n\n反射就是reflection，java的反射是指程序在运行期可以拿到一个对象的所有信息。\n\n反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。\n\nclass（包括interface）的本质是数据类型（type）。无继承关系的数据类型无法赋值：\n\nnumber n = new double(123.456); // ok\nstring s = new double(123.456); // compile error!\n\n\n1\n2\n\n\n而class是由jvm在执行过程中动态加载的。jvm在第一次读取到一种class类型时，将其加载进内存。\n\n每加载一种class，jvm就为其创建一个class类型的实例，并关联起来。注意：这里的class类型是一个名叫class的class。它长这样：\n\npublic final class class {\n    private class() {}\n}\n\n\n1\n2\n3\n\n\n以string类为例，当jvm加载string类时，它首先读取string.class文件到内存，然后，为string类创建一个class实例并关联起来：\n\nclass cls = new class(string);\n\n\n1\n\n\n这个class实例是jvm内部创建的，如果我们查看jdk源码，可以发现class类的构造方法是private，只有jvm能创建class实例，我们自己的java程序是无法创建class实例的。\n\n----------------------------------------\n\n由于jvm为每个加载的class创建了对应的class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个class实例，我们就可以通过这个class实例获取到该实例对应的class的所有信息。\n\n这种通过class实例获取class信息的方法称为反射（reflection）。\n\n如何获取一个class的class实例？有三个方法：\n\n方法一：直接通过一个class的静态变量class获取：\n\nclass cls = string.class;\n\n\n1\n\n\n方法二：如果我们有一个实例变量，可以通过该实例变量提供的getclass()方法获取：\n\nstring s = "hello";\nclass cls = s.getclass();\n\n\n1\n2\n\n\n方法三：如果知道一个class的完整类名，可以通过静态方法class.forname()获取：\n\nclass cls = class.forname("java.lang.string");\n\n\n1\n\n\n因为class实例在jvm中是唯一的，所以，上述方法获取的class实例是同一个实例。\n\n注意一下class实例比较和instanceof的差别：\n\ninteger n = new integer(123);\n\nboolean b1 = n instanceof integer; // true，因为n是integer类型\nboolean b2 = n instanceof number; // true，因为n是number类型的子类\n\nboolean b3 = n.getclass() == integer.class; // true，因为n.getclass()返回integer.class\nboolean b4 = n.getclass() == number.class; // false，因为integer.class!=number.class\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。\n\n通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。\n\n如果获取到了一个class实例，我们就可以通过该class实例来创建对应类型的实例：\n\n// 获取string的class实例:\nclass cls = string.class;\n// 创建一个string实例:\nstring s = (string) cls.newinstance();\n\n\n1\n2\n3\n4\n\n\n上述代码相当于new string()。通过class.newinstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过class.newinstance()被调用\n\n\n# 动态加载\n\njvm在执行java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：\n\n// main.java\npublic class main {\n    public static void main(string[] args) {\n        if (args.length > 0) {\n            create(args[0]);\n        }\n    }\n\n    static void create(string name) {\n        person p = new person(name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当执行main.java时，由于用到了main，因此，jvm首先会把main.class加载到内存。然而，并不会加载person.class，除非程序执行到create()方法，jvm发现需要加载person类时，才会首次加载person.class。如果没有执行create()方法，那么person.class根本就不会被加载。\n\n\n# 访问字段\n\n对任意的一个object实例，只要我们获取了它的class，就可以获取它的一切信息。\n\n我们先看看如何通过class实例获取字段信息。class类提供了以下几个方法来获取字段：\n\n * field getfield(name)：根据字段名获取某个public的field（包括父类）\n * field getdeclaredfield(name)：根据字段名获取当前类的某个field（不包括父类）\n * field[] getfields()：获取所有public的field（包括父类）\n * field[] getdeclaredfields()：获取当前类的所有field（不包括父类）\n\n一个field对象包含了一个字段的所有信息：\n\n * getname()：返回字段名称，例如，"name"；\n * gettype()：返回字段类型，也是一个class实例，例如，string.class；\n * getmodifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。\n\n通过反射可以获取字段值和设置字段值。\n\n\n# 调用方法\n\n我们已经能通过class实例获取所有field对象，同样的，可以通过class实例获取所有method信息。class类提供了以下几个方法来获取method：\n\n * method getmethod(name, class...)：获取某个public的method（包括父类）\n * method getdeclaredmethod(name, class...)：获取当前类的某个method（不包括父类）\n * method[] getmethods()：获取所有public的method（包括父类）\n * method[] getdeclaredmethods()：获取当前类的所有method（不包括父类）\n\n一个method对象包含一个方法的所有信息：\n\n * getname()：返回方法名称，例如："getscore"；\n * getreturntype()：返回方法返回值类型，也是一个class实例，例如：string.class；\n * getparametertypes()：返回方法的参数类型，是一个class数组，例如：{string.class, int.class}；\n * getmodifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。\n\n\n# 调用方法\n\n// reflection\nimport java.lang.reflect.method;\n\npublic class main {\n    public static void main(string[] args) throws exception {\n        // string对象:\n        string s = "hello world";\n        // 获取string substring(int)方法，参数为int:\n        method m = string.class.getmethod("substring", int.class);\n        // 在s对象上调用该方法并获取结果:\n        string r = (string) m.invoke(s, 6);\n        // 打印调用结果:\n        system.out.println(r);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 调用静态方法\n\nimport java.lang.reflect.method;\npublic class main {\n    public static void main(string[] args) throws exception {\n        // 获取integer.parseint(string)方法，参数为string:\n        method m = integer.class.getmethod("parseint", string.class);\n        // 调用该静态方法并获取结果:\n        integer n = (integer) m.invoke(null, "12345");\n        // 打印调用结果:\n        system.out.println(n);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。\n\n通过设置setaccessible(true)来访问非public方法；(可能会设置失败)\n\n\n# 调用构造方法\n\n如果通过反射来创建新的实例，可以调用class提供的newinstance()方法：\n\nperson p = person.class.newinstance();\n\n\n1\n\n\n调用class.newinstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过class.newinstance()来调用。\n\n为了调用任意的构造方法，java的反射api提供了constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。constructor对象和method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。\n\nimport java.lang.reflect.constructor;\n\npublic class main {\n    public static void main(string[] args) throws exception {\n        // 获取构造方法integer(int):\n        constructor cons1 = integer.class.getconstructor(int.class);\n        // 调用构造方法:\n        integer n1 = (integer) cons1.newinstance(123);\n        system.out.println(n1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过class实例获取constructor的方法如下：\n\n * getconstructor(class...)：获取某个public的constructor；\n * getdeclaredconstructor(class...)：获取某个constructor；\n * getconstructors()：获取所有public的constructor；\n * getdeclaredconstructors()：获取所有constructor。\n\n注意constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。\n\n调用非public的constructor时，必须首先通过setaccessible(true)设置允许访问。setaccessible(true)可能会失败。\n\n\n# 获取继承关系\n\n通过class对象可以获取继承关系：\n\n * class getsuperclass()：获取父类类型；\n * class[] getinterfaces()：获取当前类实现的所有接口。\n\n要特别注意：getinterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。\n\n此外，对所有interface的class调用getsuperclass()返回的是null，获取接口的父接口要用getinterfaces()。\n\n如果一个类没有实现任何interface，那么getinterfaces()返回空数组。\n\n通过class对象的isassignablefrom()方法可以判断一个向上转型是否可以实现。\n\n\n# 动态代理\n\n我们来比较java的class和interface的区别：\n\n * 可以实例化class（非abstract）；\n * 不能实例化interface。\n\n所有interface类型的变量总是通过向上转型并指向某个实例的。\n\njava标准库提供了一种动态代理（dynamic proxy）的机制：可以在运行期动态创建某个interface的实例。\n\n什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：\n\n定义接口：\n\npublic interface hello {\n    void morning(string name);\n}\n\n\n1\n2\n3\n\n\n编写实现类：\n\npublic class helloworld implements hello {\n    public void morning(string name) {\n        system.out.println("good morning, " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n创建实例，转型为接口并调用：\n\nhello hello = new helloworld();\nhello.morning("bob");\n\n\n1\n2\n\n\n这种方式就是我们通常编写代码的方式。\n\n还有一种方式是动态代码，我们仍然先定义了接口hello，但是我们并不去编写实现类，而是直接通过jdk提供的一个proxy.newproxyinstance()创建了一个hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。jdk提供的动态创建接口对象的方式，就叫动态代理。\n\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.method;\nimport java.lang.reflect.proxy;\npublic class main {\n    public static void main(string[] args) {\n        invocationhandler handler = new invocationhandler() {\n            @override\n            public object invoke(object proxy, method method, object[] args) throws throwable {\n                system.out.println(method);\n                if (method.getname().equals("morning")) {\n                    system.out.println("good morning, " + args[0]);\n                }\n                return null;\n            }\n        };\n        hello hello = (hello) proxy.newproxyinstance(\n            hello.class.getclassloader(), // 传入classloader\n            new class[] { hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的invocationhandler\n        hello.morning("bob");\n    }\n}\n\ninterface hello {\n    void morning(string name);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在运行期动态创建一个interface实例的方法如下：\n\n 1. 定义一个invocationhandler实例，它负责实现接口的方法调用；\n 2. 通过proxy.newproxyinstance()创建interface实例，它需要3个参数：\n    1. 使用的classloader，通常就是接口类的classloader；\n    2. 需要实现的接口数组，至少需要传入一个接口进去；\n    3. 用来处理接口方法调用的invocationhandler实例。\n 3. 将返回的object强制转型为接口。\n\n动态代理实际上是jdk在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：\n\npublic class hellodynamicproxy implements hello {\n    invocationhandler handler;\n    public hellodynamicproxy(invocationhandler handler) {\n        this.handler = handler;\n    }\n    public void morning(string name) {\n        handler.invoke(\n           this,\n           hello.class.getmethod("morning"),\n           new object[] { name });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n其实就是jdk帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。\n\n\n# 注解\n\n\n# 使用注解\n\n什么是注解（annotation）？注解是放在java源码的类、方法、字段、参数前的一种特殊“注释”。\n\n注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。\n\n从jvm的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。\n\njava的注解可以分为三类：\n\n第一类是由编译器使用的注解，例如：\n\n * @override：让编译器检查该方法是否正确地实现了覆写；\n * @suppresswarnings：告诉编译器忽略此处代码产生的警告。\n\n这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。\n\n第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。\n\n第三类是在程序运行期能够读取的注解，它们在加载后一直存在于jvm中，这也是最常用的注解。例如，一个配置了@postconstruct的方法会在调用构造方法后自动被调用（这是java代码读取该注解实现的功能，jvm并不会识别该注解）。\n\n注解可以配置参数，没有指定配置的参数使用默认值；\n\n\n# 定义注解\n\njava语言使用@interface语法来定义注解（annotation），它的格式如下：\n\npublic @interface report {\n    int type() default 0;\n    string level() default "info";\n    string value() default "";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 元注解\n\n有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。\n\n# @target\n\n最常用的元注解是@target。使用@target可以定义annotation能够被应用于源码的哪些位置：\n\n * 类或接口：elementtype.type；\n * 字段：elementtype.field；\n * 方法：elementtype.method；\n * 构造方法：elementtype.constructor；\n * 方法参数：elementtype.parameter。\n\n例如，定义注解@report可用在方法上，我们必须添加一个@target(elementtype.method)：\n\n@target(elementtype.method)\npublic @interface report {\n    int type() default 0;\n    string level() default "info";\n    string value() default "";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @retention\n\n另一个重要的元注解@retention定义了annotation的生命周期：\n\n * 仅编译期：retentionpolicy.source；\n * 仅class文件：retentionpolicy.class；\n * 运行期：retentionpolicy.runtime。\n\n如果@retention不存在，则该annotation默认为class。因为通常我们自定义的annotation都是runtime，所以，务必要加上@retention(retentionpolicy.runtime)这个元注解。\n\n# @repeatable\n\n使用@repeatable这个元注解可以定义annotation是否可重复。\n\n经过@repeatable修饰后，在某个类型声明处，就可以添加多个@report注解：\n\n@repeatable(reports.class)\n@target(elementtype.type)\npublic @interface report {\n    int type() default 0;\n    string level() default "info";\n    string value() default "";\n}\n\n@target(elementtype.type)\npublic @interface reports {\n    report[] value();\n}\n\n//重复使用这个注解\n@report(type=1, level="debug")\n@report(type=2, level="warning")\npublic class hello {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# @inherited\n\n使用@inherited定义子类是否可继承父类定义的annotation。@inherited仅针对@target(elementtype.type)类型的annotation有效，并且仅针对class的继承，对interface的继承无效。\n\n其中，必须设置@target和@retention，@retention一般设置为runtime，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@inherited和@repeatable。\n\n\n# 处理注解\n\njava的注解本身对代码逻辑没有任何影响。根据@retention的配置：\n\n * source类型的注解在编译期就被丢掉了；\n * class类型的注解仅保存在class文件中，它们不会被加载进jvm；\n * runtime类型的注解会被加载进jvm，并且在运行期可以被程序读取。\n\n如何使用注解完全由工具决定。source类型的注解主要由编译器使用，因此我们一般只使用，不编写。class类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有runtime类型的注解不但要使用，还经常需要编写。\n\n因此，我们只讨论如何读取runtime类型的注解。\n\n因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.annotation，因此，读取注解，需要使用反射api。\n\n\n# 使用注解\n\n注解如何使用，完全由程序自己决定。例如，junit是一个测试框架，它会自动运行所有标记为@test的方法。\n\n我们来看一个@range注解，我们希望用它来定义一个string字段的规则：字段长度满足@range的参数定义：\n\n@retention(retentionpolicy.runtime)\n@target(elementtype.field)\npublic @interface range {\n    int min() default 0;\n    int max() default 255;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在某个javabean中，我们可以使用该注解：\n\npublic class person {\n    @range(min=1, max=20)\n    public string name;\n\n    @range(max=10)\n    public string city;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个person实例的检查方法，它可以检查person实例的string字段长度是否满足@range的定义：\n\nvoid check(person person) throws illegalargumentexception, reflectiveoperationexception {\n    // 遍历所有field:\n    for (field field : person.getclass().getfields()) {\n        // 获取field定义的@range:\n        range range = field.getannotation(range.class);\n        // 如果@range存在:\n        if (range != null) {\n            // 获取field的值:\n            object value = field.get(person);\n            // 如果值是string:\n            if (value instanceof string) {\n                string s = (string) value;\n                // 判断值是否满足@range的min/max:\n                if (s.length() < range.min() || s.length() > range.max()) {\n                    throw new illegalargumentexception("invalid field: " + field.getname());\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这样一来，我们通过@range注解，配合check()方法，就可以完成person实例的检查。注意检查逻辑完全是我们自己编写的，jvm不会自动给注解添加任何额外的逻辑。\n\n\n# 泛型\n\n泛型就是定义一种模板，例如arraylist，然后在代码中为用到的类创建对应的arraylist<类型>：\n\narraylist<string> strlist = new arraylist<string>();\n\n\n1\n\n\n要特别注意：不能把arraylist向上转型为arraylist或list。\n\n\n# 擦拭法\n\njava语言的泛型实现方式是擦拭法（type erasure）。\n\n所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。\n\njava使用擦拭法实现泛型，导致了：\n\n * 编译器把类型<t>视为object；\n * 编译器根据<t>实现安全的强制转型。\n\n使用泛型的时候，我们编写的代码也是编译器看到的代码：\n\npair<string> p = new pair<>("hello", "world");\nstring first = p.getfirst();\nstring last = p.getlast();\n\n\n1\n2\n3\n\n\n而虚拟机执行的代码并没有泛型：\n\npair p = new pair("hello", "world");\nstring first = (string) p.getfirst();\nstring last = (string) p.getlast();\n\n\n1\n2\n3\n\n\n所以，java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型t视为object处理，但是，在需要转型的时候，编译器会根据t的类型自动为我们实行安全地强制转型。\n\n擦拭法决定了泛型<t>：\n\n * 不能是基本类型，例如：int；\n * 不能获取带泛型类型的class，例如：pair.class；\n * 不能判断带泛型类型的类型，例如：x instanceof pair；\n * 不能实例化t类型，例如：new t()。\n\n泛型方法要防止重复定义方法，例如：public boolean equals(t obj)；\n\n子类可以获取父类的泛型类型<t>。\n\n\n# extends通配符\n\npublic class main {  \n\tpublic static void main(string[] args) {\n    pair<integer> p = new pair<>(123, 456);\n    int n = add(p);\n    system.out.println(n);\n  }\n\n  static int add(pair<? extends number> p) { // 设置extends通配符，pari<integer>类型可传入pair<number>\n    number first = p.getfirst();\n    number last = p.getlast();\n    return first.intvalue() + last.intvalue();\n  }\n}\nclass pair<t> {\n    private t first;\n    private t last;\n    public pair(t first, t last) {\n        this.first = first;\n        this.last = last;\n    }\n    public t getfirst() {\n        return first;\n    }\n    public t getlast() {\n        return last;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这样一来，给方法传入pair<integer>类型时，它符合参数pair<? extends number>类型。这种使用<? extends number>的泛型定义称之为上界通配符（upper bounds wildcards），即把泛型类型t的上界限定在number了。\n\n除了可以传入pair<integer>类型，我们还可以传入pair<double>类型，pair<bigdecimal>类型等等，因为double和bigdecimal都是number的子类。\n\n使用类似pair<? extends number>通配符作为方法参数时表示：\n\n * 方法内部可以调用获取number引用的方法，例如：number n = obj.getfirst();；\n * 方法内部无法调用传入number引用的方法（null除外），例如：obj.setfirst(number n);。\n\n即一句话总结：使用extends通配符表示可以读，不能写。\n\n使用类似<t extends number>定义泛型类时表示：\n\n * 泛型类型限定为number以及number的子类。\n\n\n# super通配符\n\nvoid set(pair<? super integer> p, integer first, integer last) {\n    p.setfirst(first);\n    p.setlast(last);\n}\n\n\n1\n2\n3\n4\n\n\n注意到pair<? super integer>表示，方法参数接受所有泛型类型为integer或integer父类的pair类型。\n\n使用pair<? super integer>通配符表示：\n\n * 允许调用set(? super integer)方法传入integer的引用；\n * 不允许调用get()方法获得integer的引用。\n\n唯一例外是可以获取object的引用：object o = p.getfirst()。\n\n换句话说，使用super通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。\n\n\n# pesc原则\n\n何时使用extends，何时使用super？为了便于记忆，我们可以用pecs原则：producer extends consumer super。\n\n即：如果需要返回t，它是生产者（producer），要使用extends通配符；如果需要写入t，它是消费者（consumer），要使用super通配符。\n\n\n# 无限定通配符\n\n我们已经讨论了<? extends t>和<? super t>作为方法参数的作用。实际上，java的泛型还允许使用无限定通配符（unbounded wildcard type），即只定义一个?：\n\nvoid sample(pair<?> p) {\n}\n\n\n1\n2\n\n\n因为<?>通配符既没有extends，也没有super，因此：\n\n * 不允许调用set(t)方法并传入引用（null除外）；\n * 不允许调用t get()方法并获取t引用（只能获取object引用）。\n\n换句话说，既不能读，也不能写，那只能做一些null判断：\n\nstatic boolean isnull(pair<?> p) {\n    return p.getfirst() == null || p.getlast() == null;\n}\n\n\n1\n2\n3\n\n\n大多数情况下，可以引入泛型参数<t>消除<?>通配符：\n\nstatic <t> boolean isnull(pair<t> p) {\n    return p.getfirst() == null || p.getlast() == null;\n}\n\n\n1\n2\n3\n\n\n<?>通配符有一个独特的特点，就是：pair<?>是所有pair<t>的超类。\n\n\n# 泛型和反射\n\n部分反射api是泛型，例如：class，constructor；\n\n可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；\n\n可以通过array.newinstance(class, int)创建t[]数组，需要强制转型；\n\n同时使用泛型和可变参数时需要特别小心。\n\n\n# 集合\n\n\n# java集合简介\n\n在java中，如果一个java对象可以在内部持有若干其他java对象，并对外提供访问接口，我们把这种java对象称为集合。\n\njava标准库自带的java.util包提供了集合类：collection，它是除map外所有其他集合类的根接口。java的java.util包主要提供了以下三种类型的集合：\n\n * list：一种有序列表的集合，例如，按索引排列的student的list；\n * set：一种保证没有重复元素的集合，例如，所有无重复名称的student的set；\n * map：一种通过键值（key-value）查找的映射表集合，例如，根据student的name查找对应student的map。\n\n\n\n\n最后，java访问集合总是通过统一的方式——迭代器（iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。\n\n由于java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：\n\n * hashtable：一种线程安全的map实现；\n * vector：一种线程安全的list实现；\n * stack：基于vector实现的lifo的栈。\n\n还有一小部分接口是遗留接口，也不应该继续使用：\n\n * enumeration：已被iterator取代。\n\n\n# list\n\n\n# list和array互转\n\nimport java.util.list;\npublic class main {\n    public static void main(string[] args) {\n        list<integer> list = list.of(12, 34, 56);\n      \t//list转array\n        number[] array = list.toarray(new number[list.size()]);\n      \t//array转list\n      \tlist<number> list = list.of(array);\n        for (number n : array) {\n            system.out.println(n);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# hashmap（基于jdk 1.8和jdk 1.7）\n\nhashmap这个笔记有点多，我专门整理成一个专题，可以去看hashmap详解专题\n\n\n# java多线程与高并发\n\n详细内容见多线程和高并发。\n\n\n# io\n\n\n# io简介\n\nio是指input/output，即输入和输出。以内存为中心：\n\n * input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。\n * output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。\n\n\n# inputstream / outputstream\n\nio流以byte（字节）为最小单位，因此也称为字节流。\n\n在java中，inputstream代表输入字节流，ouputstream代表输出字节流，这是最基本的两种io流。\n\n\n# reader / writer\n\n如果我们需要读写的是字符，并且字符不全是单字节表示的ascii字符，那么，按照char来读写显然更方便，这种流称为字符流。\n\njava提供了reader和writer表示字符流，字符流传输的最小数据单位是char。\n\n例如，我们把char[]数组hi你好这4个字符用writer字符流写入文件，并且使用utf-8编码，得到的最终文件内容是8个字节，英文字符h和i各占一个字节，中文字符你好各占3个字节。\n\n使用reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是reader内部把读入的byte做了解码，转换成了char。使用inputstream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用reader还是inputstream，要取决于具体的使用场景。如果数据源不是文本，就只能使用inputstream，如果数据源是文本，使用reader更方便一些。writer和outputstream是类似的。\n\n\n# 同步和异步\n\n同步io是指，读写io时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是cpu执行效率低。\n\n而异步io是指，读写io时仅发出请求，然后立刻执行后续代码，它的优点是cpu执行效率高，缺点是代码编写复杂。\n\njava标准库的包java.io提供了同步io，而java.nio则是异步io。上面我们讨论的inputstream、outputstream、reader和writer都是同步io的抽象类，对应的具体实现类，以文件为例，有fileinputstream、fileoutputstream、filereader和filewriter。\n\n\n# 小结\n\nio流是一种流式的数据输入/输出模型：\n\n * 二进制数据以byte为最小单位在inputstream/outputstream中单向流动；\n * 字符数据以char为最小单位在reader/writer中单向流动。\n\njava标准库的java.io包提供了同步io功能：\n\n * 字节流接口：inputstream/outputstream；\n * 字符流接口：reader/writer。\n\n\n# file对象\n\n在计算机系统中，文件是非常重要的存储方式。java的标准库java.io提供了file对象来操作文件和目录。\n\nfile对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个file对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个file对象，并不会导致任何磁盘操作。只有当我们调用file对象的某些方法的时候，才真正进行磁盘操作。\n\njava标准库的java.io.file对象表示一个文件或者目录：\n\n * 创建file对象本身不涉及io操作；\n * 可以获取路径／绝对路径／规范路径：getpath()/getabsolutepath()/getcanonicalpath()；\n * 可以获取目录的文件和子目录：list()/listfiles()；\n * 可以创建或删除文件和目录。\n\n\n# inputstream\n\ninputstream就是java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步io的功能。\n\n要特别注意的一点是，inputstream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：\n\npublic abstract int read() throws ioexception;\n\n\n1\n\n\n这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。\n\nfileinputstream是inputstream的一个子类。顾名思义，fileinputstream就是从文件流中读取数据。下面的代码演示了如何完整地读取一个fileinputstream的所有字节：\n\npublic void readfile() throws ioexception {\n    // 创建一个fileinputstream对象:\n    inputstream input = new fileinputstream("src/readme.txt");\n    for (;;) {\n        int n = input.read(); // 反复调用read()方法，直到返回-1\n        if (n == -1) {\n            break;\n        }\n        system.out.println(n); // 打印byte的值\n    }\n    input.close(); // 关闭流\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。\n\ninputstream和outputstream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。\n\n\n# 缓冲\n\n在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。inputstream提供了两个重载方法来支持读取多个字节：\n\n * int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数\n * int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数\n\n利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。\n\n利用缓冲区一次读取多个字节的代码如下：\n\npublic void readfile() throws ioexception {\n    try (inputstream input = new fileinputstream("src/readme.txt")) {\n        // 定义1000个字节大小的缓冲区:\n        byte[] buffer = new byte[1000];\n        int n;\n        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区\n            system.out.println("read " + n + " bytes.");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 阻塞\n\n在调用inputstream的read()方法读取数据时，我们说read()方法是阻塞（blocking）的。它的意思是，对于下面的代码：\n\nint n;\nn = input.read(); // 必须等待read()方法返回才能执行下一行代码\nint m = n;\n\n\n1\n2\n3\n\n\n执行到第二行代码时，必须等read()方法返回后才能继续。因为读取io流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。\n\n\n# 小结\n\njava标准库的java.io.inputstream定义了所有输入流的超类：\n\n * fileinputstream实现了文件流输入；\n * bytearrayinputstream在内存中模拟一个字节流输入。\n\n总是使用try(resource)来保证inputstream正确关闭。\n\n\n# outputstream\n\n和inputstream相反，outputstream是java标准库提供的最基本的输出流。\n\n和inputstream类似，outputstream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：\n\npublic abstract void write(int b) throws ioexception;\n\n\n1\n\n\n这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b & 0xff）。\n\n和inputstream类似，outputstream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：outputstream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。\n\n为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多io设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以outputstream有个flush()方法，能强制把缓冲区内容输出。\n\n通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了outputstream会自动调用它，并且，在调用close()方法关闭outputstream之前，也会自动调用flush()方法。\n\n但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：\n\n小明正在开发一款在线聊天软件，当用户输入一句话后，就通过outputstream的write()方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？\n\n原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4k，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。\n\n解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。\n\n实际上，inputstream也有缓冲区。例如，从fileinputstream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致io操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。\n\n\n# fileoutputstream\n\n我们以fileoutputstream为例，演示如何将若干个字节写入文件流：\n\npublic void writefile() throws ioexception {\n    outputstream output = new fileoutputstream("out/readme.txt");\n    output.write(72); // h\n    output.write(101); // e\n    output.write(108); // l\n    output.write(108); // l\n    output.write(111); // o\n    output.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用outputstream提供的重载方法void write(byte[])来实现：\n\npublic void writefile() throws ioexception {\n    outputstream output = new fileoutputstream("out/readme.txt");\n    output.write("hello".getbytes("utf-8")); // hello\n    output.close();\n}\n\n\n1\n2\n3\n4\n5\n\n\n和inputstream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生io错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证outputstream在无论是否发生io错误的时候都能够正确地关闭：\n\npublic void writefile() throws ioexception {\n    try (outputstream output = new fileoutputstream("out/readme.txt")) {\n        output.write("hello".getbytes("utf-8")); // hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 阻塞\n\n和inputstream一样，outputstream的write()方法也是阻塞的。\n\n\n# outputstream实现类\n\n用fileoutputstream可以从文件获取输出流，这是outputstream常用的一个实现类。此外，bytearrayoutputstream可以在内存中模拟一个outputstream：\n\nimport java.io.*;\npublic class main {\n    public static void main(string[] args) throws ioexception {\n        byte[] data;\n        try (bytearrayoutputstream output = new bytearrayoutputstream()) {\n            output.write("hello ".getbytes("utf-8"));\n            output.write("world!".getbytes("utf-8"));\n            data = output.tobytearray();\n        }\n        system.out.println(new string(data, "utf-8"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nbytearrayoutputstream实际上是把一个byte[]数组在内存中变成一个outputstream，虽然实际应用不多，但测试的时候，可以用它来构造一个outputstream。\n\n\n# 小结\n\njava标准库的java.io.outputstream定义了所有输出流的超类：\n\n * fileoutputstream实现了文件流输出；\n * bytearrayoutputstream在内存中模拟一个字节流输出。\n\n某些情况下需要手动调用outputstream的flush()方法来强制输出缓冲区。\n\n总是使用try(resource)来保证outputstream正确关闭。\n\n\n# 序列化\n\n序列化是指把一个java对象变成二进制内容，本质上就是一个byte[]数组。\n\n为什么要把java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把java对象存储到文件或者通过网络传输出去了。\n\n有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”java对象，或者从网络上读取byte[]并把它“变回”java对象。\n\n我们来看看如何把一个java对象序列化。\n\n一个java对象要能序列化，必须实现一个特殊的java.io.serializable接口，它的定义如下：\n\npublic interface serializable {\n}\n\n\n1\n2\n\n\nserializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（marker interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。\n\n\n# 序列化\n\n把一个java对象变为byte[]数组，需要使用objectoutputstream。它负责把一个java对象写入一个字节流：\n\nimport java.io.*;\nimport java.util.arrays;\npublic class main {\n    public static void main(string[] args) throws ioexception {\n        bytearrayoutputstream buffer = new bytearrayoutputstream();\n        try (objectoutputstream output = new objectoutputstream(buffer)) {\n            // 写入int:\n            output.writeint(12345);\n            // 写入string:\n            output.writeutf("hello");\n            // 写入object:\n            output.writeobject(double.valueof(123.456));\n        }\n        system.out.println(arrays.tostring(buffer.tobytearray()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nobjectoutputstream既可以写入基本类型，如int，boolean，也可以写入string（以utf-8编码），还可以写入实现了serializable接口的object。\n\n因为写入object时需要大量的类型信息，所以写入的内容很大。\n\n\n# 反序列化\n\n和objectoutputstream相反，objectinputstream负责从一个字节流读取java对象：\n\ntry (objectinputstream input = new objectinputstream(...)) {\n    int n = input.readint();\n    string s = input.readutf();\n    double d = (double) input.readobject();\n}\n\n\n1\n2\n3\n4\n5\n\n\n除了能读取基本类型和string类型外，调用readobject()可以直接返回一个object对象。要把它变成一个特定类型，必须强制转型。\n\nreadobject()可能抛出的异常有：\n\n * classnotfoundexception：没有找到对应的class；\n * invalidclassexception：class不匹配。\n\n对于classnotfoundexception，这种情况常见于一台电脑上的java程序把一个java对象，例如，person对象序列化以后，通过网络传给另一台电脑上的另一个java程序，但是这台电脑的java程序并没有定义person类，所以无法反序列化。\n\n对于invalidclassexception，这种情况常见于序列化的person对象定义了一个int类型的age字段，但是反序列化时，person类定义的age字段被改成了long类型，所以导致class不兼容。\n\n为了避免这种class定义变动导致的不兼容，java的序列化允许class定义一个特殊的serialversionuid静态变量，用于标识java类的序列化“版本”，通常可以由ide自动生成。如果增加或修改了字段，可以改变serialversionuid的值，这样就能自动阻止不匹配的class版本：\n\npublic class person implements serializable {\n    private static final long serialversionuid = 2709425275741743919l;\n}\n\n\n1\n2\n3\n\n\n要特别注意反序列化的几个重要特点：\n\n反序列化时，由jvm直接构造出java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。\n\n\n# 安全性\n\n因为java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的java代码，从而导致严重的安全漏洞。\n\n实际上，java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过json这样的通用数据结构来实现，只输出基本类型（包括string）的内容，而不存储任何与代码相关的信息。\n\n\n# 小结\n\n可序列化的java对象必须实现java.io.serializable接口，类似serializable这样的空接口被称为“标记接口”（marker interface）；\n\n反序列化时不调用构造方法，可设置serialversionuid作为版本号（非必需）；\n\njava的序列化机制仅适用于java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如json。\n\n\n# reader\n\nreader是java的io库提供的另一个输入流接口。和inputstream的区别是，inputstream是一个字节流，即以byte为单位读取，而reader是一个字符流，即以char为单位读取：\n\ninputstream                 reader\n字节流，以byte为单位                字符流，以char为单位\n读取字节（-1，0~255）：int read()   读取字符（-1，0~65535）：int read()\n读到字节数组：int read(byte[] b)   读到字符数组：int read(char[] c)\n\njava.io.reader是所有字符输入流的超类，它最主要的方法是：\n\npublic int read() throws ioexception;\n\n\n1\n\n\n这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。\n\n\n# filereader\n\nfilereader是reader的一个子类，它可以打开文件并获取reader。下面的代码演示了如何完整地读取一个filereader的所有字符：\n\npublic void readfile() throws ioexception {\n    // 创建一个filereader对象:\n    reader reader = new filereader("src/readme.txt"); // 字符编码是???\n    for (;;) {\n        int n = reader.read(); // 反复调用read()方法，直到返回-1\n        if (n == -1) {\n            break;\n        }\n        system.out.println((char)n); // 打印char\n    }\n    reader.close(); // 关闭流\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果我们读取一个纯ascii编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为filereader默认的编码与系统相关，例如，windows系统的默认编码可能是gbk，打开一个utf-8编码的文本文件就会出现乱码。\n\n要避免乱码问题，我们需要在创建filereader时指定编码：\n\nreader reader = new filereader("src/readme.txt", standardcharsets.utf_8);\n\n\n1\n\n\n和inputstream类似，reader也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用try (resource)来保证reader在无论有没有io错误的时候都能够正确地关闭：\n\ntry (reader reader = new filereader("src/readme.txt", standardcharsets.utf_8) {\n    // todo\n}\n\n\n1\n2\n3\n\n\nreader还提供了一次性读取若干字符并填充到char[]数组的方法：\n\npublic int read(char[] c) throws ioexception\n\n\n1\n\n\n它返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。\n\n利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：\n\npublic void readfile() throws ioexception {\n    try (reader reader = new filereader("src/readme.txt", standardcharsets.utf_8)) {\n        char[] buffer = new char[1000];\n        int n;\n        while ((n = reader.read(buffer)) != -1) {\n            system.out.println("read " + n + " chars.");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# chararrayreader\n\nchararrayreader可以在内存中模拟一个reader，它的作用实际上是把一个char[]数组变成一个reader，这和bytearrayinputstream非常类似：\n\ntry (reader reader = new chararrayreader("hello".tochararray())) {\n}\n\n\n1\n2\n\n\n\n# stringreader\n\nstringreader可以直接把string作为数据源，它和chararrayreader几乎一样：\n\ntry (reader reader = new stringreader("hello")) {\n}\n\n\n1\n2\n\n\n\n# inputstreamreader\n\nreader和inputstream有什么关系？\n\n除了特殊的chararrayreader和stringreader，普通的reader实际上是基于inputstream构造的，因为reader需要从inputstream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看filereader的源码，它在内部实际上持有一个fileinputstream。\n\n既然reader本质上是一个基于inputstream的byte到char的转换器，那么，如果我们已经有一个inputstream，想把它转换为reader，是完全可行的。inputstreamreader就是这样一个转换器，它可以把任何inputstream转换为reader。示例代码如下：\n\n// 持有inputstream:\ninputstream input = new fileinputstream("src/readme.txt");\n// 变换为reader:\nreader reader = new inputstreamreader(input, "utf-8");\n\n\n1\n2\n3\n4\n\n\n构造inputstreamreader时，我们需要传入inputstream，还需要指定编码，就可以得到一个reader对象。上述代码可以通过try (resource)更简洁地改写如下：\n\ntry (reader reader = new inputstreamreader(new fileinputstream("src/readme.txt"), "utf-8")) {\n    // todo:\n}\n\n\n1\n2\n3\n\n\n上述代码实际上就是filereader的一种实现方式。\n\n使用try (resource)结构时，当我们关闭reader时，它会在内部自动调用inputstream的close()方法，所以，只需要关闭最外层的reader对象即可。\n\n> 使用inputstreamreader，可以把一个inputstream转换成一个reader。\n\n\n# 小结\n\nreader定义了所有字符输入流的超类：\n\n * filereader实现了文件字符流输入，使用时需要指定编码；\n * chararrayreader和stringreader可以在内存中模拟一个字符流输入。\n\nreader是基于inputstream构造的：可以通过inputstreamreader在指定编码的同时将任何inputstream转换为reader。\n\n总是使用try (resource)保证reader正确关闭。\n\n\n# writer\n\nreader是带编码转换器的inputstream，它把byte转换为char，而writer就是带编码转换器的outputstream，它把char转换为byte并输出。\n\nwriter和outputstream的区别如下：\n\noutputstream                    writer\n字节流，以byte为单位                    字符流，以char为单位\n写入字节（0~255）：void write(int b)   写入字符（0~65535）：void write(int c)\n写入字节数组：void write(byte[] b)     写入字符数组：void write(char[] c)\n无对应方法                           写入string：void write(string s)\n\nwriter是所有字符输出流的超类，它提供的方法主要有：\n\n * 写入一个字符（0~65535）：void write(int c)；\n * 写入字符数组的所有字符：void write(char[] c)；\n * 写入string表示的所有字符：void write(string s)。\n\n\n# filewriter\n\nfilewriter就是向文件中写入字符流的writer。它的使用方法和filereader类似：\n\ntry (writer writer = new filewriter("readme.txt", standardcharsets.utf_8)) {\n    writer.write(\'h\'); // 写入单个字符\n    writer.write("hello".tochararray()); // 写入char[]\n    writer.write("hello"); // 写入string\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# chararraywriter\n\nchararraywriter可以在内存中创建一个writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，这和bytearrayoutputstream非常类似：\n\ntry (chararraywriter writer = new chararraywriter()) {\n    writer.write(65);\n    writer.write(66);\n    writer.write(67);\n    char[] data = writer.tochararray(); // { \'a\', \'b\', \'c\' }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# stringwriter\n\nstringwriter也是一个基于内存的writer，它和chararraywriter类似。实际上，stringwriter在内部维护了一个stringbuffer，并对外提供了writer接口。\n\n\n# outputstreamwriter\n\n除了chararraywriter和stringwriter外，普通的writer实际上是基于outputstream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入outputstream。因此，outputstreamwriter就是一个将任意的outputstream转换为writer的转换器：\n\ntry (writer writer = new outputstreamwriter(new fileoutputstream("readme.txt"), "utf-8")) {\n    // todo:\n}\n\n\n1\n2\n3\n\n\n上述代码实际上就是filewriter的一种实现方式。这和上一节的inputstreamreader是一样的。\n\n\n# 小结\n\nwriter定义了所有字符输出流的超类：\n\n * filewriter实现了文件字符流输出；\n * chararraywriter和stringwriter在内存中模拟一个字符流输出。\n\n使用try (resource)保证writer正确关闭。\n\nwriter是基于outputstream构造的，可以通过outputstreamwriter将outputstream转换为writer，转换时需要指定编码。\n\n\n# files\n\n从java 7开始，提供了files和paths这两个工具类，能极大地方便我们读写文件。\n\n虽然files和paths是java.nio包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个byte[]，可以这么写：\n\nbyte[] data = files.readallbytes(paths.get("/path/to/file.txt"));\n\n\n1\n\n\n如果是文本文件，可以把一个文件的全部内容读取为string：\n\n// 默认使用utf-8编码读取:\nstring content1 = files.readstring(paths.get("/path/to/file.txt"));\n// 可指定编码:\nstring content2 = files.readstring(paths.get("/path/to/file.txt"), standardcharsets.iso_8859_1);\n// 按行读取并返回每行内容:\nlist<string> lines = files.readalllines(paths.get("/path/to/file.txt"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n写入文件也非常方便：\n\n// 写入二进制文件:\nbyte[] data = ...\nfiles.write(paths.get("/path/to/file.txt"), data);\n// 写入文本并指定编码:\nfiles.writestring(paths.get("/path/to/file.txt"), "文本内容...", standardcharsets.iso_8859_1);\n// 按行写入文本:\nlist<string> lines = ...\nfiles.write(paths.get("/path/to/file.txt"), lines);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，files工具类还有copy()、delete()、exists()、move()等快捷方法操作文件和目录。\n\n最后需要特别注意的是，files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个g的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。\n\n\n# 小结\n\n对于简单的小文件读写操作，可以使用files工具类简化代码。\n\n\n# 加密与安全\n\n在计算机系统中，什么是加密与安全呢？\n\n我们举个栗子：假设bob要给alice发一封邮件，在邮件传送的过程中，黑客可能会窃取到邮件的内容，所以需要防窃听。黑客还可能会篡改邮件的内容，alice必须有能力识别出邮件有没有被篡改。最后，黑客可能假冒bob给alice发邮件，alice必须有能力识别出伪造的邮件。\n\n所以，应对潜在的安全威胁，需要做到三防：\n\n * 防窃听\n * 防篡改\n * 防伪造\n\n\n# 常用设计模式\n\n详细设计模式见notes\n\n\n# 工厂方法\n\n> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。\n\n工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。\n\n实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。\n\n调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。\n\n\n# 原型\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\n原型模式，即prototype，是指创建新对象的时候，根据现有的一个原型来创建。\n\n\n# 单例\n\n> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n单例模式（singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。\n\npublic class singleton {\n    // 静态字段引用唯一实例:\n    private static final singleton instance = new singleton();\n\n    // 通过静态方法返回实例:\n    public static singleton getinstance() {\n        return instance;\n    }\n\n    // private构造方法保证外部无法实例化:\n    private singleton() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 装饰器模式\n\n> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。\n\n装饰器（decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。\n\n我们还是举个栗子：假设我们需要渲染一个html的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用decorator模式。\n\n顶层接口textnode，写一个它的实现类spannode，实现textnode的一个抽象类nodedecorator，并在抽象类中定义一个textnode字段，再去实现这个nodedecorator类，就是装饰者模式。\n\n\n# 代理模式\n\n代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。\n\n使用proxy模式要求调用方持有接口，作为proxy的类也必须实现相同的接口类型。\n\n\n# 策略模式\n\n策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。\n\n通过扩展策略，不必修改主逻辑，即可获得新策略的结果。\n\n\n# 模板方法\n\n> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n模板方法（template method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。',charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"如何在github上写出漂亮的readme.md",frontmatter:{title:"如何在github上写出漂亮的readme.md",date:"2022-04-01T16:29:21.000Z",permalink:"/pages/8599a5b876fc95u7",titleTag:"常用工具",categories:["工具","修饰"],tags:["markdown"]},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E7%BC%96%E5%86%99%E5%A5%BD%E7%9C%8B%E7%9A%84markdown%E6%96%87%E6%A1%A3.html",relativePath:"03.技术/06.编写好看的markdown文档.md",key:"v-30875754",path:"/pages/8599a5b876fc95u7/",headers:[{level:2,title:"✒️ 问题描述✏️",slug:"问题描述",normalizedTitle:"✒️ 问题描述✏️",charIndex:39},{level:3,title:"😱别人写的readme文档竟如此漂亮🙀",slug:"别人写的readme文档竟如此漂亮",normalizedTitle:"😱别人写的readme文档竟如此漂亮🙀",charIndex:53},{level:3,title:"😟再看看我写的readme文档😂",slug:"再看看我写的readme文档",normalizedTitle:"😟再看看我写的readme文档😂",charIndex:247},{level:2,title:"🤔 那么别人是如何写出那么好看的readme文档的呢❓",slug:"那么别人是如何写出那么好看的readme文档的呢",normalizedTitle:"🤔 那么别人是如何写出那么好看的readme文档的呢❓",charIndex:323},{level:3,title:"👍 readme.md的介绍👍",slug:"readme-md的介绍",normalizedTitle:"👍 readme.md的介绍👍",charIndex:356},{level:3,title:"😙markdown的emoji编辑功能💋",slug:"markdown的emoji编辑功能",normalizedTitle:"😙markdown的emoji编辑功能💋",charIndex:513},{level:3,title:"🐳Shields.io 提供大量的标签 🐾",slug:"shields-io-提供大量的标签",normalizedTitle:"🐳shields.io 提供大量的标签 🐾",charIndex:669},{level:2,title:"📝License💖",slug:"license",normalizedTitle:"📝license💖",charIndex:1949}],headersStr:"✒️ 问题描述✏️ 😱别人写的readme文档竟如此漂亮🙀 😟再看看我写的readme文档😂 🤔 那么别人是如何写出那么好看的readme文档的呢❓ 👍 readme.md的介绍👍 😙markdown的emoji编辑功能💋 🐳Shields.io 提供大量的标签 🐾 📝License💖",content:'[TOC]\n\n\n# 如何在github上写出漂亮的readme.md\n\n\n# ✒️ 问题描述✏️\n\n\n# 😱别人写的readme文档竟如此漂亮🙀\n\n最近自己利用github page搭建自己的个人博客。以前采用hexo 搭建博客的缺点是，换一台电脑就不能用了，这是然人很烦恼的一件事。今天就去翻了翻大佬的github仓库，发现大佬一般是自己在github仓库的readme中做项目介绍。而且，大佬的项目介绍写的那个靓，如下图所示\n\n花花绿绿的标签和图标，是不是看起来很赏心悦目❤️\n\n\n# 😟再看看我写的readme文档😂\n\n就不过多评价了，看起来是如此的刻板，条条款款到还是挺清晰的，哈哈哈，就是缺少色彩感了。看着让人容易犯困\n\n\n# 🤔 那么别人是如何写出那么好看的readme文档的呢❓\n\n\n# 👍 readme.md的介绍👍\n\ngithub上的readme.md是采用markdown语言编写，markdown语言的特点是，其格式编写方便。并且兼容latex，latex是用于非常强大的排版能力与office并列，对于有编程基础的人并不陌生，其排版能力非常强大，在文本编辑过程中，可以不用鼠标。\n\n\n# 😙markdown的emoji编辑功能💋\n\nmarkdown除了类似latex的强大排版功能外，还具有emoji功能，那么它的表情功能怎么用呢？\n\n:emoji:\n\n\n1\n\n\nmarkdown及github支持的表情有哪些呢？可以通过以下两个网站查\n\n * webfx\n\n * emojipedia\n\n\n# 🐳Shields.io 提供大量的标签 🐾\n\nreadme项目说明文档中，有如下图的标签\n\n这些标签是怎么来的呢？可以查阅shields.io进行引用，其中，build pass等标签，很多都需要采用travis CI 、Appvexyor CI或 Circle CI进行运行检测 [^1]。\n\n那么我们如何给自己的readme.md添加标签呢？查阅shields.io 网站各个图标怎么引用\n\n# 🍁 shields.io中有动态的图标\n\n如下需要相应的平台支持,图标显示格式可以查阅shields.io\n\ntwitter follow        /twitter/follow/:user?label=Follow\ngithub follow         /github/followers/:user?label=Follow\ngithub license        /github/license/:user/:repo\n\n\n1\n2\n3\n\n\n# 🚛 shield.io也有静态badge\n\n# 静态badge命名格式\n\nhttps://img.shields.io/badge/<LABEL>-<MESSAGE>-<COLOR>\nor\nhttps://img.shields.io/static/v1?label=<LABEL>&message=<MESSAGE>&color=<COLOR>\n\n\n1\n2\n3\n\n\n# ⏰ Colors\n\n\n\n# 🐸 示例\n\nlicense标签\n\n![License](https://img.shields.io/badge/license-MIT-yellow) #静态badge图标\n![github license](https://img.shields.io/github/license/:user/:repo) #动态连接github仓库的图标\n\n\n1\n2\n\n\n\n\n\n\ntwitter标签\n\n![Twitter](https://img.shields.io/twitter/follow/:user? label=Follow) #动态连接twitter账户的图标\n![Twitter](https://img.shields.io/twitter/follow/:user? style=social) #采用社交图标\n\n\n1\n2\n\n\n![Twitter:y](https://img.shields.io/twitter/follow/:y? label=Follow)\n\n\n\nlanguage标签\n\n![Language](https://img.shields.io/badge/language-c++-brightgreen)  #静态图标\n\n\n1\n\n\n\n\nDocumentation标签\n\n![Documentation](https://img.shields.io/badge/documentation-yes-brightgreen)\n\n\n1\n\n\n\n\n\n# 📝License💖\n\n这个有关github上优美的readme编写介绍，由Hubery-Lee编写，喜欢❤️请收藏给一个赞吧👍\n\n[^1] :travis CI 等均是持续式集成开发工具，其中travis CI是用户量最多的。Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码"集成"到主干。持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。',normalizedContent:'[toc]\n\n\n# 如何在github上写出漂亮的readme.md\n\n\n# ✒️ 问题描述✏️\n\n\n# 😱别人写的readme文档竟如此漂亮🙀\n\n最近自己利用github page搭建自己的个人博客。以前采用hexo 搭建博客的缺点是，换一台电脑就不能用了，这是然人很烦恼的一件事。今天就去翻了翻大佬的github仓库，发现大佬一般是自己在github仓库的readme中做项目介绍。而且，大佬的项目介绍写的那个靓，如下图所示\n\n花花绿绿的标签和图标，是不是看起来很赏心悦目❤️\n\n\n# 😟再看看我写的readme文档😂\n\n就不过多评价了，看起来是如此的刻板，条条款款到还是挺清晰的，哈哈哈，就是缺少色彩感了。看着让人容易犯困\n\n\n# 🤔 那么别人是如何写出那么好看的readme文档的呢❓\n\n\n# 👍 readme.md的介绍👍\n\ngithub上的readme.md是采用markdown语言编写，markdown语言的特点是，其格式编写方便。并且兼容latex，latex是用于非常强大的排版能力与office并列，对于有编程基础的人并不陌生，其排版能力非常强大，在文本编辑过程中，可以不用鼠标。\n\n\n# 😙markdown的emoji编辑功能💋\n\nmarkdown除了类似latex的强大排版功能外，还具有emoji功能，那么它的表情功能怎么用呢？\n\n:emoji:\n\n\n1\n\n\nmarkdown及github支持的表情有哪些呢？可以通过以下两个网站查\n\n * webfx\n\n * emojipedia\n\n\n# 🐳shields.io 提供大量的标签 🐾\n\nreadme项目说明文档中，有如下图的标签\n\n这些标签是怎么来的呢？可以查阅shields.io进行引用，其中，build pass等标签，很多都需要采用travis ci 、appvexyor ci或 circle ci进行运行检测 [^1]。\n\n那么我们如何给自己的readme.md添加标签呢？查阅shields.io 网站各个图标怎么引用\n\n# 🍁 shields.io中有动态的图标\n\n如下需要相应的平台支持,图标显示格式可以查阅shields.io\n\ntwitter follow        /twitter/follow/:user?label=follow\ngithub follow         /github/followers/:user?label=follow\ngithub license        /github/license/:user/:repo\n\n\n1\n2\n3\n\n\n# 🚛 shield.io也有静态badge\n\n# 静态badge命名格式\n\nhttps://img.shields.io/badge/<label>-<message>-<color>\nor\nhttps://img.shields.io/static/v1?label=<label>&message=<message>&color=<color>\n\n\n1\n2\n3\n\n\n# ⏰ colors\n\n\n\n# 🐸 示例\n\nlicense标签\n\n![license](https://img.shields.io/badge/license-mit-yellow) #静态badge图标\n![github license](https://img.shields.io/github/license/:user/:repo) #动态连接github仓库的图标\n\n\n1\n2\n\n\n\n\n\n\ntwitter标签\n\n![twitter](https://img.shields.io/twitter/follow/:user? label=follow) #动态连接twitter账户的图标\n![twitter](https://img.shields.io/twitter/follow/:user? style=social) #采用社交图标\n\n\n1\n2\n\n\n![twitter:y](https://img.shields.io/twitter/follow/:y? label=follow)\n\n\n\nlanguage标签\n\n![language](https://img.shields.io/badge/language-c++-brightgreen)  #静态图标\n\n\n1\n\n\n\n\ndocumentation标签\n\n![documentation](https://img.shields.io/badge/documentation-yes-brightgreen)\n\n\n1\n\n\n\n\n\n# 📝license💖\n\n这个有关github上优美的readme编写介绍，由hubery-lee编写，喜欢❤️请收藏给一个赞吧👍\n\n[^1] :travis ci 等均是持续式集成开发工具，其中travis ci是用户量最多的。travis ci 提供的是持续集成服务（continuous integration，简称 ci）。它绑定 github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码"集成"到主干。持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。',charsets:{cjk:!0},lastUpdated:"2022/04/11, 12:35:43",lastUpdatedTimestamp:1649680543e3},{title:"windows中常用工具",frontmatter:{title:"windows中常用工具",date:"2022-04-01T16:29:21.000Z",permalink:"/pages/8599a54e76fc95e3",titleTag:"常用工具",categories:["工具","安装"],tags:["windows","install"]},regularPath:"/03.%E6%8A%80%E6%9C%AF/07.%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85.html",relativePath:"03.技术/07.一些工具安装.md",key:"v-185bd302",path:"/pages/8599a54e76fc95e3/",headers:[{level:3,title:"chocolatey 安装",slug:"chocolatey-安装",normalizedTitle:"chocolatey 安装",charIndex:2}],headersStr:"chocolatey 安装",content:"# chocolatey 安装\n\n----------------------------------------\n\n> 使用管理员权限模式打开Powdershell，粘贴下方安装代码，稍等片刻即可安装成功。\n\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\n\n\n1\n\n\n> 在PowerShell中执行命令后各种提示错误，因为在此系统上 禁止运行远程脚本。有关详细信息，请参阅microsoft\n\n> 输入以下命令将执行策略设置为允许签名的远程脚本就行了。\n\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned\n\n\n1\n\n\n> 还有一个错误是如下：\n\nUnable to unzip package using 7zip. Perhaps try setting $env:chocolateyUseWindowsCompression = 'true' and call install again. Error: 7-Zip signalled an unknown error (code )\n\n\n1\n\n\n# 关于解压失败的错误，这个似乎是无法解压的问题，根据错误提示执行如下命令，使Chocolatey使用系统的压缩功能。\n\n> 根据提示在powershell(管理员模式）下运行如下命令：\n\n$env:chocolateyUseWindowsCompression = 'true'\n\n\n1\n",normalizedContent:"# chocolatey 安装\n\n----------------------------------------\n\n> 使用管理员权限模式打开powdershell，粘贴下方安装代码，稍等片刻即可安装成功。\n\nset-executionpolicy bypass -scope process -force; [system.net.servicepointmanager]::securityprotocol = [system.net.servicepointmanager]::securityprotocol -bor 3072; iex ((new-object system.net.webclient).downloadstring('https://chocolatey.org/install.ps1'))\n\n\n1\n\n\n> 在powershell中执行命令后各种提示错误，因为在此系统上 禁止运行远程脚本。有关详细信息，请参阅microsoft\n\n> 输入以下命令将执行策略设置为允许签名的远程脚本就行了。\n\nset-executionpolicy -executionpolicy remotesigned\n\n\n1\n\n\n> 还有一个错误是如下：\n\nunable to unzip package using 7zip. perhaps try setting $env:chocolateyusewindowscompression = 'true' and call install again. error: 7-zip signalled an unknown error (code )\n\n\n1\n\n\n# 关于解压失败的错误，这个似乎是无法解压的问题，根据错误提示执行如下命令，使chocolatey使用系统的压缩功能。\n\n> 根据提示在powershell(管理员模式）下运行如下命令：\n\n$env:chocolateyusewindowscompression = 'true'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/11, 12:35:43",lastUpdatedTimestamp:1649680543e3},{title:"友情链接",frontmatter:{title:"友情链接",date:"2019-12-25T14:27:01.000Z",permalink:"/friends",article:!1,sidebar:!1},regularPath:"/03.%E6%8A%80%E6%9C%AF/99.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"03.技术/99.友情链接.md",key:"v-35a778e7",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:273}],headersStr:"友链申请",content:"程序员思语\n\n专注前端\n\n- name: 程序员思语\n  desc: 专注前端\n  avatar: https://avatars.githubusercontent.com/u/40508737?v=4 # 可选\n  link: https://gitluosiyu.github.io/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: xxx's blog # 昵称\n  desc: 前端/后端/运维/UI/其他。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/ # 头像\n  link: https://rwerplus.github.io/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",normalizedContent:"程序员思语\n\n专注前端\n\n- name: 程序员思语\n  desc: 专注前端\n  avatar: https://avatars.githubusercontent.com/u/40508737?v=4 # 可选\n  link: https://gitluosiyu.github.io/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: xxx's blog # 昵称\n  desc: 前端/后端/运维/ui/其他。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/ # 头像\n  link: https://rwerplus.github.io/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2022/11/09, 03:51:49",lastUpdatedTimestamp:1667965909e3},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-6bce7929",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🎨友链",slug:"🎨友链",normalizedTitle:"🎨友链",charIndex:91},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:383},{level:2,title:"🐛技能",slug:"🐛技能",normalizedTitle:"🐛技能",charIndex:405},{level:2,title:"⭐️公众号",slug:"⭐️公众号",normalizedTitle:"⭐️公众号",charIndex:486}],headersStr:"📚Blog 🎨友链 🐼Me 🐛技能 ⭐️公众号",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术\n\n提示\n\n文章内容仅是我个人的工作和学习的总结，资历尚浅，如有误还请指正。\n\n\n# 🎨友链\n\n程序员思语\n\n专注前端\n\n- name: 程序员思语\n  desc: 专注前端\n  avatar: https://avatars.githubusercontent.com/u/40508737?v=4 # 可选\n  link: https://github.com/codeluosiyu/codeluosiyu # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 🐼Me\n\n工作了三年的前端实习生\n\n\n# 🐛技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue、React 的拼写\n * 精通Ctrl+C 、 Ctrl+V\n * bug产出者\n\n\n# ⭐️公众号\n\n花椒和邻居 个人发布日常博客的方式之一",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术\n\n提示\n\n文章内容仅是我个人的工作和学习的总结，资历尚浅，如有误还请指正。\n\n\n# 🎨友链\n\n程序员思语\n\n专注前端\n\n- name: 程序员思语\n  desc: 专注前端\n  avatar: https://avatars.githubusercontent.com/u/40508737?v=4 # 可选\n  link: https://github.com/codeluosiyu/codeluosiyu # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 🐼me\n\n工作了三年的前端实习生\n\n\n# 🐛技能\n\n * 熟悉 javascript、html、css、vue、react 的拼写\n * 精通ctrl+c 、 ctrl+v\n * bug产出者\n\n\n# ⭐️公众号\n\n花椒和邻居 个人发布日常博客的方式之一",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2022-03-02T15:45:46.000Z",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.网站.md",key:"v-6b0ea974",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:165},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:373},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:604},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:631},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:719},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:783},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:860},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:924},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:380},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1175},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1224},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1296},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1357},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1520},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1780},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:902},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2117},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2177},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2207},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2268},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:572},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3369},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1994},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2447},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:3790},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1866},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4471},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:249},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3356},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4715},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5088},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2357},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5168},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5196}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n<li><a href="https://www.zaozao.run/" target="_blank" rel="noopener noreferrer">值得前端观看的前沿技术<OutboundLink/></a> by Scott</li>\n</ul>\n<div class="center-container"><p>关注公众号\n<img src="docs/.vuepress/public/img/images/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt=""></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n * 值得前端观看的前沿技术 by Scott\n\n关注公众号\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n * 关注科技动态\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n * jiumo 免费搜索全网电子书\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n * 值得前端观看的前沿技术 by scott\n\n关注公众号\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n * 关注科技动态\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n * jiumo 免费搜索全网电子书\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/12/01, 03:05:10",lastUpdatedTimestamp:166986391e4},{title:"常用的前端轮子",frontmatter:{title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"06.收藏夹/02.常用的前端轮子.md",key:"v-f0d21874",path:"/pages/47cf96/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:469}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",charsets:{cjk:!0},lastUpdated:"2022/02/21, 12:13:04",lastUpdatedTimestamp:1645445584e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-a1f06136",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/21, 12:13:04",lastUpdatedTimestamp:1645445584e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-aad24a76",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/21, 12:13:04",lastUpdatedTimestamp:1645445584e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-015f14e5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/21, 12:13:04",lastUpdatedTimestamp:1645445584e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-92bd0212",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"花椒和邻居",link:"https://github.com/rwerplus"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-8dbf1712",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/04/05, 05:42:45",lastUpdatedTimestamp:1649137365e3},{title:"Home",frontmatter:{home:!0,heroText:"花椒和邻居's Blog",tagline:"坚持创作，深入原理，抽象式的解决问题。一直在程序的道路上跌走。",bannerBg:"none"},regularPath:"/",relativePath:"index.md",key:"v-68b42d7e",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/30, 08:02:04",lastUpdatedTimestamp:1648627324e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"前端",link:"/web/",items:[]},{text:"开源",link:"/open/",items:[]},{text:"技术",link:"/technology/",items:[{text:"技术文档",link:"/pages/9a7ee40fc232253e/"},{text:"GitHub技巧",link:"/pages/4c778760be26d8b3/"},{text:"Nodejs",link:"/pages/117708e0af7f0bd9/"},{text:"博客搭建",link:"/pages/41f87d890d0a02af/"},{text:"Java程序员",link:"/pages/e58ecf/"}]},{text:"收藏",link:"/pages/beb6c0bd8a66cea6/"},{text:"关于",link:"/about/"},{text:"随笔",link:"/pages/f2e63f"}],sidebarDepth:2,logo:"/img/logo.png",repo:"rwerplus/rwerplus.github.io",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"去GitHub编辑",contentBgStyle:6,sidebar:{"/00.目录页/":[["01.前端.md","前端日常总结","/web"],["02.页面.md","开源","/open"],["03.技术.md","技术","/technology"],["04.更多.md","更多","/more"]],catalogue:{"前端":"/web","页面":"/open","技术":"/technology","更多":"/more"},"/01.前端/":[{title:"前端开发笔记",collapsable:!0,children:[["01.前端开发笔记/01.重识 HTML，掌握页面基本结构和加载过程.md","重识 HTML，掌握页面基本结构和加载过程","/pages/86005a/"],["01.前端开发笔记/02.CSS：页面布局的基本规则和方式.md","CSS：页面布局的基本规则和方式","/pages/21c2f2/"],["01.前端开发笔记/03.JavaScript 如何实现继承？.md","JavaScript 如何实现继承？","/pages/884d6e/"],["01.前端开发笔记/04.JavaScript 引擎如何执行 JavaScript 代码.md","JavaScript 引擎如何执行 JavaScript 代码？","/pages/13ef6c/"],["01.前端开发笔记/05.单线程的 JavaScript 如何管理任务.md","单线程的 JavaScript 如何管理任务？","/pages/c3f2e0/"],["01.前端开发笔记/06.一个网络请求是怎么进行的.md","一个网络请求是怎么进行的？","/pages/6fddea/"],["01.前端开发笔记/07.HTTP 协议和前端开发有什么关系.md","HTTP 协议和前端开发有什么关系？","/pages/595abe/"],["01.前端开发笔记/08.深入剖析浏览器中页面的渲染过程.md","深入剖析浏览器中页面的渲染过程","/pages/53ab0a/"],["01.前端开发笔记/09.改善编程思维：从事件驱动到数据驱动.md","改善编程思维：从事件驱动到数据驱动","/pages/b206ba/"],["01.前端开发笔记/10.掌握前端框架模板引擎的实现原理.md","掌握前端框架模板引擎的实现原理","/pages/ea57d2/"],["01.前端开发笔记/11.为什么小程序特立独行.md","为什么小程序特立独行","/pages/49a69e/"],["01.前端开发笔记/12.单页应用与前端路由库设计原理.md","单页应用与前端路由库设计原理","/pages/f761ed/"],["01.前端开发笔记/13.代码构建与 Webpack 必备技能.md","代码构建与 Webpack 必备技能","/pages/596343/"],["01.前端开发笔记/14.提升编程体验：组件化与模块化设计.md","提升编程体验：组件化与模块化设计","/pages/996215/"],["01.前端开发笔记/17.AngularReactVue 三大前端框架的设计特色.md","AngularReactVue 三大前端框架的设计特色","/pages/7d3a8a/"],["01.前端开发笔记/18.如何设计合适的状态管理方案.md","如何设计合适的状态管理方案","/pages/ddbbb3/"],["01.前端开发笔记/19.如何搭建前端监控体系为业务排忧解难.md","如何搭建前端监控体系为业务排忧解难","/pages/9c6643/"],["01.前端开发笔记/20.如何进行性能分析的自动化实现.md","如何进行性能分析的自动化实现","/pages/aeb6b9/"],["01.前端开发笔记/21.前端性能优化与解决方案.md","前端性能优化与解决方案","/pages/55cc33/"],["01.前端开发笔记/22.如何进行技术方案调研与设计.md","如何进行技术方案调研与设计","/pages/ee7a1a/"],["01.前端开发笔记/23.如何设计一个前端项目.md","如何设计一个前端项目","/pages/b1d475/"],["01.前端开发笔记/24.通过前端工程化提升团队开发效率.md","通过前端工程化提升团队开发效率","/pages/8a03a9/"],["01.前端开发笔记/25.大型前端项目的痛点和优化方案.md","大型前端项目的痛点和优化方案","/pages/e991d8/"],["01.前端开发笔记/26.如何通过前期准备和后期复盘让项目稳定上线.md","如何通过前期准备和后期复盘让项目稳定上线","/pages/75d6fd/"]]},{title:"JavaScript",collapsable:!0,children:[["25.JavaScript/01.33个非常实用的JavaScript一行代码.md","33个非常实用的JavaScript一行代码","/pages/a61298/"],["25.JavaScript/02.new命令原理.md","new命令原理","/pages/8143cc480faf9a11"],["25.JavaScript/03.ES5面向对象.md","ES5面向对象","/pages/b1af5cb8996363c5"],["25.JavaScript/04.ES6面向对象.md","ES6面向对象","/pages/1f4123be6f45abcd"],["25.JavaScript/10.Service Worker简述.md","Service Worker简述","/pages/dcebaf/","原创"],["25.JavaScript/50.js随机打乱数组.md","JS随机打乱数组","/pages/40b4db2d38ba85f2"],["25.JavaScript/70.将一维数组按指定长度转为二维数组.md","将一维数组按指定长度转为二维数组","/pages/f1acb712033ac8da"],["25.JavaScript/100.比typeof运算符更准确的类型判断.md","比typeof运算符更准确的类型判断","/pages/fd4a16d56b83c1bc"]]},{title:"3D地图相关",collapsable:!0,children:[["26.3D地图相关/01.Cesium入门.md","Cesium入门","/pages/8a70a2/","原创"],["26.3D地图相关/02.Cesium一般使用.md","Cesium一般使用","/pages/8382fc/","原创"]]}],"/02.页面/":[["00.DevUI.md","DevUI Design","/open/8599a5b876fc95e4","UI组件库"],["01.enalPro.md","vuecli template","/open/8599a5b876fc95e3","原创"]],"/03.技术/":[{title:"面试",collapsable:!0,children:[["00.面试/01.面试问题集锦.md","面试问题集锦","/pages/aea6571b7a8bae86"]]},{title:"技术文档",collapsable:!0,children:[["01.技术文档/01.Git使用手册.md","Git使用手册","/pages/9a7ee40fc232253e"],["01.技术文档/02.Markdown使用教程.md","Markdown使用教程","/pages/ad247c4332211551"],["01.技术文档/03.npm常用命令.md","npm常用命令","/pages/61f2f95fd7da14fd"],["01.技术文档/08.记一次nvm安装失败的过程.md","记一次nvm安装失败的过程","/pages/x123482"],["01.技术文档/10.npm packageJson属性详解.md","npm packageJson属性详解","/pages/dec4f3f00e71a312"],["01.技术文档/15.yaml语言教程.md","yaml语言教程","/pages/4e8444e2d534d14f"]]},{title:"GitHub技巧",collapsable:!0,children:[["02.GitHub技巧/01.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/pages/4c778760be26d8b3"],["02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md","GitHub Actions 实现自动部署静态博客","/pages/6b9d359ec5aa5019"],["02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md","GitHub Actions 定时运行代码：每天定时百度链接推送","/pages/f44d2f9ad04ab8d3"],["02.GitHub技巧/10.GitHub加速下载项目的方法.md","GitHub加速下载项目的方法","/pages/95331c6a9613faf8"]]},{title:"Nodejs",collapsable:!0,children:[["03.Nodejs/01.nodejs递归读取所有文件.md","nodejs递归读取所有文件","/pages/117708e0af7f0bd9"]]},{title:"博客搭建",collapsable:!0,children:[["04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md","解决百度无法收录搭建在GitHub上的个人博客的问题","/pages/41f87d890d0a02af"],["04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md","使用Gitalk实现静态博客无后台评论系统","/pages/1da0bf9a988eafe5"],["04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md","GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床","/pages/a5f73af5185fdf0a"],["04.博客搭建/10.vdoing主题效果图.md","vdoing主题效果图","/pages/d557b9a89a215d2e"]]},{title:"java",collapsable:!0,children:[["05.java/052.java.md","java","/pages/e58ecf/"]]},["06.编写好看的markdown文档.md","如何在github上写出漂亮的readme.md","/pages/8599a5b876fc95u7","常用工具"],["07.一些工具安装.md","windows中常用工具","/pages/8599a54e76fc95e3","常用工具"],["99.友情链接.md","友情链接","/friends"]],"/05.关于/":[["01.关于.md","关于","/about"]],"/06.收藏夹/":[["01.网站.md","网站","/pages/beb6c0bd8a66cea6"],["02.常用的前端轮子.md","常用的前端轮子","/pages/47cf96/"]]},author:{name:"花椒和邻居",link:"https://github.com/rwerplus"},blogger:{avatar:"/img/ava.2gamq0p5pj8k.webp",name:"花椒和邻居",slogan:"工作了三年半的前端实习生"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:localfeng@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/rwerplus"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=88954294"}]},footer:{createYear:2022,copyrightInfo:'花椒和邻居 | <a href="https://github.com/rwerplus/rwerplus.github.io/blob/master/LICENSE" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:'<div style="padding: 0.95rem">\n    <p style="\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    ">公众号</p>\n    <img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000005&size=102&__biz=MzAwMDIwMDg5Ng==&mid=2247483749&idx=1&sn=776cecde93319398dbd84c0e246aaca9&send_time=  style="width:100%;" />\n    <p>\n    </br></br>\n    关注公众号，有问必回\n    </p>\n    </div>'}},locales:{"/":{lang:"zh-CN",title:"花椒和邻居's Blog",description:"web前端技术博客,花椒和邻居sBlog,持续专注web前端学习与总结。Cesium,markdown,JavaScript,js,ES6,TypeScript,vue,React,css3,html5,Node,git,github等技术文章。",path:"/"}}};var xl=t(96),_l=t(97),kl=t(11);var jl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(kl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(kl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(kl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:i}}=n[r];"array"===Object(kl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(kl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Wt.component(xl.default),Wt.component(_l.default);function Sl(n){return n.toString().padStart(2,"0")}t(245);Wt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,411))),Wt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,96))),Wt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,97)));t(246),t(247);var El=t(95),Tl=t.n(El),Cl=t(27);let Al,Il;var Pl;"valine"===(Pl="gitalk")?t.e(76).then(t.t.bind(null,337,7)).then(n=>Il=n.default):"gitalk"===Pl&&Promise.all([t.e(0),t.e(75)]).then(t.t.bind(null,338,7)).then(()=>t.e(74).then(t.t.bind(null,339,7))).then(n=>Al=n.default);function Ol(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=Tl.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Cl.name}@v${Cl.version}:`,Cl.homepage);const Dl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Al(Ol({clientID:"5caec8f87d3c2c9c4c2a",clientSecret:"0d25fa4927dd65f87b29b546c81eb639d3b624c5",repo:"rwerplus.github.io",owner:"rwerplus",admin:["rwerplus"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Il({...Ol({clientID:"5caec8f87d3c2c9c4c2a",clientSecret:"0d25fa4927dd65f87b29b546c81eb639d3b624c5",repo:"rwerplus.github.io",owner:"rwerplus",admin:["rwerplus"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Bl="vuepress-plugin-comment";let Ml=null;function zl(n){return Dl.gitalk.clear(Bl)}function Ll(n){return!1!==n.comment&&!1!==n.comments}function Rl(n){clearTimeout(Ml);if(document.querySelector("main.page"))return Dl.gitalk.render(n,Bl);Ml=setTimeout(()=>Rl(n),200)}var Hl={mounted(){Ml=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};zl()&&Ll(n)&&Rl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};zl()&&Ll(t)&&Rl(t)})}},Jl=Object(vl.a)(Hl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Fl=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Sl(n.getUTCMonth()+1)}-${Sl(n.getUTCDate())} ${Sl(n.getUTCHours())}:${Sl(n.getUTCMinutes())}:${Sl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(jl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",a.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var a=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<a.length;t++)a[t].alpha<=0?(e.body.removeChild(a[t].el),a.splice(t,1)):(a[t].y--,a[t].scale+=.004,a[t].alpha-=.013,a[t].el.style.cssText="left:"+a[t].x+"px;top:"+a[t].y+"px;opacity:"+a[t].alpha+";transform:scale("+a[t].scale+","+a[t].scale+") rotate(45deg);background:"+a[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Jl)}],Ul=["Comment"];class $l extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign($l.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Nl={install(n){const e=new $l;n.$vuepress=e,n.prototype.$vuepress=e}};function Gl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Wl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Wt.component(e)||Wt.component(e,os(e)),Wt.component(e)?n(e):n("")}},Vl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},ql={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Xl=(t(253),t(254),Object(vl.a)(ql,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Kl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(No),Wt.use(Nl),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},wl)),Wt.component("Content",Wl),Wt.component("ContentSlotsDistributor",Vl),Wt.component("OutboundLink",Xl),Wt.component("ClientOnly",Kl),Wt.component("Layout",ss("Layout")),Wt.component("NotFound",ss("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"993b800"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:wl.routerBase||wl.base,t=new No({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Gl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Gl(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Gl(n,a)?r(a):Gl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Fl.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:wl,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ul.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);