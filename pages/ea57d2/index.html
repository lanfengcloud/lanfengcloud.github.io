<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>掌握前端框架模板引擎的实现原理 | 花椒和邻居&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/87452.png">
    <meta name="description" content="web前端技术博客,花椒和邻居sBlog,持续专注web前端学习与总结。Cesium,markdown,JavaScript,js,ES6,TypeScript,vue,React,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.11b57309.css" as="style"><link rel="preload" href="/assets/js/app.d13a64a1.js" as="script"><link rel="preload" href="/assets/js/2.4651773a.js" as="script"><link rel="preload" href="/assets/js/19.1d3312d9.js" as="script"><link rel="prefetch" href="/assets/js/10.ce591752.js"><link rel="prefetch" href="/assets/js/11.b3b332f5.js"><link rel="prefetch" href="/assets/js/12.f5a1836d.js"><link rel="prefetch" href="/assets/js/13.7ee8c39c.js"><link rel="prefetch" href="/assets/js/14.286a6768.js"><link rel="prefetch" href="/assets/js/15.2f79ae5a.js"><link rel="prefetch" href="/assets/js/16.1ccfaf3d.js"><link rel="prefetch" href="/assets/js/17.b9644e7b.js"><link rel="prefetch" href="/assets/js/18.02c9e60c.js"><link rel="prefetch" href="/assets/js/20.33a2e48f.js"><link rel="prefetch" href="/assets/js/21.cbd55d73.js"><link rel="prefetch" href="/assets/js/22.17d94390.js"><link rel="prefetch" href="/assets/js/23.71f3318d.js"><link rel="prefetch" href="/assets/js/24.52e90323.js"><link rel="prefetch" href="/assets/js/25.b502869e.js"><link rel="prefetch" href="/assets/js/26.6f44735e.js"><link rel="prefetch" href="/assets/js/27.1d65aca3.js"><link rel="prefetch" href="/assets/js/28.98366502.js"><link rel="prefetch" href="/assets/js/29.aeaeb5e3.js"><link rel="prefetch" href="/assets/js/3.c999fa3c.js"><link rel="prefetch" href="/assets/js/30.b3434784.js"><link rel="prefetch" href="/assets/js/31.49829b57.js"><link rel="prefetch" href="/assets/js/32.31faca0f.js"><link rel="prefetch" href="/assets/js/33.c4e8045e.js"><link rel="prefetch" href="/assets/js/34.cbb06c3e.js"><link rel="prefetch" href="/assets/js/35.7f222782.js"><link rel="prefetch" href="/assets/js/36.c45f8fa8.js"><link rel="prefetch" href="/assets/js/37.0439c9ea.js"><link rel="prefetch" href="/assets/js/38.b953313a.js"><link rel="prefetch" href="/assets/js/39.971ddf21.js"><link rel="prefetch" href="/assets/js/4.d82326e8.js"><link rel="prefetch" href="/assets/js/40.b554f955.js"><link rel="prefetch" href="/assets/js/41.51a76d90.js"><link rel="prefetch" href="/assets/js/42.60fdf685.js"><link rel="prefetch" href="/assets/js/43.cc26bde1.js"><link rel="prefetch" href="/assets/js/44.35df12ae.js"><link rel="prefetch" href="/assets/js/45.e7b9d5a1.js"><link rel="prefetch" href="/assets/js/46.09c1d0ac.js"><link rel="prefetch" href="/assets/js/47.f09174e3.js"><link rel="prefetch" href="/assets/js/48.3a7f2685.js"><link rel="prefetch" href="/assets/js/49.f887c293.js"><link rel="prefetch" href="/assets/js/5.1a2700dd.js"><link rel="prefetch" href="/assets/js/50.b2e3e2b1.js"><link rel="prefetch" href="/assets/js/51.608586ee.js"><link rel="prefetch" href="/assets/js/52.7529742c.js"><link rel="prefetch" href="/assets/js/53.6f679505.js"><link rel="prefetch" href="/assets/js/54.cd2ced6c.js"><link rel="prefetch" href="/assets/js/55.fa0ac247.js"><link rel="prefetch" href="/assets/js/56.112e5af2.js"><link rel="prefetch" href="/assets/js/57.8f8f1126.js"><link rel="prefetch" href="/assets/js/58.c17061aa.js"><link rel="prefetch" href="/assets/js/59.e666b783.js"><link rel="prefetch" href="/assets/js/6.c4610236.js"><link rel="prefetch" href="/assets/js/60.314af2d6.js"><link rel="prefetch" href="/assets/js/61.3862b3af.js"><link rel="prefetch" href="/assets/js/62.a4cccce2.js"><link rel="prefetch" href="/assets/js/63.dfc009ae.js"><link rel="prefetch" href="/assets/js/64.8f216c0d.js"><link rel="prefetch" href="/assets/js/65.cb92cce0.js"><link rel="prefetch" href="/assets/js/66.7da08f3c.js"><link rel="prefetch" href="/assets/js/67.8f5d2a42.js"><link rel="prefetch" href="/assets/js/68.6eea4628.js"><link rel="prefetch" href="/assets/js/69.b9654bda.js"><link rel="prefetch" href="/assets/js/7.a5bff2b9.js"><link rel="prefetch" href="/assets/js/70.97bf8b83.js"><link rel="prefetch" href="/assets/js/71.ba0a87e1.js"><link rel="prefetch" href="/assets/js/72.84b055cd.js"><link rel="prefetch" href="/assets/js/73.7ab818f4.js"><link rel="prefetch" href="/assets/js/74.2fac3511.js"><link rel="prefetch" href="/assets/js/75.688b385a.js"><link rel="prefetch" href="/assets/js/76.e5a15c1b.js"><link rel="prefetch" href="/assets/js/8.4ac93032.js"><link rel="prefetch" href="/assets/js/9.d31b45ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.11b57309.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="花椒和邻居's Blog" class="logo"> <span class="site-name can-hide">花椒和邻居's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/open/" class="nav-link">开源</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/e58ecf/" class="nav-link">Java程序员</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/f2e63f.html" class="nav-link">随笔</a></div> <a href="https://github.com/rwerplus/rwerplus.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/ava.2gamq0p5pj8k.webp"> <div class="blogger-info"><h3>花椒和邻居</h3> <span>工作了三年半的前端实习生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/open/" class="nav-link">开源</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/e58ecf/" class="nav-link">Java程序员</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/f2e63f.html" class="nav-link">随笔</a></div> <a href="https://github.com/rwerplus/rwerplus.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端开发笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/86005a/" class="sidebar-link">重识 HTML，掌握页面基本结构和加载过程</a></li><li><a href="/pages/21c2f2/" class="sidebar-link">CSS：页面布局的基本规则和方式</a></li><li><a href="/pages/884d6e/" class="sidebar-link">JavaScript 如何实现继承？</a></li><li><a href="/pages/13ef6c/" class="sidebar-link">JavaScript 引擎如何执行 JavaScript 代码？</a></li><li><a href="/pages/c3f2e0/" class="sidebar-link">单线程的 JavaScript 如何管理任务？</a></li><li><a href="/pages/6fddea/" class="sidebar-link">一个网络请求是怎么进行的？</a></li><li><a href="/pages/595abe/" class="sidebar-link">HTTP 协议和前端开发有什么关系？</a></li><li><a href="/pages/53ab0a/" class="sidebar-link">深入剖析浏览器中页面的渲染过程</a></li><li><a href="/pages/b206ba/" class="sidebar-link">改善编程思维：从事件驱动到数据驱动</a></li><li><a href="/pages/ea57d2/" aria-current="page" class="active sidebar-link">掌握前端框架模板引擎的实现原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/49a69e/" class="sidebar-link">为什么小程序特立独行</a></li><li><a href="/pages/f761ed/" class="sidebar-link">单页应用与前端路由库设计原理</a></li><li><a href="/pages/596343/" class="sidebar-link">代码构建与 Webpack 必备技能</a></li><li><a href="/pages/996215/" class="sidebar-link">提升编程体验：组件化与模块化设计</a></li><li><a href="/pages/7d3a8a/" class="sidebar-link">AngularReactVue 三大前端框架的设计特色</a></li><li><a href="/pages/ddbbb3/" class="sidebar-link">如何设计合适的状态管理方案</a></li><li><a href="/pages/9c6643/" class="sidebar-link">如何搭建前端监控体系为业务排忧解难</a></li><li><a href="/pages/aeb6b9/" class="sidebar-link">如何进行性能分析的自动化实现</a></li><li><a href="/pages/55cc33/" class="sidebar-link">前端性能优化与解决方案</a></li><li><a href="/pages/ee7a1a/" class="sidebar-link">如何进行技术方案调研与设计</a></li><li><a href="/pages/b1d475/" class="sidebar-link">如何设计一个前端项目</a></li><li><a href="/pages/8a03a9/" class="sidebar-link">通过前端工程化提升团队开发效率</a></li><li><a href="/pages/e991d8/" class="sidebar-link">大型前端项目的痛点和优化方案</a></li><li><a href="/pages/75d6fd/" class="sidebar-link">如何通过前期准备和后期复盘让项目稳定上线</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3D地图相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/web/#前端" data-v-06225672>前端</a></li><li data-v-06225672><a href="/web/#前端开发笔记" data-v-06225672>前端开发笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/rwerplus" target="_blank" title="作者" class="beLink" data-v-06225672>花椒和邻居</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-04-14</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">掌握前端框架模板引擎的实现原理<!----></h1>  <div class="theme-vdoing-content content__default"><p data-nodeid="68536">如今说起前端开发，基本上都离不开前端框架。随着前端技术不断迭代，前端框架相关的文档和社区日益完善，前端入门也越来越简单了。我们可以快速上手一些工具和框架，但常常会忽略其中的设计和原理。</p> <p data-nodeid="68537">对框架和工具的了解不够深入，会导致我们在遇到一些偏门的问题时容易找不到方向，也不利于个人的知识领域扩展，不能很好地进行技术选型。</p> <p data-nodeid="68538">今天，我会带你了解前端框架为什么会这么热门，以及介绍前端框架的核心能力——模板引擎的实现原理。在讲解的过程中，一些代码会以 Vue.js 作为示例。</p> <p data-nodeid="68539">我们先来看一下，为什么要使用前端框架。</p> <h3 data-nodeid="68540">为什么要使用前端框架</h3> <p data-nodeid="68541">一个工具被大多数人使用、成为热门，离不开相关技术发展的历史进程。了解这些工具和框架出现的原因，我们可以及时掌握技术的发展方向，保持对技术的敏感度、更新自身的认知，这些都会成为我们自身的竞争力。</p> <p data-nodeid="68542">前端框架也一样。在前端框架出现之前，jQuery 也是前端开发必备的工具库，大多数项目中都会使用。短短几年间，前端开发却变得无法离开前端框架，这中间到底发生了什么呢？</p> <h4 data-nodeid="68543">前端的飞速发展</h4> <p data-nodeid="68544">曾几何时，一提到前端，大家都会想到 jQuery。那是 jQuery 一把梭的年代，不管前端后台都会用 jQuery 完成页面开发。那时候前端开发的工作倾向于切图和重构，重页面样式而轻逻辑，工作内容常常是拼接 JSP 模板、拼 PHP 模板以及调节浏览器兼容。</p> <p data-nodeid="68545">为什么 jQuery 那么热门呢？除了超方便的 Sizzle 引擎元素选择器、简单易用的异步请求库 ajax，还有链式调用的编程方式使得代码如行云流水般流畅。jQuery 提供的便捷几乎满足了当时前端的大部分工作（所以说 jQuery 一把梭不是毫无道理的）。</p> <p data-nodeid="68546">接下来短短的几年时间，前端经历了特别多的改变。随着 Node.js 的出现、NPM 包管理的完善，再加上热闹的开源社区，前端领域获得了千千万万开发者的支援。从页面开发到工具库开发、框架开发、脚本开发、到服务端开发，单线程的 JavaScript 正在不断进行自我革新，从而将领域不断拓宽，形成了如今你所能看到的、获得赋能的前端。</p> <p data-nodeid="68547">那么，是什么原因导致了 jQuery 被逐渐冷落，前端框架站上了舞台中央呢？其中的原因有很多，包括业务场景的进化、技术的更新迭代，比如前端应用逐渐复杂、单页应用的出现、前端模块化等。</p> <h4 data-nodeid="68548">前端框架的出现</h4> <p data-nodeid="68549">前面第 8 讲中，我们知道了浏览器是如何渲染页面的。从用户的角度来看，浏览器生成了最终的渲染树，并通过光栅化来将页面显示在屏幕上，页面渲染的工作就完成了。</p> <p data-nodeid="68550">实际上，浏览器页面更多的不只是静态页面的渲染，还包括点击、拖拽等事件操作以及接口请求、数据渲染到页面等动态的交互逻辑，因此我们还常常需要更新页面的内容。</p> <p data-nodeid="68551">要理解前端框架为什么如此重要，需要先看看在框架出现前，前端开发是如何实现和用户进行交互的。</p> <p data-nodeid="68552">这个过程跟上一讲事件驱动的内容很相似，以一个常见的表单提交作为例子，会包括编写静态页面、给对应的元素绑定对应的事件、事件触发时更新页面内容等步骤，这是最简单的页面交互。</p> <p data-nodeid="68553">对于更新页面内容这个步骤，如果我们页面中有很多的内容需要更新，光拼接字符串我们可能就有一大堆代码。</p> <blockquote data-nodeid="68554"><p data-nodeid="68555">以下的例子，为了不占用大量的篇幅，使用了 jQuery，否则代码量会更多。</p></blockquote> <p data-nodeid="68556">举个例子，抢答活动中常常会出现题目和多个答案进行选择，我们现在需要开发一个管理端，对这些抢答卡片进行管理。假设一个问题会包括两个答案，我们可以通过新增卡片的方式来添加一套问答，编辑卡片的过程包括这些步骤。</p> <p data-nodeid="69931"><strong data-nodeid="69937">1</strong>. 新增一个卡片时，通过插入 DOM 节点的方式添加卡片样式。</p> <pre data-nodeid="69932" class="lang-java"><code data-language="java"><span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 用来新增一个卡片，卡片内需要填写一些内容</span>
<span class="hljs-function">function <span class="hljs-title">addCard</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 获取一个id为the-dom的元素</span>
  <span class="hljs-keyword">var</span> body = $(<span class="hljs-string">&quot;#the-dom&quot;</span>);
  <span class="hljs-comment">// 从该元素内获取class为the-class的元素</span>
  <span class="hljs-keyword">var</span> addDom = body.find(<span class="hljs-string">&quot;.the-class&quot;</span>);
  <span class="hljs-comment">// 在the-class元素前方插入一个div</span>
  addDom.before(<span class="hljs-string">'&lt;div class=&quot;col-lg-4&quot; data-index=&quot;'</span> + index + <span class="hljs-string">'&quot;&gt;&lt;/div&gt;'</span>);
  <span class="hljs-comment">// 同时保存下来该DOM节点，方便更新内容</span>
  <span class="hljs-keyword">var</span> theDom = body.find(<span class="hljs-string">'[data-index=&quot;'</span> + index + <span class="hljs-string">'&quot;]'</span>);
  theDom.innerHTML(
    `&lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control question&quot;</span> placeholder=<span class="hljs-string">&quot;你的问题&quot;</span>&gt;
         &lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control option-a&quot;</span> placeholder=<span class="hljs-string">&quot;回答1&quot;</span>&gt;
         &lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control option-b&quot;</span> placeholder=<span class="hljs-string">&quot;回答2&quot;</span>&gt;
        `
  );
  <span class="hljs-comment">// 做完上面这堆之后index自增</span>
  index++;
  <span class="hljs-keyword">return</span> theDom;
}
</code></pre> <p data-nodeid="70496"><strong data-nodeid="70502">2</strong>. 卡片内编辑题目和答案时，会有字数限制（使用 jQuery 对输入框的输入事件进行监听，并限制输入内容）。</p> <pre data-nodeid="70497" class="lang-java"><code data-language="java"><span class="hljs-comment">// theDom使用上面代码保存下来的引用</span>
<span class="hljs-comment">// 问题绑定值</span>
theDom
  .on(<span class="hljs-string">&quot;keyup&quot;</span>, <span class="hljs-string">&quot;.question&quot;</span>, function (ev) {
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);
  })
  <span class="hljs-comment">// 答案a绑定值</span>
  .on(<span class="hljs-string">&quot;keyup&quot;</span>, <span class="hljs-string">&quot;.option-a&quot;</span>, function (ev) {
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  })
  <span class="hljs-comment">// 答案b绑定值</span>
  .on(<span class="hljs-string">&quot;keyup&quot;</span>, <span class="hljs-string">&quot;.option-b&quot;</span>, function (ev) {
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  });
</code></pre> <p data-nodeid="71065" class="te-preview-highlight"><strong data-nodeid="71071">3</strong>. 获取输入框内的内容（使用 jQuery 选择元素并获取内容），用于提交到后台。</p> <pre data-nodeid="71066" class="lang-java"><code data-language="java"><span class="hljs-comment">// 获取卡片的输入值</span>
<span class="hljs-comment">// theDom 使用上面代码保存下来的引用</span>
<span class="hljs-function">function <span class="hljs-title">getCardValue</span><span class="hljs-params">(index)</span> </span>{
  <span class="hljs-keyword">var</span> body = $(<span class="hljs-string">&quot;#the-dom&quot;</span>);
  <span class="hljs-keyword">var</span> theDom = body.find(<span class="hljs-string">'[data-index=&quot;'</span> + index + <span class="hljs-string">'&quot;]'</span>);
  <span class="hljs-keyword">var</span> questionName = theDom.find(<span class="hljs-string">&quot;.question&quot;</span>).val();
  <span class="hljs-keyword">var</span> optionA = theDom.find(<span class="hljs-string">&quot;.option-a&quot;</span>).val();
  <span class="hljs-keyword">var</span> optionB = theDom.find(<span class="hljs-string">&quot;.option-b&quot;</span>).val();
  <span class="hljs-keyword">return</span> { questionName, optionA, optionB };
}
</code></pre> <p data-nodeid="68569">可以看到，仅是实现一个问答卡片的编辑就需要编写不少的代码，大多数代码内容都是为了拼接 HTML 内容、获取 DOM 节点、操作 DOM 节点。<br>
这些代码逻辑，如果我们使用 Vue 来实现，只需要这么写：</p> <pre data-nodeid="68570" class="lang-java"><code data-language="java">&lt;template&gt;
  &lt;div v-for=&quot;card in cards&quot;&gt;
    &lt;input
      type=&quot;text&quot;
      class=&quot;form-control question&quot;
      v-model=&quot;card.questionName&quot;
      placeholder=&quot;你的问题&quot;
    /&gt;
    &lt;input
      type=&quot;text&quot;
      class=&quot;form-control option-a&quot;
      v-model=&quot;card.optionA&quot;
      placeholder=&quot;回答1&quot;
    /&gt;
    &lt;input
      type=&quot;text&quot;
      class=&quot;form-control option-b&quot;
      v-model=&quot;card.optionB&quot;
      placeholder=&quot;回答2&quot;
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: &quot;Cards&quot;,
    data() {
      return {
        cards: [],
      };
    },
    methods: {
      // 添加一个卡片
      addCard() {
        this.cards.push({
          questionName: &quot;&quot;,
          optionA: &quot;&quot;,
          optionB: &quot;&quot;,
        });
      },
      // 获取卡片的输入值
      getCardValue(index) {
        return this.cards[index];
      },
    },
  };
&lt;/script&gt;
</code></pre> <p data-nodeid="68571">可见，前端框架提供了便利的数据绑定、界面更新、事件监听等 API，我们不需要再手动更新前端页面的内容、维护一大堆的 HTML 和变量拼接的动态内容了。<br>
使用前端框架对开发效率有很大的提升，同时也在一定程度上避免了代码可读性、可维护性等问题。这也是为什么前端框架这么热门，大家都会使用它来进行开发的原因。</p> <p data-nodeid="68572">那么，前端框架是怎么做到这些的呢？要实现这些能力，离不开其中的模板引擎。</p> <h3 data-nodeid="68573">前端框架的核心——模板引擎</h3> <p data-nodeid="68574">当用户对页面进行操作、页面内容更新，我们需要实现的功能流程包括：</p> <ol data-nodeid="68575"><li data-nodeid="68576"><p data-nodeid="68577">监听操作；</p></li> <li data-nodeid="68578"><p data-nodeid="68579">获取数据变量；</p></li> <li data-nodeid="68580"><p data-nodeid="68581">使用数据变量拼接成 HTML 模板；</p></li> <li data-nodeid="68582"><p data-nodeid="68583">将 HTML 内容塞到页面对应的地方；</p></li> <li data-nodeid="68584"><p data-nodeid="68585">将 HTML 片段内需要监听的点击等事件进行绑定。</p></li></ol> <p data-nodeid="68586">可以看到，实现逻辑会比较复杂和烦琐。</p> <p data-nodeid="68587">如果使用前端框架，我们可以：</p> <ul data-nodeid="68588"><li data-nodeid="68589"><p data-nodeid="68590">使用将数据变量绑定到 HTML 模板的方式，来控制展示的内容；</p></li> <li data-nodeid="68591"><p data-nodeid="68592">配合一些条件判断、条件循环等逻辑，控制交互的具体逻辑；</p></li> <li data-nodeid="68593"><p data-nodeid="68594">通过改变数据变量，框架会自动更新页面内容。</p></li></ul> <p data-nodeid="68595">这样，我们可以快速高效地完成功能开发，代码的可读性和维护性都远胜于纯手工实现。</p> <p data-nodeid="68596">如果使用数据驱动的方式，还可以通过让逻辑与 UI 解耦的方式，提升代码的可维护性。其中的数据绑定、事件绑定等功能，前端框架是依赖模板引擎的方式来实现的。</p> <p data-nodeid="68597">以 Vue 为例子，对于开发者编写的 Vue 代码，Vue 会将其进行以下处理从而渲染到页面中：</p> <ol data-nodeid="68598"><li data-nodeid="68599"><p data-nodeid="68600">解析语法生成 AST 对象；</p></li> <li data-nodeid="68601"><p data-nodeid="68602">根据生成的 AST 对象，完成<code data-backticks="1" data-nodeid="68729">data</code>数据初始化；</p></li> <li data-nodeid="68603"><p data-nodeid="68604">根据 AST 对象和<code data-backticks="1" data-nodeid="68732">data</code>数据绑定情况，生成虚拟 DOM 对象；</p></li> <li data-nodeid="68605"><p data-nodeid="68606">将虚拟 DOM 对象生成真正的 DOM 元素插入到页面中，此时页面会被渲染。</p></li></ol> <p data-nodeid="68607">模板引擎将模板语法进行解析，分别生成 HTML DOM，使用像 HTML 拼接的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 DOM 的设计，可以最大化地提升页面的性能。</p> <p data-nodeid="68608">这些便是模板引擎主要的工作，我们来分别看一下。</p> <h4 data-nodeid="68609">解析语法生成 AST 对象</h4> <p data-nodeid="68610">抽象语法树（Abstract Syntax Tree）也称为 AST 语法树，指的是源代码语法所对应的树状结构。其实我们的 DOM 结构树，也是 AST 的一种，浏览器会对 HTML DOM 进行语法解析、并生成最终的页面。</p> <p data-nodeid="68611">生成 AST 的过程涉及编译器的原理，一般经过以下过程。</p> <ol data-nodeid="68612"><li data-nodeid="68613"><p data-nodeid="68614">语法分析。模板引擎需要在这个过程中识别出特定的语法，比如<code data-backticks="1" data-nodeid="68741">v-if</code>/<code data-backticks="1" data-nodeid="68743">v-for</code>这样的指令，或是<code data-backticks="1" data-nodeid="68745">&lt;MyCustomComponent&gt;</code>这样的自定义 DOM 标签，还有<code data-backticks="1" data-nodeid="68747">@click</code>/<code data-backticks="1" data-nodeid="68749">:props</code>这样的简化绑定语法等。</p></li> <li data-nodeid="68615"><p data-nodeid="68616">语义分析。这个过程会审查源程序有无语义错误，为代码生成阶段收集类型信息，一般类型检查也会在这个过程中进行。例如我们绑定了某个不存在的变量或者事件，又或者是使用了某个未定义的自定义组件等，都会在这个阶段进行报错提示。</p></li> <li data-nodeid="68617"><p data-nodeid="68618">生成 AST 对象。</p></li></ol> <p data-nodeid="68619">以 Vue 为例，生成 AST 的过程包括 HTML 模板解析、元素检查和预处理：</p> <pre data-nodeid="68620" class="lang-java"><code data-language="java"><span class="hljs-comment">/**
 *  将HTML编译成AST对象
 *  该代码片段基于Vue2.x版本
 */</span>
<span class="hljs-function">export function <span class="hljs-title">parse</span><span class="hljs-params">(
  template: string,
  options: CompilerOptions
)</span>: ASTElement | <span class="hljs-keyword">void</span> </span>{
  <span class="hljs-comment">// 返回AST对象</span>
  <span class="hljs-comment">// 篇幅原因，一些前置定义省略</span>
  <span class="hljs-comment">// 此处开始解析HTML模板</span>
  parseHTML(template, {
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start(tag, attrs, unary) {
      <span class="hljs-comment">// 一些前置检查和设置、兼容处理此处省略</span>
      <span class="hljs-comment">// 此处定义了初始化的元素AST对象</span>
      <span class="hljs-keyword">const</span> element: ASTElement = {
        type: <span class="hljs-number">1</span>,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: [],
      };
      <span class="hljs-comment">// 检查元素标签是否合法（不是保留命名）</span>
      <span class="hljs-keyword">if</span> (isForbiddenTag(element) &amp;&amp; !isServerRendering()) {
        element.forbidden = <span class="hljs-keyword">true</span>;
        process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span> &amp;&amp;
          warn(
            <span class="hljs-string">&quot;Templates should only be responsible for mapping the state to the &quot;</span> +
              <span class="hljs-string">&quot;UI. Avoid placing tags with side-effects in your templates, such as &quot;</span> +
              `&lt;${tag}&gt;` +
              <span class="hljs-string">&quot;, as they will not be parsed.&quot;</span>
          );
      }
      <span class="hljs-comment">// 执行一些前置的元素预处理</span>
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; preTransforms.length; i++) {
        preTransforms[i](element, options);
      }
      <span class="hljs-comment">// 是否原生元素</span>
      <span class="hljs-keyword">if</span> (inVPre) {
        <span class="hljs-comment">// 处理元素的一些属性</span>
        processRawAttrs(element);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 处理指令，此处包括v-for/v-if/v-once/key等等</span>
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element); <span class="hljs-comment">// 删除结构属性</span>
        <span class="hljs-comment">// 确定这是否是一个简单的元素</span>
        element.plain = !element.key &amp;&amp; !attrs.length;
        <span class="hljs-comment">// 处理ref/slot/component等属性</span>
        processRef(element);
        processSlot(element);
        processComponent(element);
        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; transforms.length; i++) {
          transforms[i](element, options);
        }
        processAttrs(element);
      }
      <span class="hljs-comment">// 后面还有一些父子节点等处理，此处省略</span>
    },
    <span class="hljs-comment">// 其他省略</span>
  });
  <span class="hljs-keyword">return</span> root;
}
</code></pre> <p data-nodeid="68621">到这里，Vue 将开发者的模板代码解析成 AST 对象，我们来看看这样的 AST 对象是怎样生成 DOM 元素的。</p> <h4 data-nodeid="68622">AST 对象生成 DOM 元素</h4> <p data-nodeid="68623">前面提到，在编译解析和渲染过程中，模板引擎会识别和解析模板语法语义、生成 AST 对象，最后根据 AST 对象会生成最终的 DOM 元素。</p> <p data-nodeid="68624">举个例子，我们写了以下这么一段 HTML 模板：</p> <pre data-nodeid="68625" class="lang-java"><code data-language="java">&lt;div&gt;
  &lt;a&gt;123&lt;/a&gt;
  &lt;p&gt;456&lt;span&gt;789&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre> <p data-nodeid="68626">模板引擎可以在语法分析、语义分析等步骤后，得到这样的一个 AST 对象：</p> <pre data-nodeid="68627" class="lang-java"><code data-language="java">thisDiv = {
  dom: {
    type: <span class="hljs-string">&quot;dom&quot;</span>,
    ele: <span class="hljs-string">&quot;div&quot;</span>,
    nodeIndex: <span class="hljs-number">0</span>,
    children: [
      {
        type: <span class="hljs-string">&quot;dom&quot;</span>,
        ele: <span class="hljs-string">&quot;a&quot;</span>,
        nodeIndex: <span class="hljs-number">1</span>,
        children: [{ type: <span class="hljs-string">&quot;text&quot;</span>, value: <span class="hljs-string">&quot;123&quot;</span> }],
      },
      {
        type: <span class="hljs-string">&quot;dom&quot;</span>,
        ele: <span class="hljs-string">&quot;p&quot;</span>,
        nodeIndex: <span class="hljs-number">2</span>,
        children: [
          { type: <span class="hljs-string">&quot;text&quot;</span>, value: <span class="hljs-string">&quot;456&quot;</span> },
          {
            type: <span class="hljs-string">&quot;dom&quot;</span>,
            ele: <span class="hljs-string">&quot;span&quot;</span>,
            nodeIndex: <span class="hljs-number">3</span>,
            children: [{ type: <span class="hljs-string">&quot;text&quot;</span>, value: <span class="hljs-string">&quot;789&quot;</span> }],
          },
        ],
      },
    ],
  },
};
</code></pre> <p data-nodeid="68628">这个 AST 对象维护我们需要的一些信息，包括 HTML 元素里：</p> <ul data-nodeid="68629"><li data-nodeid="68630"><p data-nodeid="68631">需要绑定哪些变量（变量更新的时候需要更新该节点内容）；</p></li> <li data-nodeid="68632"><p data-nodeid="68633">是否有其他的逻辑需要处理（比如含有逻辑指令，如<code data-backticks="1" data-nodeid="68762">v-if</code>、<code data-backticks="1" data-nodeid="68764">v-for</code>等）；</p></li> <li data-nodeid="68634"><p data-nodeid="68635">哪些节点绑定了事件监听事件（是否匹配一些常用的事件能力支持，如<code data-backticks="1" data-nodeid="68767">@click</code>）。</p></li></ul> <p data-nodeid="68636">模板引擎会根据 AST 对象生成最终的页面片段和逻辑，在这个过程中会通过添加特殊标识（例如元素 ID、属性标记等）的方式来标记 DOM 节点，配合 DOM 元素选择方式、事件监听方式等，在需要更新的时候可快速定位到该 DOM 节点，并进行节点内容更新，从而实现页面内容的更新。</p> <p data-nodeid="68637">目前来说，前端模板渲染的实现一般分为以下两种方式。</p> <ol data-nodeid="68638"><li data-nodeid="68639"><p data-nodeid="68640">字符串模版方式：使用拼接的方式生成 DOM 字符串，直接通过<code data-backticks="1" data-nodeid="68772">innderHTML()</code>插入页面。</p></li> <li data-nodeid="68641"><p data-nodeid="68642">节点模版方式：使用<code data-backticks="1" data-nodeid="68775">createElement()</code>/<code data-backticks="1" data-nodeid="68777">appendChild()</code>/<code data-backticks="1" data-nodeid="68779">textContent</code>等方法动态地插入 DOM 节点。</p></li></ol> <p data-nodeid="68643">在使用字符串模版的时候，我们将<code data-backticks="1" data-nodeid="68782">nodeIndex</code>绑定在元素属性上，主要用于在数据更新时追寻节点进行内容更新。</p> <p data-nodeid="68644">在使用节点模版的时候，我们可在创建节点时将该节点保存下来，直接用于数据更新：</p> <pre data-nodeid="68645" class="lang-java"><code data-language="java">// 假设这是一个生成 DOM 的过程，包括 innerHTML 和事件监听
function generateDOM(astObject) {
  const { dom, binding = [] } = astObject;
  // 生成DOM，这里假装当前节点是baseDom
  baseDom.innerHTML = getDOMString(dom);
  // 对于数据绑定的，来进行监听更新吧
  baseDom.addEventListener(&quot;data:change&quot;, (name, value) =&gt; {
    // 寻找匹配的数据绑定
    const obj = binding.find((x) =&gt; x.valueName == name);
    // 若找到值绑定的对应节点，则更新其值。
    if (obj) {
      baseDom.find(`[data-node-index=&quot;${obj.nodeIndex}&quot;]`).innerHTML = value;
    }
  });
}
// 获取DOM字符串，这里简单拼成字符串
function getDOMString(domObj) {
  // 无效对象返回''
  if (!domObj) return &quot;&quot;;
  const { type, children = [], nodeIndex, ele, value } = domObj;
  if (type == &quot;dom&quot;) {
    // 若有子对象，递归返回生成的字符串拼接
    const childString = &quot;&quot;;
    children.forEach((x) =&gt; {
      childString += getDOMString(x);
    });
    // dom对象，拼接生成对象字符串
    return `&lt;${ele} data-node-index=&quot;${nodeIndex}&quot;&gt;${childString}&lt;/${ele}&gt;`;
  } else if (type == &quot;text&quot;) {
    // 若为textNode，返回text的值
    return value;
  }
}
</code></pre> <p data-nodeid="68646">通过上面的方式，前端框架实现了将 AST 对象生成 DOM 元素，并将这些 DOM 元素渲染或更新到页面上。</p> <p data-nodeid="68647">或许你会觉得疑惑：原本就是一个<code data-backticks="1" data-nodeid="68787">&lt;div&gt;</code>HTML 模板，经过 AST 生成一个对象，最终还是生成一个<code data-backticks="1" data-nodeid="68789">&lt;div&gt;</code>DOM 节点，看起来好像挺多余的。</p> <p data-nodeid="68648">实际上，在这个过程中，模板引擎可以实现更多功能。</p> <h4 data-nodeid="68649">模板引擎可以做更多</h4> <p data-nodeid="68650">将 HTML 模板解析成 AST 对象，再根据 AST 对象生成 DOM 节点，在这个过程中前端框架可以实现以下功能：</p> <ol data-nodeid="68651"><li data-nodeid="68652"><p data-nodeid="68653">排除无效 DOM 元素（非自定义组件、也非默认组件的 DOM 元素），在构建阶段可及时发现并进行报错；</p></li> <li data-nodeid="68654"><p data-nodeid="68655">可识别出自定义组件，并渲染对应的组件；</p></li> <li data-nodeid="68656"><p data-nodeid="68657">可方便地实现数据绑定、事件绑定等功能；</p></li> <li data-nodeid="68658"><p data-nodeid="68659">为虚拟 DOM Diff 过程打下铺垫；</p></li> <li data-nodeid="68660"><p data-nodeid="68661">HTML 转义（预防 XSS 漏洞）。</p></li></ol> <p data-nodeid="68662">这里我们以第 5 点预防 XSS 漏洞为例子，详细地介绍一下模板引擎是如何避免 XSS 攻击的。</p> <h4 data-nodeid="68663">预防 XSS 漏洞</h4> <p data-nodeid="68664">我们知道 XSS 的整个攻击过程大概为：</p> <ol data-nodeid="68665"><li data-nodeid="68666"><p data-nodeid="68667">攻击者提交含有恶意代码的内容（比如 JavaScript 脚本）；</p></li> <li data-nodeid="68668"><p data-nodeid="68669">页面渲染的时候，这些内容未被过滤就被加载处理，比如获取 Cookie、执行操作等；</p></li> <li data-nodeid="68670"><p data-nodeid="68671">其他用户在浏览页面的时候，就会在加载到恶意代码时受到攻击。</p></li></ol> <p data-nodeid="68672">要避免网站用户受到 XSS 攻击，主要方法是将用户提交的内容进行过滤处理。大多数前端框架会自带 HTML 转义功能，从而避免的 XSS 攻击。</p> <p data-nodeid="68673">以 Vue 为例，使用默认的数据绑定方式（双大括号、<code data-backticks="1" data-nodeid="68807">v-bind</code>等）会进行 HTML 转义，将数据解释为普通文本，而非 HTML 代码。</p> <p data-nodeid="68674">除此预防 XSS 漏洞之外，前端框架还做了一些性能、安全性等方面的优化，也提供了一些用于项目开发配套的工具，包括路由的管理、状态和数据的管理等工具。</p> <h3 data-nodeid="68675">小结</h3> <p data-nodeid="68676">今天我带大家了解了前端框架的出现，由于前端框架帮开发者解决了很多重复性的工作（拼接 HTML 模板、DOM 元素查找、DOM 元素事件监听等），极大地提升了开发者的效率，同时还提升了代码的可读性和可维护性，因此受到很多前端开发的追捧。</p> <p data-nodeid="68677">除此之外，我还介绍了前端框架中模板引擎的实现原理，包括解析语法生成 AST 对象、根据 AST 对象生成 DOM 元素，并对生成的 DOM 元素进行标记，则可以在变量改变的时候，解析找到相应的 DOM 元素进行内容的更新。</p> <p data-nodeid="68678">在了解这些内容之后，我们可以在页面渲染遇到性能问题的时候，根据所使用框架的具体实现，找到可能导致页面渲染卡顿或是不流畅的原因。除此之外，在使用框架的过程中，遇到一些语法报错、XSS 安全漏洞等问题的时候，也可以快速找到解决办法。</p> <p data-nodeid="68679">今日思考：React.js 中的 JSX 和模板引擎是什么关系？在留言区写出你的想法！</p> <hr> <h3 id="精选评论"><a href="#精选评论" class="header-anchor">#</a> 精选评论</h3> <h5 id="宇"><a href="#宇" class="header-anchor">#</a> **宇：</h5> <blockquote><p>jsx会被babel编译成React.createElement()，用来创建相应的虚拟dom对象，后面会被reactdom或者react native等不同平台的渲染库渲染成ui或者SSR。之所以发明jsx是因为，React.createElement太过繁琐，jsx可以像写html一样写ui，同时也保留了部分js的能力。题外话：其实Facebook最初并没有打算让createElement作为jsx的编译产物，因为它里面的defaultValue，propType，ref key的拦截等等逻辑比较浪费性能，对props的属性有O(n)级别的复杂度，本来只是作为让用户临时手动生产虚拟dom的一个补充手段，但因为当时只有它是最好的选择，所以才这样了，react17以后可能有变化。</p></blockquote> <h5 id="浩"><a href="#浩" class="header-anchor">#</a> *浩：</h5> <blockquote><p>今日思考的回答：React中的jsx本质是JavaScript语法的扩展，充分具备JavaScript能力，这就能让developer像写JavaScript一样写UI，我们写的虽然是jsx，借助babel等类似的工具的转化，最终还是会编译成React.createElement()这样的函数去生成虚拟DOM，后面生成AST,再由AST生成真实DOM,这些过程应该跟老师经的一样吧，有写错的地方，望老师批评指正。</p></blockquote> <h5 id="_856"><a href="#_856" class="header-anchor">#</a> 856：</h5> <blockquote><p>jsx 是把代码转成react可以解读的代码，并没有生成dom模板引擎是通过自己的语法生成dom 相同点都是用自己的语法 写html ,底层实现操作dom</p></blockquote> <h6 id="讲师回复"><a href="#讲师回复" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    大体上差不多，但也不一定是通过自己的语法生成 DOM，可以考虑下 jsx 是如何对接 react 和 vue 的</p></blockquote></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/rwerplus/rwerplus.github.io/edit/master/docs/01.前端/01.前端开发笔记/10.掌握前端框架模板引擎的实现原理.md" target="_blank" rel="noopener noreferrer">去GitHub编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/15, 02:26:10</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b206ba/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">改善编程思维：从事件驱动到数据驱动</div></a> <a href="/pages/49a69e/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">为什么小程序特立独行</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b206ba/" class="prev">改善编程思维：从事件驱动到数据驱动</a></span> <span class="next"><a href="/pages/49a69e/">为什么小程序特立独行</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/49a69e/"><div>
            为什么小程序特立独行
            <!----></div></a> <span class="date">04-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/f761ed/"><div>
            单页应用与前端路由库设计原理
            <!----></div></a> <span class="date">04-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/596343/"><div>
            代码构建与 Webpack 必备技能
            <!----></div></a> <span class="date">04-23</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:localfeng@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/rwerplus" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=88954294" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>花椒和邻居 | <a href="https://github.com/rwerplus/rwerplus.github.io/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.d13a64a1.js" defer></script><script src="/assets/js/2.4651773a.js" defer></script><script src="/assets/js/19.1d3312d9.js" defer></script>
  </body>
</html>
