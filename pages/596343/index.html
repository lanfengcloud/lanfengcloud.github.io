<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>代码构建与 Webpack 必备技能 | 花椒和邻居&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/87452.png">
    <meta name="description" content="web前端技术博客,花椒和邻居sBlog,持续专注web前端学习与总结。Cesium,markdown,JavaScript,js,ES6,TypeScript,vue,React,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.11b57309.css" as="style"><link rel="preload" href="/assets/js/app.7d38c94f.js" as="script"><link rel="preload" href="/assets/js/2.4651773a.js" as="script"><link rel="preload" href="/assets/js/22.17d94390.js" as="script"><link rel="prefetch" href="/assets/js/10.ce591752.js"><link rel="prefetch" href="/assets/js/11.f5344398.js"><link rel="prefetch" href="/assets/js/12.6eb460e9.js"><link rel="prefetch" href="/assets/js/13.d3c1e6f1.js"><link rel="prefetch" href="/assets/js/14.8a7cb2b8.js"><link rel="prefetch" href="/assets/js/15.8e64b536.js"><link rel="prefetch" href="/assets/js/16.1ccfaf3d.js"><link rel="prefetch" href="/assets/js/17.b9644e7b.js"><link rel="prefetch" href="/assets/js/18.02c9e60c.js"><link rel="prefetch" href="/assets/js/19.1d3312d9.js"><link rel="prefetch" href="/assets/js/20.33a2e48f.js"><link rel="prefetch" href="/assets/js/21.cbd55d73.js"><link rel="prefetch" href="/assets/js/23.71f3318d.js"><link rel="prefetch" href="/assets/js/24.52e90323.js"><link rel="prefetch" href="/assets/js/25.b502869e.js"><link rel="prefetch" href="/assets/js/26.6f44735e.js"><link rel="prefetch" href="/assets/js/27.1d65aca3.js"><link rel="prefetch" href="/assets/js/28.98366502.js"><link rel="prefetch" href="/assets/js/29.aeaeb5e3.js"><link rel="prefetch" href="/assets/js/3.c999fa3c.js"><link rel="prefetch" href="/assets/js/30.b3434784.js"><link rel="prefetch" href="/assets/js/31.9a104273.js"><link rel="prefetch" href="/assets/js/32.b09ab3dc.js"><link rel="prefetch" href="/assets/js/33.906f5e48.js"><link rel="prefetch" href="/assets/js/34.65f2ade3.js"><link rel="prefetch" href="/assets/js/35.638ad7c5.js"><link rel="prefetch" href="/assets/js/36.16ab1509.js"><link rel="prefetch" href="/assets/js/37.851d308f.js"><link rel="prefetch" href="/assets/js/38.9c9c5f69.js"><link rel="prefetch" href="/assets/js/39.8da9fa39.js"><link rel="prefetch" href="/assets/js/4.d82326e8.js"><link rel="prefetch" href="/assets/js/40.252d8608.js"><link rel="prefetch" href="/assets/js/41.81e7aef1.js"><link rel="prefetch" href="/assets/js/42.c70af93c.js"><link rel="prefetch" href="/assets/js/43.acbd19b9.js"><link rel="prefetch" href="/assets/js/44.8db3762d.js"><link rel="prefetch" href="/assets/js/45.e2e6b96f.js"><link rel="prefetch" href="/assets/js/46.c2281ad8.js"><link rel="prefetch" href="/assets/js/47.9b4b10b9.js"><link rel="prefetch" href="/assets/js/48.4a87ce48.js"><link rel="prefetch" href="/assets/js/49.a2e7a0eb.js"><link rel="prefetch" href="/assets/js/5.1a2700dd.js"><link rel="prefetch" href="/assets/js/50.1e264e29.js"><link rel="prefetch" href="/assets/js/51.5b27ad72.js"><link rel="prefetch" href="/assets/js/52.f45fd595.js"><link rel="prefetch" href="/assets/js/53.151f1dbf.js"><link rel="prefetch" href="/assets/js/54.689022c8.js"><link rel="prefetch" href="/assets/js/55.e46d9867.js"><link rel="prefetch" href="/assets/js/56.dc2831a1.js"><link rel="prefetch" href="/assets/js/57.7072ff5d.js"><link rel="prefetch" href="/assets/js/58.54f07e7e.js"><link rel="prefetch" href="/assets/js/59.eafc095d.js"><link rel="prefetch" href="/assets/js/6.c4610236.js"><link rel="prefetch" href="/assets/js/60.314af2d6.js"><link rel="prefetch" href="/assets/js/61.3862b3af.js"><link rel="prefetch" href="/assets/js/62.a4cccce2.js"><link rel="prefetch" href="/assets/js/63.dfc009ae.js"><link rel="prefetch" href="/assets/js/64.8f216c0d.js"><link rel="prefetch" href="/assets/js/65.cb92cce0.js"><link rel="prefetch" href="/assets/js/66.7da08f3c.js"><link rel="prefetch" href="/assets/js/67.8f5d2a42.js"><link rel="prefetch" href="/assets/js/68.6eea4628.js"><link rel="prefetch" href="/assets/js/69.b9654bda.js"><link rel="prefetch" href="/assets/js/7.a5bff2b9.js"><link rel="prefetch" href="/assets/js/70.97bf8b83.js"><link rel="prefetch" href="/assets/js/71.ba0a87e1.js"><link rel="prefetch" href="/assets/js/72.84b055cd.js"><link rel="prefetch" href="/assets/js/73.7ab818f4.js"><link rel="prefetch" href="/assets/js/74.2fac3511.js"><link rel="prefetch" href="/assets/js/75.688b385a.js"><link rel="prefetch" href="/assets/js/76.e5a15c1b.js"><link rel="prefetch" href="/assets/js/8.4ac93032.js"><link rel="prefetch" href="/assets/js/9.d31b45ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.11b57309.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="花椒和邻居's Blog" class="logo"> <span class="site-name can-hide">花椒和邻居's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/open/" class="nav-link">开源</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/e58ecf/" class="nav-link">Java程序员</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/f2e63f.html" class="nav-link">随笔</a></div> <a href="https://github.com/rwerplus/rwerplus.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/ava.2gamq0p5pj8k.webp"> <div class="blogger-info"><h3>花椒和邻居</h3> <span>工作了三年半的前端实习生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/open/" class="nav-link">开源</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/e58ecf/" class="nav-link">Java程序员</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/f2e63f.html" class="nav-link">随笔</a></div> <a href="https://github.com/rwerplus/rwerplus.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端开发笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/86005a/" class="sidebar-link">重识 HTML，掌握页面基本结构和加载过程</a></li><li><a href="/pages/21c2f2/" class="sidebar-link">CSS：页面布局的基本规则和方式</a></li><li><a href="/pages/884d6e/" class="sidebar-link">JavaScript 如何实现继承？</a></li><li><a href="/pages/13ef6c/" class="sidebar-link">JavaScript 引擎如何执行 JavaScript 代码？</a></li><li><a href="/pages/c3f2e0/" class="sidebar-link">单线程的 JavaScript 如何管理任务？</a></li><li><a href="/pages/6fddea/" class="sidebar-link">一个网络请求是怎么进行的？</a></li><li><a href="/pages/595abe/" class="sidebar-link">HTTP 协议和前端开发有什么关系？</a></li><li><a href="/pages/53ab0a/" class="sidebar-link">深入剖析浏览器中页面的渲染过程</a></li><li><a href="/pages/b206ba/" class="sidebar-link">改善编程思维：从事件驱动到数据驱动</a></li><li><a href="/pages/ea57d2/" class="sidebar-link">掌握前端框架模板引擎的实现原理</a></li><li><a href="/pages/49a69e/" class="sidebar-link">为什么小程序特立独行</a></li><li><a href="/pages/f761ed/" class="sidebar-link">单页应用与前端路由库设计原理</a></li><li><a href="/pages/596343/" aria-current="page" class="active sidebar-link">代码构建与 Webpack 必备技能</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/996215/" class="sidebar-link">提升编程体验：组件化与模块化设计</a></li><li><a href="/pages/7d3a8a/" class="sidebar-link">AngularReactVue 三大前端框架的设计特色</a></li><li><a href="/pages/ddbbb3/" class="sidebar-link">如何设计合适的状态管理方案</a></li><li><a href="/pages/9c6643/" class="sidebar-link">如何搭建前端监控体系为业务排忧解难</a></li><li><a href="/pages/aeb6b9/" class="sidebar-link">如何进行性能分析的自动化实现</a></li><li><a href="/pages/55cc33/" class="sidebar-link">前端性能优化与解决方案</a></li><li><a href="/pages/ee7a1a/" class="sidebar-link">如何进行技术方案调研与设计</a></li><li><a href="/pages/b1d475/" class="sidebar-link">如何设计一个前端项目</a></li><li><a href="/pages/8a03a9/" class="sidebar-link">通过前端工程化提升团队开发效率</a></li><li><a href="/pages/e991d8/" class="sidebar-link">大型前端项目的痛点和优化方案</a></li><li><a href="/pages/75d6fd/" class="sidebar-link">如何通过前期准备和后期复盘让项目稳定上线</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3D地图相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/web/#前端" data-v-06225672>前端</a></li><li data-v-06225672><a href="/web/#前端开发笔记" data-v-06225672>前端开发笔记</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/rwerplus" target="_blank" title="作者" class="beLink" data-v-06225672>花椒和邻居</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-04-23</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">代码构建与 Webpack 必备技能<!----></h1>  <div class="theme-vdoing-content content__default"><p data-nodeid="1169">最初的页面开发中，前端实现一个页面只需要在一个文件里完成，包括 HTML/CSS/JavaScript 各种内容。后来，通常将常用的静态资源放置在 CDN，并使用<code data-backticks="1" data-nodeid="1299">&lt;link&gt;</code>和<code data-backticks="1" data-nodeid="1301">&lt;script&gt;</code>的 src 属性引入的方式，来减少页面开发过程中的重复代码编写。</p> <p data-nodeid="1170">如今前端页面的功能越来越复杂，规模也越来越大。为了提升代码的可读性、项目的可维护性，我们会将一些通用的工具和组件进行抽象，代码被有组织地按照一定规则进行划分，比如按照功能划分为页面、组件、工具库、脚本等。</p> <p data-nodeid="1171">这个过程便是模块化，而 JavaScript 中的模块规范不止一种。</p> <h3 data-nodeid="1172">JavaScript 模块</h3> <p data-nodeid="1173">在 JavaScript 中，我们常说的模块规范包括 CommonJS/AMD/UMD/ES6 Module 四种。这些模块规范和定义之间的区别常常容易搞混，我们先来分别看一下。</p> <h4 data-nodeid="1174">CommonJS 规范</h4> <p data-nodeid="1175">CommonJS 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。</p> <p data-nodeid="1176">我们来看一个 CommonJS 规范的模块示例：</p> <pre data-nodeid="1177" class="lang-java"><code data-language="java"><span class="hljs-keyword">var</span> beta = require(<span class="hljs-string">'beta'</span>);
function verb {
  <span class="hljs-keyword">return</span> beta.verb();
}
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
  verb: verb
};
</code></pre> <p data-nodeid="1178">在该示例中，使用<code data-backticks="1" data-nodeid="1311">require()</code>载入模块，使用<code data-backticks="1" data-nodeid="1313">module.exports</code>输出模块 。<br>
一般来说，CommonJS 有以下特点：</p> <ul data-nodeid="1179"><li data-nodeid="1180"><p data-nodeid="1181">一个文件就是一个模块；</p></li> <li data-nodeid="1182"><p data-nodeid="1183">使用<code data-backticks="1" data-nodeid="1319">require()</code>载入模块，使用<code data-backticks="1" data-nodeid="1321">module.exports</code>输出模块，因此各个模块间可以进行交互；</p></li> <li data-nodeid="1184"><p data-nodeid="1185">不支持异步加载。</p></li></ul> <p data-nodeid="1186">或许你已经知道，Node.js 环境使用的便是基于 CommonJS 规范实现的模块系统，而如今我们提到 CommonJS 规范，也基本上认为是 Node.js 系统。</p> <p data-nodeid="1187">为什么浏览器环境不使用 CommonJS 规范呢？这是因为 CommonJS 不支持异步加载，而前面我们也说过，浏览器环境中同步任务的执行会带来性能问题，但对于异步模块定义（AMD）来说就不存在这样的问题。</p> <h4 data-nodeid="1188">AMD</h4> <p data-nodeid="1189">顾名思义，异步模块定义（AMD）主要为了解决异步加载模块而提出，它通过指定模块和依赖项的方式来定义模块。</p> <p data-nodeid="1190">RequireJS 便是基于 AMD 的实现，我们同样可以看一个模块示例：</p> <pre data-nodeid="1191" class="lang-java"><code data-language="java">define(<span class="hljs-string">&quot;alpha&quot;</span>, [<span class="hljs-string">&quot;require&quot;</span>, <span class="hljs-string">&quot;exports&quot;</span>, <span class="hljs-string">&quot;beta&quot;</span>], function (
  require,
  <span class="hljs-keyword">exports</span>,
  beta
) {
  <span class="hljs-keyword">exports</span>.verb = function () {
    <span class="hljs-keyword">return</span> beta.verb();
    <span class="hljs-comment">// 或者可以这么写</span>
    <span class="hljs-keyword">return</span> require(<span class="hljs-string">&quot;beta&quot;</span>).verb();
  };
});
</code></pre> <p data-nodeid="1192">在该示例中，导出 ID 为 alpha 的模块，依赖了 ID 为 beta 的模块。</p> <p data-nodeid="1193">现在我们知道，Node.js 环境中的模块系统基于 CommonJS 规范，而浏览器环境中需要使用 AMD 实现。</p> <p data-nodeid="1194">那么如果我们有一个模块，需要同时能运行在 Node.js 环境和浏览器环境中，要怎么办？我们可以使用 UMD 模式。</p> <h4 data-nodeid="1195">UMD</h4> <p data-nodeid="1196">为了兼容 AMD 和 CommonJS 的规范，通用模块定义（UMD）模式被提出，它在兼容两者的同时，也支持了传统的全局变量模式。</p> <p data-nodeid="1197">我们来看一个 UMD 模式的模块示例：</p> <pre data-nodeid="1198" class="lang-java"><code data-language="java">(function (root, factory) {
  <span class="hljs-keyword">if</span> (typeof define === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; define.amd) {
    <span class="hljs-comment">// AMD</span>
    define([<span class="hljs-string">&quot;jquery&quot;</span>], factory);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">exports</span> === <span class="hljs-string">&quot;object&quot;</span>) {
    <span class="hljs-comment">// CommonJS</span>
    <span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = factory(require(<span class="hljs-string">&quot;jquery&quot;</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 全局变量</span>
    root.returnExports = factory(root.jQuery);
  }
})(<span class="hljs-keyword">this</span>, function ($) {
  <span class="hljs-comment">// ...</span>
});
</code></pre> <p data-nodeid="1199">可以看到，UMD 模块头部通常都会有用来判断模块加载器环境的代码，并根据不同的环境提供了不同的方式进行加载。</p> <p data-nodeid="1200">到这里，似乎不管是 Node.js 环境还是浏览器环境，都有支持的模块规范，也有能相互兼容的模块规范了。那么，ES6 模块又是什么呢？</p> <h4 data-nodeid="1201">ES6 模块</h4> <p data-nodeid="1202">相比于运行时进行加载的 CommonJS 规范，ES6 模块化主要是为了<strong data-nodeid="1343">在编译阶段就可以确定各个模块之间的依赖关系</strong>。</p> <p data-nodeid="1203">我们同样来看一个 ES6 模块的示例代码：</p> <pre data-nodeid="1204" class="lang-java"><code data-language="java"><span class="hljs-comment">// import 导入</span>
<span class="hljs-keyword">import</span> BaseTask, { TaskType } from <span class="hljs-string">&quot;./BaseTask&quot;</span>;
<span class="hljs-comment">// export 导出</span>
export { BaseTask };
</code></pre> <p data-nodeid="1205">在该示例中，使用<code data-backticks="1" data-nodeid="1346">import</code>加载模块，使用<code data-backticks="1" data-nodeid="1348">export</code>输出模块。</p> <p data-nodeid="1206">ES6 模块的特点如下：</p> <ul data-nodeid="1207"><li data-nodeid="1208"><p data-nodeid="1209">使用<code data-backticks="1" data-nodeid="1352">import</code>加载和<code data-backticks="1" data-nodeid="1354">export</code>输出；</p></li> <li data-nodeid="1210"><p data-nodeid="1211">一个模块只会加载一次（CommonJS 也是一样）；</p></li> <li data-nodeid="1212"><p data-nodeid="1213">导出的模块为变量引用，因此可以在内存中共享。</p></li></ul> <p data-nodeid="1214">现在大多数前端项目中都使用 ES6 模块，由于 ES6 模块化目的是编译阶段确定模块间依赖关系，因此我们需要在编译的时候使用 Babel、Webpack 等方式构建依赖关系树。</p> <p data-nodeid="1215">除此之外，ES6 模块化在各个浏览器里的兼容性差异较大，因此同样需要进行 Babal 编译以及 Webpack 进行打包，这个过程我们称之为代码构建。</p> <p data-nodeid="1216">我们来总结一下 CommonJS/AMD/UMD/ES6 Module 这四种模块规范：</p> <ol data-nodeid="1217"><li data-nodeid="1218"><p data-nodeid="1219">CommonJS 规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。</p></li> <li data-nodeid="1220"><p data-nodeid="1221">CommonJS 不支持异步加载，因此异步模块定义（AMD）主要为了解决异步加载模块而提出。</p></li> <li data-nodeid="1222"><p data-nodeid="1223">通用模块定义（UMD）模式用于兼容 AMD 和 CommonJS 的规范。</p></li> <li data-nodeid="1224"><p data-nodeid="1225">CommonJS 规范用于运行时进行模块加载，ES6 模块化可以在编译阶段确定各个模块之间的依赖关系。</p></li></ol> <p data-nodeid="1226">下面，我们一起来看看 Webpack 这个在前端项目中经常出现的工具。</p> <h3 data-nodeid="1227">Webpack 工具都做了些什么</h3> <p data-nodeid="1228">如今前端项目大多数都使用了模块化，而如果想要将多个文件的代码打包成最终可按照预期运行的代码，则需要使用到代码构建工具。</p> <p data-nodeid="1229">不管项目代码是如何进行组织的，项目中又有多少个文件，最终浏览器依然会从 HTML 内容进行解析和加载，因此我们需要对项目中的代码进行构建（包括编译和打包），生成浏览器可正常解析和加载的内容。</p> <p data-nodeid="1230">我们先来认识下常见的前端构建相关的工具。</p> <h4 data-nodeid="1231">常见的前端构建工具</h4> <p data-nodeid="4965">对于前端开发来说，我们会用到各式各样的构建/打包工具，比如这些。</p> <p data-nodeid="4966" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/3F/7C/Cgp9HWCeSsSAHiJFAALlqT5qxqA460.png" alt="图片2.png" data-nodeid="4970"></p> <p data-nodeid="1234">其中，涉及模块化代码打包的主要有 Grunt/Gulp/Webpack/Rollup。很多同学会搞混这几个工具，这里我简单介绍下它们之间的区别。</p> <ol data-nodeid="1235"><li data-nodeid="1236"><p data-nodeid="1237">Gulp/Grunt 是一种能够优化前端工作流程的工具，比如自动刷新页面、combo、压缩 CSS/JavaScript、编译 Less/Sass 等。</p></li> <li data-nodeid="1238"><p data-nodeid="1239">Webpack/Rollup 是一个 JavaScript 的模块打包器，用于整合编译成最终的代码。</p></li> <li data-nodeid="1240"><p data-nodeid="1241">其中，Rollup 通常用来构建库，Webpack 更适合用来构建应用程序。</p></li></ol> <p data-nodeid="1242">对于业务团队来说，进行代码的模块打包更多情况下会选择 Webpack。那么，下面我们主要围绕 Webpack 工具，来介绍代码模块化打包的过程。</p> <h3 data-nodeid="1243">认识 Webpack</h3> <p data-nodeid="1244">相信你肯定也认识 Webpack，要了解一个工具，最好的方式就是从如何使用它开始熟悉。</p> <p data-nodeid="1245">Webpack 的使用中有 4 个核心概念：入口（entry）、输出（output）、Loader、插件（plugins），我们先来分别看看。</p> <h4 data-nodeid="1246">入口（entry）</h4> <p data-nodeid="1247">首先便是入口（entry），entry 指向我们前端应用的第一个启动文件。例如，在 Vue 中是<code data-backticks="1" data-nodeid="1385">new Vue()</code>位置所在的文件，在 Angular 中是启动<code data-backticks="1" data-nodeid="1387">.bootstrap()</code>的文件，在 React 中则是<code data-backticks="1" data-nodeid="1389">ReactDOM.render()</code>或者是<code data-backticks="1" data-nodeid="1391">React.render()</code>的启动文件。</p> <pre data-nodeid="1248" class="lang-java"><code data-language="java"><span class="hljs-comment">// 将entry指向启动文件即可</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
  entry: <span class="hljs-string">&quot;./path/to/my/entry/file.js&quot;</span>,
};
</code></pre> <p data-nodeid="1249">或许你会疑惑，入口的一个文件，又是怎样把整个前端项目中的代码关联起来，并进行打包的呢？</p> <p data-nodeid="3797">实际上， Webpack 会从 entry 开始，通过解析模块间的依赖关系，递归地构建出一个依赖图。我们如果在项目中使用<code data-backticks="1" data-nodeid="3800">webpack-bundle-analyzer</code>插件，也可以看到生成的这样一个依赖图。</p> <p data-nodeid="3798"><img src="https://s0.lgstatic.com/i/image6/M00/3F/85/CioPOWCeSrqACnYnABLbVfl-Zds569.png" alt="图片4.png" data-nodeid="3804"></p> <p data-nodeid="1252">Webpack 会根据依赖图来对各个模块进行整合，最终打包成一个或多个的文件，来提供给浏览器进行加载。</p> <p data-nodeid="1253">既然有入口，那当然就有出口，Webpack 中的出口由输出（output）字段来描述。</p> <h4 data-nodeid="1254">输出（output）</h4> <p data-nodeid="1255">输出（output）字段用于告诉 Webpack 要将打包后的代码生成的文件名是什么（<code data-backticks="1" data-nodeid="1404">filename</code>），以及将它们放在哪里（<code data-backticks="1" data-nodeid="1406">path</code>）。</p> <pre data-nodeid="1256" class="lang-java"><code data-language="java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
  output: {
    filename: <span class="hljs-string">&quot;bundle.js&quot;</span>, <span class="hljs-comment">// 编译文件的文件名，比如 main.js/bundle.js/index.js</span>
    path: <span class="hljs-string">&quot;/home/proj/public/assets&quot;</span>, <span class="hljs-comment">// 对应一个绝对路径，此路径是你希望一次性打包的目录</span>
  },
};
</code></pre> <p data-nodeid="1257">有了 entry 和 output，我们来看看 Webpack 中间的编译过程中，是怎样用到 Loader 和 Plugins 的。</p> <h4 data-nodeid="1258">Loader</h4> <p data-nodeid="1259">要了解 Loader，你需要知道在 Webpack 中，每个文件(<code data-backticks="1" data-nodeid="1411">.css</code>,<code data-backticks="1" data-nodeid="1413">.html</code>,<code data-backticks="1" data-nodeid="1415">.scss</code>,<code data-backticks="1" data-nodeid="1417">.jpg</code>等) 都会被作为模块处理。如果你看过生成的 bundle.js 代码就会发现，Webpack 将所有的模块打包一起，每个模块添加标记 id，通过这样一个 id 去获取所需模块的代码。</p> <p data-nodeid="1260">但实际上，Webpack 只理解 JavaScript，因此 Loader 的作用就是把不同的模块和文件（比如 HTML、CSS、JSX、Typescript 等）转换为 JavaScript 模块。</p> <p data-nodeid="2039">而不同的应用场景需要不同的 Loader，比如我们经常会使用到的 CSS 相关 Loader 和其他资源 Loader。</p> <p data-nodeid="2631"><img src="https://s0.lgstatic.com/i/image6/M01/3F/7C/Cgp9HWCeSqyAWHwvAAHProznCQc246.png" alt="图片3.png" data-nodeid="2635"></p> <p data-nodeid="2632">前面我们说到，ES6 模块需要依赖 Babel 编译和 Webpack 打包，而 Babel 在 Webpack 中就是使用 Loader 的方式来进行编译的。</p> <p data-nodeid="1264">babel-loader 将 ES6/ES7 语法编译生成 ES5，其中部分特性还需要 babel-polyfill 支持。这是因为 Babel 默认只转换新的 JavaScript 语法（比如<code data-backticks="1" data-nodeid="1426">const/let</code>），但不会对新的 API（比如<code data-backticks="1" data-nodeid="1428">Promise</code>）进行处理。</p> <p data-nodeid="1265">Webpack 在编译过程中，支持多个 Loader 通过流水线的方式进行先后编译，编译的顺序为从后往前，最终以 JavaScript 模块的方式输出。</p> <p data-nodeid="1266">到这里，我们知道 Webpack 以 entry 为入口，链式调用各个 Loader 进行编译生成 JavaScript，最终打包放置在 output 中。其中 Loader 只负责将其他非 JavaScript 模块转换成 JavaScript 模块。</p> <p data-nodeid="1267">那 Webpack 又是怎样地对这些代码进行组织并生成文件呢？这就是插件 Plugins 负责的事情。</p> <h4 data-nodeid="1268">插件（plugins）</h4> <p data-nodeid="1269">插件（plugins）主要负责解决 Loader 无法做到的事情，它可以访问在 Webpack 编译过程中的关键事件，对 Webpack 内部示例的一些数据进行处理，处理完成后回调 Webpack 让其继续。</p> <p data-nodeid="1270">这样说或许有些抽象，我们直接来看看几个常用的插件就明白了。</p> <ul data-nodeid="1271"><li data-nodeid="1272"><p data-nodeid="1273">HtmlwebpackPlugin：可以生成创建 HTML 入口文件，也可以为 HTML 文件中引入的外部资源如 script、link 动态添加每次编译后的哈希值，防止引用缓存的外部文件问题。</p></li> <li data-nodeid="1274"><p data-nodeid="1275">CommonsChunkPlugin：用来提取代码中的公共模块，并将这些公共模块按照预期进行打包生成独立的文件。</p></li> <li data-nodeid="1276"><p data-nodeid="1277">ProvidePlugin：用来定义标识符，当遇到指定标识符的时候自动加载模块，适合引入的全局变量（比如 jQuery）。</p></li> <li data-nodeid="1278"><p data-nodeid="1279">ExtractTextPlugin：可以将样式从 JavaScript 中抽出，生成单独的 .css 样式文件。</p></li></ul> <p data-nodeid="1280">看到这里你应该已经明白了，<strong data-nodeid="1445">插件可以用来控制最终生成的代码是如何进行组织和输出的，包括对代码的打包优化、压缩，甚至是启用模块热替换、重新定义环境中的变量，等等</strong>。</p> <p data-nodeid="1281">那么，现在我们已经知道 Webpack 到底对项目代码做了什么。</p> <ol data-nodeid="1282"><li data-nodeid="1283"><p data-nodeid="1284">通过 entry 指定的入口开始，解析各个文件模块间的依赖。</p></li> <li data-nodeid="1285"><p data-nodeid="1286">根据模块间的依赖关系，开始对各个模块进行编译。</p></li> <li data-nodeid="1287"><p data-nodeid="1288">编译过程中，根据配置的规则对一些模块使用 Loader 进行编译处理。</p></li> <li data-nodeid="1289"><p data-nodeid="1290">根据插件的配置，对 Loader 编译后的代码进行封装、优化、分块、压缩等。</p></li> <li data-nodeid="1291"><p data-nodeid="1292">最终 Webpack 整合各个模块，根据依赖关系将它们打包成最终的一个或者多个文件。</p></li></ol> <p data-nodeid="1293">这便是 Webpack 做的事情：<strong data-nodeid="1456">让前端项目中模块化的代码能最终在浏览器中进行加载、并正常地工作。</strong></p> <h3 data-nodeid="1294">小结</h3> <p data-nodeid="1295">如今几乎大多数框架的代码构建工具（比如 Vue CLI、Create React App 等）底层实现都依赖 Webpack。虽然这些前端框架都提供了完善的脚手架，也提供了丰富的配置功能，但如果想要对自己的项目进行更多优化，我们依然需要自己调整 Webpack 配置，因此对它的掌握也是不可少的。</p> <p data-nodeid="1296">对于前端来说，自动化工具的出现，大大降低了应用的开发和维护成本，也因此前端生态也日益丰富和完善。善用这些工具来解决开发过程中的痛点，是作为现代前端开发的必备技能。比如，我们可以使用 Webpack 的 Loader 和插件，实现自己的 AST 语法分析和代码处理过程，这也是许多前端框架在做的事情。</p> <p data-nodeid="1297">如果你要做一个在编译时自动给 Class 类加上指定装饰器的能力，你认为是应该使用 Loader 还是 Plugins 呢？可以在留言区留下你的想法和实现逻辑。</p> <hr> <h3 id="精选评论"><a href="#精选评论" class="header-anchor">#</a> 精选评论</h3> <h5 id="庆"><a href="#庆" class="header-anchor">#</a> *庆：</h5> <blockquote><p>在编译时自动给 Class 类加上指定装饰器的能力: 由于这需要在编译时进行处理，所以应该是使用Loader，因为Loader就是根据特定的规则对模块进行编译处理，而Plugins是对Loader编译后的代码进行处理</p></blockquote> <h6 id="讲师回复"><a href="#讲师回复" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    嗯，可以使用 babel loader 提供的能力实现</p></blockquote> <h5 id="console-man"><a href="#console-man" class="header-anchor">#</a> console_man：</h5> <blockquote><p>涉及到代码修改都是loader，plugin并不负责代码修改</p></blockquote> <h5 id="振"><a href="#振" class="header-anchor">#</a> *振：</h5> <blockquote><p>我猜应该是插件吧，一旦 webpack 即将处理 js 文件，就加上装饰器，然后返回给 webpack 继续执行。</p></blockquote> <h6 id="讲师回复-2"><a href="#讲师回复-2" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    Loader 可以做到哦，babel loader 就提供了这样的能力</p></blockquote> <h5 id="雨"><a href="#雨" class="header-anchor">#</a> *雨：</h5> <blockquote><p>用Plugins，类似HtmlwebpackPlugin，生成文档DOM对象，遍历每个node的class</p></blockquote> <h6 id="讲师回复-3"><a href="#讲师回复-3" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    可以通过 loader 处理的 AST 对象中加上装饰器</p></blockquote> <h5 id="军"><a href="#军" class="header-anchor">#</a> *军：</h5> <blockquote><p>简单点就是只要涉及改变输出结果的那就是plugin，loader只是辅助webpack进行解析</p></blockquote> <h6 id="讲师回复-4"><a href="#讲师回复-4" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    实际上，loader 在解析过程中可以拿到 AST，因此也可以对 AST 进行修改，比如 babel 相关的 loader 便会在适当的时候在代码中添加 polyfill。</p></blockquote> <h5 id="聪"><a href="#聪" class="header-anchor">#</a> *聪：</h5> <blockquote><p>Loader 的作用就是把不同的模块和文件（比如 HTML、CSS、JSX、Typescript 等）转换为 JavaScript 模块。其他的功能应该都是使用Plugins吧</p></blockquote> <h6 id="讲师回复-5"><a href="#讲师回复-5" class="header-anchor">#</a>     讲师回复：</h6> <blockquote><p>    Loader 在转换过程中也可以进行自定义的处理哦</p></blockquote></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/rwerplus/rwerplus.github.io/edit/master/docs/01.前端/01.前端开发笔记/13.代码构建与 Webpack 必备技能.md" target="_blank" rel="noopener noreferrer">去GitHub编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/23, 06:56:29</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/f761ed/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">单页应用与前端路由库设计原理</div></a> <a href="/pages/996215/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">提升编程体验：组件化与模块化设计</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/f761ed/" class="prev">单页应用与前端路由库设计原理</a></span> <span class="next"><a href="/pages/996215/">提升编程体验：组件化与模块化设计</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/49a69e/"><div>
            为什么小程序特立独行
            <!----></div></a> <span class="date">04-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/f761ed/"><div>
            单页应用与前端路由库设计原理
            <!----></div></a> <span class="date">04-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/996215/"><div>
            提升编程体验：组件化与模块化设计
            <!----></div></a> <span class="date">04-23</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:localfeng@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/rwerplus" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=88954294" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>花椒和邻居 | <a href="https://github.com/rwerplus/rwerplus.github.io/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.7d38c94f.js" defer></script><script src="/assets/js/2.4651773a.js" defer></script><script src="/assets/js/22.17d94390.js" defer></script>
  </body>
</html>
